{"ast":null,"code":"'use strict';\n\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar DiscordAPIError = require('./DiscordAPIError');\n\nvar HTTPError = require('./HTTPError');\n\nvar _require = require('../util/Constants'),\n    RATE_LIMIT = _require.Events.RATE_LIMIT,\n    browser = _require.browser;\n\nvar Util = require('../util/Util');\n\nfunction parseResponse(res) {\n  if (res.headers.get('content-type').startsWith('application/json')) return res.json();\n  if (browser) return res.blob();\n  return res.buffer();\n}\n\nfunction getAPIOffset(serverDate) {\n  return new Date(serverDate).getTime() - Date.now();\n}\n\nfunction calculateReset(reset, serverDate) {\n  return new Date(Number(reset) * 1000).getTime() - getAPIOffset(serverDate);\n}\n\nvar RequestHandler = /*#__PURE__*/function () {\n  function RequestHandler(manager) {\n    _classCallCheck(this, RequestHandler);\n\n    this.manager = manager;\n    this.busy = false;\n    this.queue = [];\n    this.reset = -1;\n    this.remaining = -1;\n    this.limit = -1;\n    this.retryAfter = -1;\n  }\n\n  _createClass(RequestHandler, [{\n    key: \"push\",\n    value: function push(request) {\n      if (this.busy) {\n        this.queue.push(request);\n        return this.run();\n      } else {\n        return this.execute(request);\n      }\n    }\n  }, {\n    key: \"run\",\n    value: function run() {\n      if (this.queue.length === 0) return Promise.resolve();\n      return this.execute(this.queue.shift());\n    }\n  }, {\n    key: \"execute\",\n    value: function () {\n      var _execute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(item) {\n        var reject, request, resolve, timeout, res, serverDate, limit, remaining, reset, retryAfter, success, data;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this.busy) {\n                  _context.next = 3;\n                  break;\n                }\n\n                this.queue.unshift(item);\n                return _context.abrupt(\"return\", null);\n\n              case 3:\n                this.busy = true;\n                reject = item.reject, request = item.request, resolve = item.resolve; // After calculations and requests have been done, pre-emptively stop further requests\n\n                if (!this.limited) {\n                  _context.next = 15;\n                  break;\n                }\n\n                timeout = this.reset + this.manager.client.options.restTimeOffset - Date.now();\n\n                if (this.manager.client.listenerCount(RATE_LIMIT)) {\n                  /**\n                   * Emitted when the client hits a rate limit while making a request\n                   * @event Client#rateLimit\n                   * @param {Object} rateLimitInfo Object containing the rate limit info\n                   * @param {number} rateLimitInfo.timeout Timeout in ms\n                   * @param {number} rateLimitInfo.limit Number of requests that can be made to this endpoint\n                   * @param {string} rateLimitInfo.method HTTP method used for request that triggered this event\n                   * @param {string} rateLimitInfo.path Path used for request that triggered this event\n                   * @param {string} rateLimitInfo.route Route used for request that triggered this event\n                   */\n                  this.manager.client.emit(RATE_LIMIT, {\n                    timeout: timeout,\n                    limit: this.limit,\n                    method: request.method,\n                    path: request.path,\n                    route: request.route\n                  });\n                }\n\n                if (!this.manager.globalTimeout) {\n                  _context.next = 13;\n                  break;\n                }\n\n                _context.next = 11;\n                return this.manager.globalTimeout;\n\n              case 11:\n                _context.next = 15;\n                break;\n\n              case 13:\n                _context.next = 15;\n                return Util.delayFor(timeout);\n\n              case 15:\n                _context.prev = 15;\n                _context.next = 18;\n                return request.make();\n\n              case 18:\n                res = _context.sent;\n                _context.next = 25;\n                break;\n\n              case 21:\n                _context.prev = 21;\n                _context.t0 = _context[\"catch\"](15);\n                // NodeFetch error expected for all \"operational\" errors, such as 500 status code\n                this.busy = false;\n                return _context.abrupt(\"return\", reject(new HTTPError(_context.t0.message, _context.t0.constructor.name, _context.t0.status, request.method, request.path)));\n\n              case 25:\n                if (!(res && res.headers)) {\n                  _context.next = 41;\n                  break;\n                }\n\n                serverDate = res.headers.get('date');\n                limit = res.headers.get('x-ratelimit-limit');\n                remaining = res.headers.get('x-ratelimit-remaining');\n                reset = res.headers.get('x-ratelimit-reset');\n                retryAfter = res.headers.get('retry-after');\n                this.limit = limit ? Number(limit) : Infinity;\n                this.remaining = remaining ? Number(remaining) : 1;\n                this.reset = reset ? calculateReset(reset, serverDate) : Date.now();\n                this.retryAfter = retryAfter ? Number(retryAfter) : -1; // https://github.com/discordapp/discord-api-docs/issues/182\n\n                if (item.request.route.includes('reactions')) {\n                  this.reset = new Date(serverDate).getTime() - getAPIOffset(serverDate) + 250;\n                } // Handle global ratelimit\n\n\n                if (!res.headers.get('x-ratelimit-global')) {\n                  _context.next = 41;\n                  break;\n                }\n\n                // Set the manager's global timeout as the promise for other requests to \"wait\"\n                this.manager.globalTimeout = Util.delayFor(this.retryAfter); // Wait for the global timeout to resolve before continuing\n\n                _context.next = 40;\n                return this.manager.globalTimeout;\n\n              case 40:\n                // Clean up global timeout\n                this.manager.globalTimeout = null;\n\n              case 41:\n                // Finished handling headers, safe to unlock manager\n                this.busy = false;\n\n                if (!res.ok) {\n                  _context.next = 50;\n                  break;\n                }\n\n                _context.next = 45;\n                return parseResponse(res);\n\n              case 45:\n                success = _context.sent;\n                // Nothing wrong with the request, proceed with the next one\n                resolve(success);\n                return _context.abrupt(\"return\", this.run());\n\n              case 50:\n                if (!(res.status === 429)) {\n                  _context.next = 58;\n                  break;\n                }\n\n                // A ratelimit was hit - this should never happen\n                this.queue.unshift(item);\n                this.manager.client.emit('debug', \"429 hit on route \".concat(item.request.route));\n                _context.next = 55;\n                return Util.delayFor(this.retryAfter);\n\n              case 55:\n                return _context.abrupt(\"return\", this.run());\n\n              case 58:\n                if (!(res.status >= 500 && res.status < 600)) {\n                  _context.next = 68;\n                  break;\n                }\n\n                if (!(item.retries === this.manager.client.options.retryLimit)) {\n                  _context.next = 63;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", reject(new HTTPError(res.statusText, res.constructor.name, res.status, item.request.method, request.path)));\n\n              case 63:\n                item.retries++;\n                this.queue.unshift(item);\n                return _context.abrupt(\"return\", this.run());\n\n              case 66:\n                _context.next = 80;\n                break;\n\n              case 68:\n                _context.prev = 68;\n                _context.next = 71;\n                return parseResponse(res);\n\n              case 71:\n                data = _context.sent;\n\n                if (!(res.status >= 400 && res.status < 500)) {\n                  _context.next = 74;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", reject(new DiscordAPIError(request.path, data, request.method, res.status)));\n\n              case 74:\n                return _context.abrupt(\"return\", null);\n\n              case 77:\n                _context.prev = 77;\n                _context.t1 = _context[\"catch\"](68);\n                return _context.abrupt(\"return\", reject(new HTTPError(_context.t1.message, _context.t1.constructor.name, _context.t1.status, request.method, request.path)));\n\n              case 80:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[15, 21], [68, 77]]);\n      }));\n\n      function execute(_x) {\n        return _execute.apply(this, arguments);\n      }\n\n      return execute;\n    }()\n  }, {\n    key: \"limited\",\n    get: function get() {\n      return Boolean(this.manager.globalTimeout) || this.remaining <= 0 && Date.now() < this.reset;\n    }\n  }, {\n    key: \"_inactive\",\n    get: function get() {\n      return this.queue.length === 0 && !this.limited && this.busy !== true;\n    }\n  }]);\n\n  return RequestHandler;\n}();\n\nmodule.exports = RequestHandler;","map":null,"metadata":{},"sourceType":"module"}