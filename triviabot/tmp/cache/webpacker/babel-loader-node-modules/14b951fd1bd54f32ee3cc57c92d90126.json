{"ast":null,"code":"'use strict';\n\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _createForOfIteratorHelper(o) { if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar Base = require('./Base');\n\nvar GuildAuditLogs = require('./GuildAuditLogs');\n\nvar GuildPreview = require('./GuildPreview');\n\nvar Integration = require('./Integration');\n\nvar Invite = require('./Invite');\n\nvar VoiceRegion = require('./VoiceRegion');\n\nvar Webhook = require('./Webhook');\n\nvar GuildChannelManager = require('../managers/GuildChannelManager');\n\nvar GuildEmojiManager = require('../managers/GuildEmojiManager');\n\nvar GuildMemberManager = require('../managers/GuildMemberManager');\n\nvar PresenceManager = require('../managers/PresenceManager');\n\nvar RoleManager = require('../managers/RoleManager');\n\nvar VoiceStateManager = require('../managers/VoiceStateManager');\n\nvar Collection = require('../util/Collection');\n\nvar _require = require('../util/Constants'),\n    ChannelTypes = _require.ChannelTypes,\n    DefaultMessageNotifications = _require.DefaultMessageNotifications,\n    PartialTypes = _require.PartialTypes,\n    VerificationLevels = _require.VerificationLevels,\n    ExplicitContentFilterLevels = _require.ExplicitContentFilterLevels;\n\nvar DataResolver = require('../util/DataResolver');\n\nvar Snowflake = require('../util/Snowflake');\n\nvar SystemChannelFlags = require('../util/SystemChannelFlags');\n\nvar Util = require('../util/Util');\n/**\n * Represents a guild (or a server) on Discord.\n * <info>It's recommended to see if a guild is available before performing operations or reading data from it. You can\n * check this with `guild.available`.</info>\n * @extends {Base}\n */\n\n\nvar Guild = /*#__PURE__*/function (_Base) {\n  _inherits(Guild, _Base);\n\n  var _super = _createSuper(Guild);\n\n  /**\n   * @param {Client} client The instantiating client\n   * @param {Object} data The data for the guild\n   */\n  function Guild(client, data) {\n    var _this;\n\n    _classCallCheck(this, Guild);\n\n    _this = _super.call(this, client);\n    /**\n     * A manager of the members belonging to this guild\n     * @type {GuildMemberManager}\n     */\n\n    _this.members = new GuildMemberManager(_assertThisInitialized(_this));\n    /**\n     * A manager of the channels belonging to this guild\n     * @type {GuildChannelManager}\n     */\n\n    _this.channels = new GuildChannelManager(_assertThisInitialized(_this));\n    /**\n     * A manager of the roles belonging to this guild\n     * @type {RoleManager}\n     */\n\n    _this.roles = new RoleManager(_assertThisInitialized(_this));\n    /**\n     * A manager of the presences belonging to this guild\n     * @type {PresenceManager}\n     */\n\n    _this.presences = new PresenceManager(_this.client);\n    /**\n     * A manager of the voice states of this guild\n     * @type {VoiceStateManager}\n     */\n\n    _this.voiceStates = new VoiceStateManager(_assertThisInitialized(_this));\n    /**\n     * Whether the bot has been removed from the guild\n     * @type {boolean}\n     */\n\n    _this.deleted = false;\n    if (!data) return _possibleConstructorReturn(_this);\n\n    if (data.unavailable) {\n      /**\n       * Whether the guild is available to access. If it is not available, it indicates a server outage\n       * @type {boolean}\n       */\n      _this.available = false;\n      /**\n       * The Unique ID of the guild, useful for comparisons\n       * @type {Snowflake}\n       */\n\n      _this.id = data.id;\n    } else {\n      _this._patch(data);\n\n      if (!data.channels) _this.available = false;\n    }\n    /**\n     * The id of the shard this Guild belongs to.\n     * @type {number}\n     */\n\n\n    _this.shardID = data.shardID;\n    return _this;\n  }\n  /**\n   * The Shard this Guild belongs to.\n   * @type {WebSocketShard}\n   * @readonly\n   */\n\n\n  _createClass(Guild, [{\n    key: \"_patch\",\n\n    /**\n     * Sets up the guild.\n     * @param {*} data The raw data of the guild\n     * @private\n     */\n    value: function _patch(data) {\n      /**\n       * The name of the guild\n       * @type {string}\n       */\n      this.name = data.name;\n      /**\n       * The hash of the guild icon\n       * @type {?string}\n       */\n\n      this.icon = data.icon;\n      /**\n       * The hash of the guild splash image (VIP only)\n       * @type {?string}\n       */\n\n      this.splash = data.splash;\n      /**\n       * The region the guild is located in\n       * @type {string}\n       */\n\n      this.region = data.region;\n      /**\n       * The full amount of members in this guild\n       * @type {number}\n       */\n\n      this.memberCount = data.member_count || this.memberCount;\n      /**\n       * Whether the guild is \"large\" (has more than 250 members)\n       * @type {boolean}\n       */\n\n      this.large = Boolean('large' in data ? data.large : this.large);\n      /**\n       * An array of enabled guild features, here are the possible values:\n       * * ANIMATED_ICON\n       * * BANNER\n       * * COMMERCE\n       * * DISCOVERABLE\n       * * FEATURABLE\n       * * INVITE_SPLASH\n       * * NEWS\n       * * PARTNERED\n       * * PUBLIC\n       * * PUBLIC_DISABLED\n       * * VANITY_URL\n       * * VERIFIED\n       * * VIP_REGIONS\n       * * WELCOME_SCREEN_ENABLED\n       * @typedef {string} Features\n       */\n\n      /**\n       * An array of guild features partnered guilds have enabled\n       * @type {Features[]}\n       */\n\n      this.features = data.features;\n      /**\n       * The ID of the application that created this guild (if applicable)\n       * @type {?Snowflake}\n       */\n\n      this.applicationID = data.application_id;\n      /**\n       * The time in seconds before a user is counted as \"away from keyboard\"\n       * @type {?number}\n       */\n\n      this.afkTimeout = data.afk_timeout;\n      /**\n       * The ID of the voice channel where AFK members are moved\n       * @type {?Snowflake}\n       */\n\n      this.afkChannelID = data.afk_channel_id;\n      /**\n       * The ID of the system channel\n       * @type {?Snowflake}\n       */\n\n      this.systemChannelID = data.system_channel_id;\n      /**\n       * Whether embedded images are enabled on this guild\n       * @type {boolean}\n       */\n\n      this.embedEnabled = data.embed_enabled;\n      /**\n       * The type of premium tier:\n       * * 0: NONE\n       * * 1: TIER_1\n       * * 2: TIER_2\n       * * 3: TIER_3\n       * @typedef {number} PremiumTier\n       */\n\n      /**\n       * The premium tier on this guild\n       * @type {PremiumTier}\n       */\n\n      this.premiumTier = data.premium_tier;\n      /**\n       * The total number of users currently boosting this server\n       * @type {?number}\n       * @name Guild#premiumSubscriptionCount\n       */\n\n      if (typeof data.premium_subscription_count !== 'undefined') {\n        this.premiumSubscriptionCount = data.premium_subscription_count;\n      }\n      /**\n       * Whether widget images are enabled on this guild\n       * @type {?boolean}\n       * @name Guild#widgetEnabled\n       */\n\n\n      if (typeof data.widget_enabled !== 'undefined') this.widgetEnabled = data.widget_enabled;\n      /**\n       * The widget channel ID, if enabled\n       * @type {?string}\n       * @name Guild#widgetChannelID\n       */\n\n      if (typeof data.widget_channel_id !== 'undefined') this.widgetChannelID = data.widget_channel_id;\n      /**\n       * The embed channel ID, if enabled\n       * @type {?string}\n       * @name Guild#embedChannelID\n       */\n\n      if (typeof data.embed_channel_id !== 'undefined') this.embedChannelID = data.embed_channel_id;\n      /**\n       * The verification level of the guild\n       * @type {VerificationLevel}\n       */\n\n      this.verificationLevel = VerificationLevels[data.verification_level];\n      /**\n       * The explicit content filter level of the guild\n       * @type {ExplicitContentFilterLevel}\n       */\n\n      this.explicitContentFilter = ExplicitContentFilterLevels[data.explicit_content_filter];\n      /**\n       * The required MFA level for the guild\n       * @type {number}\n       */\n\n      this.mfaLevel = data.mfa_level;\n      /**\n       * The timestamp the client user joined the guild at\n       * @type {number}\n       */\n\n      this.joinedTimestamp = data.joined_at ? new Date(data.joined_at).getTime() : this.joinedTimestamp;\n      /**\n       * The value set for the guild's default message notifications\n       * @type {DefaultMessageNotifications|number}\n       */\n\n      this.defaultMessageNotifications = DefaultMessageNotifications[data.default_message_notifications] || data.default_message_notifications;\n      /**\n       * The value set for the guild's system channel flags\n       * @type {Readonly<SystemChannelFlags>}\n       */\n\n      this.systemChannelFlags = new SystemChannelFlags(data.system_channel_flags).freeze();\n      /**\n       * The maximum amount of members the guild can have\n       * <info>You will need to fetch the guild using {@link Guild#fetch} if you want to receive this parameter</info>\n       * @type {?number}\n       * @name Guild#maximumMembers\n       */\n\n      if (typeof data.max_members !== 'undefined') this.maximumMembers = data.max_members || 250000;\n      /**\n       * The maximum amount of presences the guild can have\n       * <info>You will need to fetch the guild using {@link Guild#fetch} if you want to receive this parameter</info>\n       * @type {?number}\n       * @name Guild#maximumPresences\n       */\n\n      if (typeof data.max_presences !== 'undefined') this.maximumPresences = data.max_presences || 25000;\n      /**\n       * The vanity URL code of the guild, if any\n       * @type {?string}\n       */\n\n      this.vanityURLCode = data.vanity_url_code;\n      /**\n       * The description of the guild, if any\n       * @type {?string}\n       */\n\n      this.description = data.description;\n      /**\n       * The hash of the guild banner\n       * @type {?string}\n       */\n\n      this.banner = data.banner;\n      this.id = data.id;\n      this.available = !data.unavailable;\n      this.features = data.features || this.features || [];\n      /**\n       * The ID of the rules channel for the guild\n       * <info>This is only available on guilds with the `PUBLIC` feature</info>\n       * @type {?Snowflake}\n       */\n\n      this.rulesChannelID = data.rules_channel_id;\n      /**\n       * The ID of the public updates channel for the guild\n       * <info>This is only available on guilds with the `PUBLIC` feature</info>\n       * @type {?Snowflake}\n       */\n\n      this.publicUpdatesChannelID = data.public_updates_channel_id;\n\n      if (data.channels) {\n        this.channels.cache.clear();\n\n        var _iterator = _createForOfIteratorHelper(data.channels),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var rawChannel = _step.value;\n            this.client.channels.add(rawChannel, this);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n\n      if (data.roles) {\n        this.roles.cache.clear();\n\n        var _iterator2 = _createForOfIteratorHelper(data.roles),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var role = _step2.value;\n            this.roles.add(role);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n\n      if (data.members) {\n        this.members.cache.clear();\n\n        var _iterator3 = _createForOfIteratorHelper(data.members),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var guildUser = _step3.value;\n            this.members.add(guildUser);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n\n      if (data.owner_id) {\n        /**\n         * The user ID of this guild's owner\n         * @type {Snowflake}\n         */\n        this.ownerID = data.owner_id;\n      }\n\n      if (data.presences) {\n        var _iterator4 = _createForOfIteratorHelper(data.presences),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var presence = _step4.value;\n            this.presences.add(Object.assign(presence, {\n              guild: this\n            }));\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      }\n\n      if (data.voice_states) {\n        this.voiceStates.cache.clear();\n\n        var _iterator5 = _createForOfIteratorHelper(data.voice_states),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var voiceState = _step5.value;\n            this.voiceStates.add(voiceState);\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n      }\n\n      if (!this.emojis) {\n        /**\n         * A manager of the emojis belonging to this guild\n         * @type {GuildEmojiManager}\n         */\n        this.emojis = new GuildEmojiManager(this);\n\n        if (data.emojis) {\n          var _iterator6 = _createForOfIteratorHelper(data.emojis),\n              _step6;\n\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var emoji = _step6.value;\n              this.emojis.add(emoji);\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n        }\n      } else if (data.emojis) {\n        this.client.actions.GuildEmojisUpdate.handle({\n          guild_id: this.id,\n          emojis: data.emojis\n        });\n      }\n    }\n    /**\n     * The URL to this guild's banner.\n     * @param {ImageURLOptions} [options={}] Options for the Image URL\n     * @returns {?string}\n     */\n\n  }, {\n    key: \"bannerURL\",\n    value: function bannerURL() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          format = _ref.format,\n          size = _ref.size;\n\n      if (!this.banner) return null;\n      return this.client.rest.cdn.Banner(this.id, this.banner, format, size);\n    }\n    /**\n     * The timestamp the guild was created at\n     * @type {number}\n     * @readonly\n     */\n\n  }, {\n    key: \"iconURL\",\n\n    /**\n     * The URL to this guild's icon.\n     * @param {ImageURLOptions} [options={}] Options for the Image URL\n     * @returns {?string}\n     */\n    value: function iconURL() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          format = _ref2.format,\n          size = _ref2.size,\n          dynamic = _ref2.dynamic;\n\n      if (!this.icon) return null;\n      return this.client.rest.cdn.Icon(this.id, this.icon, format, size, dynamic);\n    }\n    /**\n     * The acronym that shows up in place of a guild icon.\n     * @type {string}\n     * @readonly\n     */\n\n  }, {\n    key: \"splashURL\",\n\n    /**\n     * The URL to this guild's splash.\n     * @param {ImageURLOptions} [options={}] Options for the Image URL\n     * @returns {?string}\n     */\n    value: function splashURL() {\n      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          format = _ref3.format,\n          size = _ref3.size;\n\n      if (!this.splash) return null;\n      return this.client.rest.cdn.Splash(this.id, this.splash, format, size);\n    }\n    /**\n     * The owner of the guild\n     * @type {?GuildMember}\n     * @readonly\n     */\n\n  }, {\n    key: \"member\",\n\n    /**\n     * Returns the GuildMember form of a User object, if the user is present in the guild.\n     * @param {UserResolvable} user The user that you want to obtain the GuildMember of\n     * @returns {?GuildMember}\n     * @example\n     * // Get the guild member of a user\n     * const member = guild.member(message.author);\n     */\n    value: function member(user) {\n      return this.members.resolve(user);\n    }\n    /**\n     * Fetches this guild.\n     * @returns {Promise<Guild>}\n     */\n\n  }, {\n    key: \"fetch\",\n    value: function fetch() {\n      var _this2 = this;\n\n      return this.client.api.guilds(this.id).get().then(function (data) {\n        _this2._patch(data);\n\n        return _this2;\n      });\n    }\n    /**\n     * An object containing information about a guild member's ban.\n     * @typedef {Object} BanInfo\n     * @property {User} user User that was banned\n     * @property {?string} reason Reason the user was banned\n     */\n\n    /**\n     * Fetches information on a banned user from this guild.\n     * @param {UserResolvable} user The User to fetch the ban info of\n     * @returns {Promise<BanInfo>}\n     */\n\n  }, {\n    key: \"fetchBan\",\n    value: function fetchBan(user) {\n      var _this3 = this;\n\n      var id = this.client.users.resolveID(user);\n      if (!id) throw new Error('FETCH_BAN_RESOLVE_ID');\n      return this.client.api.guilds(this.id).bans(id).get().then(function (ban) {\n        return {\n          reason: ban.reason,\n          user: _this3.client.users.add(ban.user)\n        };\n      });\n    }\n    /**\n     * Fetches a collection of banned users in this guild.\n     * @returns {Promise<Collection<Snowflake, BanInfo>>}\n     */\n\n  }, {\n    key: \"fetchBans\",\n    value: function fetchBans() {\n      var _this4 = this;\n\n      return this.client.api.guilds(this.id).bans.get().then(function (bans) {\n        return bans.reduce(function (collection, ban) {\n          collection.set(ban.user.id, {\n            reason: ban.reason,\n            user: _this4.client.users.add(ban.user)\n          });\n          return collection;\n        }, new Collection());\n      });\n    }\n    /**\n     * Fetches a collection of integrations to this guild.\n     * Resolves with a collection mapping integrations by their ids.\n     * @returns {Promise<Collection<string, Integration>>}\n     * @example\n     * // Fetch integrations\n     * guild.fetchIntegrations()\n     *   .then(integrations => console.log(`Fetched ${integrations.size} integrations`))\n     *   .catch(console.error);\n     */\n\n  }, {\n    key: \"fetchIntegrations\",\n    value: function fetchIntegrations() {\n      var _this5 = this;\n\n      return this.client.api.guilds(this.id).integrations.get().then(function (data) {\n        return data.reduce(function (collection, integration) {\n          return collection.set(integration.id, new Integration(_this5.client, integration, _this5));\n        }, new Collection());\n      });\n    }\n    /**\n     * The data for creating an integration.\n     * @typedef {Object} IntegrationData\n     * @property {string} id The integration id\n     * @property {string} type The integration type\n     */\n\n    /**\n     * Creates an integration by attaching an integration object\n     * @param {IntegrationData} data The data for the integration\n     * @param {string} reason Reason for creating the integration\n     * @returns {Promise<Guild>}\n     */\n\n  }, {\n    key: \"createIntegration\",\n    value: function createIntegration(data, reason) {\n      var _this6 = this;\n\n      return this.client.api.guilds(this.id).integrations.post({\n        data: data,\n        reason: reason\n      }).then(function () {\n        return _this6;\n      });\n    }\n    /**\n     * Fetches a collection of invites to this guild.\n     * Resolves with a collection mapping invites by their codes.\n     * @returns {Promise<Collection<string, Invite>>}\n     * @example\n     * // Fetch invites\n     * guild.fetchInvites()\n     *   .then(invites => console.log(`Fetched ${invites.size} invites`))\n     *   .catch(console.error);\n     * @example\n     * // Fetch invite creator by their id\n     * guild.fetchInvites()\n     *  .then(invites => console.log(invites.find(invite => invite.inviter.id === '84484653687267328')))\n     *  .catch(console.error);\n     */\n\n  }, {\n    key: \"fetchInvites\",\n    value: function fetchInvites() {\n      var _this7 = this;\n\n      return this.client.api.guilds(this.id).invites.get().then(function (inviteItems) {\n        var invites = new Collection();\n\n        var _iterator7 = _createForOfIteratorHelper(inviteItems),\n            _step7;\n\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var inviteItem = _step7.value;\n            var invite = new Invite(_this7.client, inviteItem);\n            invites.set(invite.code, invite);\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n\n        return invites;\n      });\n    }\n    /**\n     * Obtains a guild preview for this guild from Discord, only available for public guilds.\n     * @returns {Promise<GuildPreview>}\n     */\n\n  }, {\n    key: \"fetchPreview\",\n    value: function fetchPreview() {\n      var _this8 = this;\n\n      return this.client.api.guilds(this.id).preview.get().then(function (data) {\n        return new GuildPreview(_this8.client, data);\n      });\n    }\n    /**\n     * Fetches the vanity url invite code to this guild.\n     * Resolves with a string matching the vanity url invite code, not the full url.\n     * @returns {Promise<string>}\n     * @example\n     * // Fetch invites\n     * guild.fetchVanityCode()\n     *   .then(code => {\n     *     console.log(`Vanity URL: https://discord.gg/${code}`);\n     *   })\n     *   .catch(console.error);\n     */\n\n  }, {\n    key: \"fetchVanityCode\",\n    value: function fetchVanityCode() {\n      if (!this.features.includes('VANITY_URL')) {\n        return Promise.reject(new Error('VANITY_URL'));\n      }\n\n      return this.client.api.guilds(this.id, 'vanity-url').get().then(function (res) {\n        return res.code;\n      });\n    }\n    /**\n     * Fetches all webhooks for the guild.\n     * @returns {Promise<Collection<Snowflake, Webhook>>}\n     * @example\n     * // Fetch webhooks\n     * guild.fetchWebhooks()\n     *   .then(webhooks => console.log(`Fetched ${webhooks.size} webhooks`))\n     *   .catch(console.error);\n     */\n\n  }, {\n    key: \"fetchWebhooks\",\n    value: function fetchWebhooks() {\n      var _this9 = this;\n\n      return this.client.api.guilds(this.id).webhooks.get().then(function (data) {\n        var hooks = new Collection();\n\n        var _iterator8 = _createForOfIteratorHelper(data),\n            _step8;\n\n        try {\n          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n            var hook = _step8.value;\n            hooks.set(hook.id, new Webhook(_this9.client, hook));\n          }\n        } catch (err) {\n          _iterator8.e(err);\n        } finally {\n          _iterator8.f();\n        }\n\n        return hooks;\n      });\n    }\n    /**\n     * Fetches available voice regions.\n     * @returns {Promise<Collection<string, VoiceRegion>>}\n     */\n\n  }, {\n    key: \"fetchVoiceRegions\",\n    value: function fetchVoiceRegions() {\n      return this.client.api.guilds(this.id).regions.get().then(function (res) {\n        var regions = new Collection();\n\n        var _iterator9 = _createForOfIteratorHelper(res),\n            _step9;\n\n        try {\n          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n            var region = _step9.value;\n            regions.set(region.id, new VoiceRegion(region));\n          }\n        } catch (err) {\n          _iterator9.e(err);\n        } finally {\n          _iterator9.f();\n        }\n\n        return regions;\n      });\n    }\n    /**\n     * The Guild Embed object\n     * @typedef {Object} GuildEmbedData\n     * @property {boolean} enabled Whether the embed is enabled\n     * @property {?GuildChannel} channel The embed channel\n     */\n\n    /**\n     * Fetches the guild embed.\n     * @returns {Promise<GuildEmbedData>}\n     * @example\n     * // Fetches the guild embed\n     * guild.fetchEmbed()\n     *   .then(embed => console.log(`The embed is ${embed.enabled ? 'enabled' : 'disabled'}`))\n     *   .catch(console.error);\n     */\n\n  }, {\n    key: \"fetchEmbed\",\n    value: function fetchEmbed() {\n      var _this10 = this;\n\n      return this.client.api.guilds(this.id).embed.get().then(function (data) {\n        return {\n          enabled: data.enabled,\n          channel: data.channel_id ? _this10.channels.cache.get(data.channel_id) : null\n        };\n      });\n    }\n    /**\n     * Fetches audit logs for this guild.\n     * @param {Object} [options={}] Options for fetching audit logs\n     * @param {Snowflake|GuildAuditLogsEntry} [options.before] Limit to entries from before specified entry\n     * @param {number} [options.limit] Limit number of entries\n     * @param {UserResolvable} [options.user] Only show entries involving this user\n     * @param {AuditLogAction|number} [options.type] Only show entries involving this action type\n     * @returns {Promise<GuildAuditLogs>}\n     * @example\n     * // Output audit log entries\n     * guild.fetchAuditLogs()\n     *   .then(audit => console.log(audit.entries.first()))\n     *   .catch(console.error);\n     */\n\n  }, {\n    key: \"fetchAuditLogs\",\n    value: function fetchAuditLogs() {\n      var _this11 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      if (options.before && options.before instanceof GuildAuditLogs.Entry) options.before = options.before.id;\n      if (typeof options.type === 'string') options.type = GuildAuditLogs.Actions[options.type];\n      return this.client.api.guilds(this.id)['audit-logs'].get({\n        query: {\n          before: options.before,\n          limit: options.limit,\n          user_id: this.client.users.resolveID(options.user),\n          action_type: options.type\n        }\n      }).then(function (data) {\n        return GuildAuditLogs.build(_this11, data);\n      });\n    }\n    /**\n     * Adds a user to the guild using OAuth2. Requires the `CREATE_INSTANT_INVITE` permission.\n     * @param {UserResolvable} user User to add to the guild\n     * @param {Object} options Options for the addition\n     * @param {string} options.accessToken An OAuth2 access token for the user with the `guilds.join` scope granted to the\n     * bot's application\n     * @param {string} [options.nick] Nickname to give the member (requires `MANAGE_NICKNAMES`)\n     * @param {Collection<Snowflake, Role>|RoleResolvable[]} [options.roles] Roles to add to the member\n     * (requires `MANAGE_ROLES`)\n     * @param {boolean} [options.mute] Whether the member should be muted (requires `MUTE_MEMBERS`)\n     * @param {boolean} [options.deaf] Whether the member should be deafened (requires `DEAFEN_MEMBERS`)\n     * @returns {Promise<GuildMember>}\n     */\n\n  }, {\n    key: \"addMember\",\n    value: function addMember(user, options) {\n      var _this12 = this;\n\n      user = this.client.users.resolveID(user);\n      if (!user) return Promise.reject(new TypeError('INVALID_TYPE', 'user', 'UserResolvable'));\n      if (this.members.cache.has(user)) return Promise.resolve(this.members.cache.get(user));\n      options.access_token = options.accessToken;\n\n      if (options.roles) {\n        var roles = [];\n\n        var _iterator10 = _createForOfIteratorHelper(options.roles instanceof Collection ? options.roles.values() : options.roles),\n            _step10;\n\n        try {\n          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n            var role = _step10.value;\n            role = this.roles.resolve(role);\n\n            if (!role) {\n              return Promise.reject(new TypeError('INVALID_TYPE', 'options.roles', 'Array or Collection of Roles or Snowflakes', true));\n            }\n\n            roles.push(role.id);\n          }\n        } catch (err) {\n          _iterator10.e(err);\n        } finally {\n          _iterator10.f();\n        }\n\n        options.roles = roles;\n      }\n\n      return this.client.api.guilds(this.id).members(user).put({\n        data: options\n      }).then(function (data) {\n        return _this12.members.add(data);\n      });\n    }\n    /**\n     * The data for editing a guild.\n     * @typedef {Object} GuildEditData\n     * @property {string} [name] The name of the guild\n     * @property {string} [region] The region of the guild\n     * @property {VerificationLevel|number} [verificationLevel] The verification level of the guild\n     * @property {ExplicitContentFilterLevel|number} [explicitContentFilter] The level of the explicit content filter\n     * @property {ChannelResolvable} [afkChannel] The AFK channel of the guild\n     * @property {ChannelResolvable} [systemChannel] The system channel of the guild\n     * @property {number} [afkTimeout] The AFK timeout of the guild\n     * @property {Base64Resolvable} [icon] The icon of the guild\n     * @property {GuildMemberResolvable} [owner] The owner of the guild\n     * @property {Base64Resolvable} [splash] The splash screen of the guild\n     * @property {Base64Resolvable} [banner] The banner of the guild\n     * @property {DefaultMessageNotifications|number} [defaultMessageNotifications] The default message notifications\n     * @property {SystemChannelFlagsResolvable} [systemChannelFlags] The system channel flags of the guild\n     */\n\n    /**\n     * Updates the guild with new information - e.g. a new name.\n     * @param {GuildEditData} data The data to update the guild with\n     * @param {string} [reason] Reason for editing this guild\n     * @returns {Promise<Guild>}\n     * @example\n     * // Set the guild name and region\n     * guild.edit({\n     *   name: 'Discord Guild',\n     *   region: 'london',\n     * })\n     *   .then(updated => console.log(`New guild name ${updated} in region ${updated.region}`))\n     *   .catch(console.error);\n     */\n\n  }, {\n    key: \"edit\",\n    value: function edit(data, reason) {\n      var _this13 = this;\n\n      var _data = {};\n      if (data.name) _data.name = data.name;\n      if (data.region) _data.region = data.region;\n\n      if (typeof data.verificationLevel !== 'undefined') {\n        _data.verification_level = typeof data.verificationLevel === 'number' ? Number(data.verificationLevel) : VerificationLevels.indexOf(data.verificationLevel);\n      }\n\n      if (typeof data.afkChannel !== 'undefined') {\n        _data.afk_channel_id = this.client.channels.resolveID(data.afkChannel);\n      }\n\n      if (typeof data.systemChannel !== 'undefined') {\n        _data.system_channel_id = this.client.channels.resolveID(data.systemChannel);\n      }\n\n      if (data.afkTimeout) _data.afk_timeout = Number(data.afkTimeout);\n      if (typeof data.icon !== 'undefined') _data.icon = data.icon;\n      if (data.owner) _data.owner_id = this.client.users.resolveID(data.owner);\n      if (data.splash) _data.splash = data.splash;\n      if (data.banner) _data.banner = data.banner;\n\n      if (typeof data.explicitContentFilter !== 'undefined') {\n        _data.explicit_content_filter = typeof data.explicitContentFilter === 'number' ? data.explicitContentFilter : ExplicitContentFilterLevels.indexOf(data.explicitContentFilter);\n      }\n\n      if (typeof data.defaultMessageNotifications !== 'undefined') {\n        _data.default_message_notifications = typeof data.defaultMessageNotifications === 'string' ? DefaultMessageNotifications.indexOf(data.defaultMessageNotifications) : data.defaultMessageNotifications;\n      }\n\n      if (typeof data.systemChannelFlags !== 'undefined') {\n        _data.system_channel_flags = SystemChannelFlags.resolve(data.systemChannelFlags);\n      }\n\n      return this.client.api.guilds(this.id).patch({\n        data: _data,\n        reason: reason\n      }).then(function (newData) {\n        return _this13.client.actions.GuildUpdate.handle(newData).updated;\n      });\n    }\n    /**\n     * Edits the level of the explicit content filter.\n     * @param {ExplicitContentFilterLevel|number} explicitContentFilter The new level of the explicit content filter\n     * @param {string} [reason] Reason for changing the level of the guild's explicit content filter\n     * @returns {Promise<Guild>}\n     */\n\n  }, {\n    key: \"setExplicitContentFilter\",\n    value: function setExplicitContentFilter(explicitContentFilter, reason) {\n      return this.edit({\n        explicitContentFilter: explicitContentFilter\n      }, reason);\n    }\n    /* eslint-disable max-len */\n\n    /**\n     * Edits the setting of the default message notifications of the guild.\n     * @param {DefaultMessageNotifications|number} defaultMessageNotifications The new setting for the default message notifications\n     * @param {string} [reason] Reason for changing the setting of the default message notifications\n     * @returns {Promise<Guild>}\n     */\n\n  }, {\n    key: \"setDefaultMessageNotifications\",\n    value: function setDefaultMessageNotifications(defaultMessageNotifications, reason) {\n      return this.edit({\n        defaultMessageNotifications: defaultMessageNotifications\n      }, reason);\n    }\n    /* eslint-enable max-len */\n\n    /**\n     * Edits the flags of the default message notifications of the guild.\n     * @param {SystemChannelFlagsResolvable} systemChannelFlags The new flags for the default message notifications\n     * @param {string} [reason] Reason for changing the flags of the default message notifications\n     * @returns {Promise<Guild>}\n     */\n\n  }, {\n    key: \"setSystemChannelFlags\",\n    value: function setSystemChannelFlags(systemChannelFlags, reason) {\n      return this.edit({\n        systemChannelFlags: systemChannelFlags\n      }, reason);\n    }\n    /**\n     * Edits the name of the guild.\n     * @param {string} name The new name of the guild\n     * @param {string} [reason] Reason for changing the guild's name\n     * @returns {Promise<Guild>}\n     * @example\n     * // Edit the guild name\n     * guild.setName('Discord Guild')\n     *  .then(updated => console.log(`Updated guild name to ${guild}`))\n     *  .catch(console.error);\n     */\n\n  }, {\n    key: \"setName\",\n    value: function setName(name, reason) {\n      return this.edit({\n        name: name\n      }, reason);\n    }\n    /**\n     * Edits the region of the guild.\n     * @param {string} region The new region of the guild\n     * @param {string} [reason] Reason for changing the guild's region\n     * @returns {Promise<Guild>}\n     * @example\n     * // Edit the guild region\n     * guild.setRegion('london')\n     *  .then(updated => console.log(`Updated guild region to ${updated.region}`))\n     *  .catch(console.error);\n     */\n\n  }, {\n    key: \"setRegion\",\n    value: function setRegion(region, reason) {\n      return this.edit({\n        region: region\n      }, reason);\n    }\n    /**\n     * Edits the verification level of the guild.\n     * @param {VerificationLevel|number} verificationLevel The new verification level of the guild\n     * @param {string} [reason] Reason for changing the guild's verification level\n     * @returns {Promise<Guild>}\n     * @example\n     * // Edit the guild verification level\n     * guild.setVerificationLevel(1)\n     *  .then(updated => console.log(`Updated guild verification level to ${guild.verificationLevel}`))\n     *  .catch(console.error);\n     */\n\n  }, {\n    key: \"setVerificationLevel\",\n    value: function setVerificationLevel(verificationLevel, reason) {\n      return this.edit({\n        verificationLevel: verificationLevel\n      }, reason);\n    }\n    /**\n     * Edits the AFK channel of the guild.\n     * @param {ChannelResolvable} afkChannel The new AFK channel\n     * @param {string} [reason] Reason for changing the guild's AFK channel\n     * @returns {Promise<Guild>}\n     * @example\n     * // Edit the guild AFK channel\n     * guild.setAFKChannel(channel)\n     *  .then(updated => console.log(`Updated guild AFK channel to ${guild.afkChannel.name}`))\n     *  .catch(console.error);\n     */\n\n  }, {\n    key: \"setAFKChannel\",\n    value: function setAFKChannel(afkChannel, reason) {\n      return this.edit({\n        afkChannel: afkChannel\n      }, reason);\n    }\n    /**\n     * Edits the system channel of the guild.\n     * @param {ChannelResolvable} systemChannel The new system channel\n     * @param {string} [reason] Reason for changing the guild's system channel\n     * @returns {Promise<Guild>}\n     * @example\n     * // Edit the guild system channel\n     * guild.setSystemChannel(channel)\n     *  .then(updated => console.log(`Updated guild system channel to ${guild.systemChannel.name}`))\n     *  .catch(console.error);\n     */\n\n  }, {\n    key: \"setSystemChannel\",\n    value: function setSystemChannel(systemChannel, reason) {\n      return this.edit({\n        systemChannel: systemChannel\n      }, reason);\n    }\n    /**\n     * Edits the AFK timeout of the guild.\n     * @param {number} afkTimeout The time in seconds that a user must be idle to be considered AFK\n     * @param {string} [reason] Reason for changing the guild's AFK timeout\n     * @returns {Promise<Guild>}\n     * @example\n     * // Edit the guild AFK channel\n     * guild.setAFKTimeout(60)\n     *  .then(updated => console.log(`Updated guild AFK timeout to ${guild.afkTimeout}`))\n     *  .catch(console.error);\n     */\n\n  }, {\n    key: \"setAFKTimeout\",\n    value: function setAFKTimeout(afkTimeout, reason) {\n      return this.edit({\n        afkTimeout: afkTimeout\n      }, reason);\n    }\n    /**\n     * Sets a new guild icon.\n     * @param {Base64Resolvable|BufferResolvable} icon The new icon of the guild\n     * @param {string} [reason] Reason for changing the guild's icon\n     * @returns {Promise<Guild>}\n     * @example\n     * // Edit the guild icon\n     * guild.setIcon('./icon.png')\n     *  .then(updated => console.log('Updated the guild icon'))\n     *  .catch(console.error);\n     */\n\n  }, {\n    key: \"setIcon\",\n    value: function () {\n      var _setIcon = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(icon, reason) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.t0 = this;\n                _context.next = 3;\n                return DataResolver.resolveImage(icon);\n\n              case 3:\n                _context.t1 = _context.sent;\n                _context.t2 = reason;\n                _context.t3 = {\n                  icon: _context.t1,\n                  reason: _context.t2\n                };\n                return _context.abrupt(\"return\", _context.t0.edit.call(_context.t0, _context.t3));\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function setIcon(_x, _x2) {\n        return _setIcon.apply(this, arguments);\n      }\n\n      return setIcon;\n    }()\n    /**\n     * Sets a new owner of the guild.\n     * @param {GuildMemberResolvable} owner The new owner of the guild\n     * @param {string} [reason] Reason for setting the new owner\n     * @returns {Promise<Guild>}\n     * @example\n     * // Edit the guild owner\n     * guild.setOwner(guild.members.cache.first())\n     *  .then(updated => console.log(`Updated the guild owner to ${updated.owner.displayName}`))\n     *  .catch(console.error);\n     */\n\n  }, {\n    key: \"setOwner\",\n    value: function setOwner(owner, reason) {\n      return this.edit({\n        owner: owner\n      }, reason);\n    }\n    /**\n     * Sets a new guild splash screen.\n     * @param {Base64Resolvable|BufferResolvable} splash The new splash screen of the guild\n     * @param {string} [reason] Reason for changing the guild's splash screen\n     * @returns {Promise<Guild>}\n     * @example\n     * // Edit the guild splash\n     * guild.setSplash('./splash.png')\n     *  .then(updated => console.log('Updated the guild splash'))\n     *  .catch(console.error);\n     */\n\n  }, {\n    key: \"setSplash\",\n    value: function () {\n      var _setSplash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(splash, reason) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.t0 = this;\n                _context2.next = 3;\n                return DataResolver.resolveImage(splash);\n\n              case 3:\n                _context2.t1 = _context2.sent;\n                _context2.t2 = reason;\n                _context2.t3 = {\n                  splash: _context2.t1,\n                  reason: _context2.t2\n                };\n                return _context2.abrupt(\"return\", _context2.t0.edit.call(_context2.t0, _context2.t3));\n\n              case 7:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function setSplash(_x3, _x4) {\n        return _setSplash.apply(this, arguments);\n      }\n\n      return setSplash;\n    }()\n    /**\n     * Sets a new guild banner.\n     * @param {Base64Resolvable|BufferResolvable} banner The new banner of the guild\n     * @param {string} [reason] Reason for changing the guild's banner\n     * @returns {Promise<Guild>}\n     * @example\n     * guild.setBanner('./banner.png')\n     *  .then(updated => console.log('Updated the guild banner'))\n     *  .catch(console.error);\n     */\n\n  }, {\n    key: \"setBanner\",\n    value: function () {\n      var _setBanner = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(banner, reason) {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.t0 = this;\n                _context3.next = 3;\n                return DataResolver.resolveImage(banner);\n\n              case 3:\n                _context3.t1 = _context3.sent;\n                _context3.t2 = reason;\n                _context3.t3 = {\n                  banner: _context3.t1,\n                  reason: _context3.t2\n                };\n                return _context3.abrupt(\"return\", _context3.t0.edit.call(_context3.t0, _context3.t3));\n\n              case 7:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function setBanner(_x5, _x6) {\n        return _setBanner.apply(this, arguments);\n      }\n\n      return setBanner;\n    }()\n    /**\n     * The data needed for updating a channel's position.\n     * @typedef {Object} ChannelPosition\n     * @property {ChannelResolvable} channel Channel to update\n     * @property {number} position New position for the channel\n     */\n\n    /**\n     * Batch-updates the guild's channels' positions.\n     * @param {ChannelPosition[]} channelPositions Channel positions to update\n     * @returns {Promise<Guild>}\n     * @example\n     * guild.setChannelPositions([{ channel: channelID, position: newChannelIndex }])\n     *   .then(guild => console.log(`Updated channel positions for ${guild}`))\n     *   .catch(console.error);\n     */\n\n  }, {\n    key: \"setChannelPositions\",\n    value: function setChannelPositions(channelPositions) {\n      var _this14 = this;\n\n      var updatedChannels = channelPositions.map(function (r) {\n        return {\n          id: _this14.client.channels.resolveID(r.channel),\n          position: r.position\n        };\n      });\n      return this.client.api.guilds(this.id).channels.patch({\n        data: updatedChannels\n      }).then(function () {\n        return _this14.client.actions.GuildChannelsPositionUpdate.handle({\n          guild_id: _this14.id,\n          channels: updatedChannels\n        }).guild;\n      });\n    }\n    /**\n     * The data needed for updating a guild role's position\n     * @typedef {Object} GuildRolePosition\n     * @property {RoleResolveable} role The ID of the role\n     * @property {number} position The position to update\n     */\n\n    /**\n     * Batch-updates the guild's role positions\n     * @param {GuildRolePosition[]} rolePositions Role positions to update\n     * @returns {Promise<Guild>}\n     * @example\n     * guild.setRolePositions([{ role: roleID, position: updatedRoleIndex }])\n     *  .then(guild => console.log(`Role permissions updated for ${guild}`))\n     *  .catch(console.error);\n     */\n\n  }, {\n    key: \"setRolePositions\",\n    value: function setRolePositions(rolePositions) {\n      var _this15 = this;\n\n      // Make sure rolePositions are prepared for API\n      rolePositions = rolePositions.map(function (o) {\n        return {\n          id: _this15.roles.resolveID(o.role),\n          position: o.position\n        };\n      }); // Call the API to update role positions\n\n      return this.client.api.guilds(this.id).roles.patch({\n        data: rolePositions\n      }).then(function () {\n        return _this15.client.actions.GuildRolesPositionUpdate.handle({\n          guild_id: _this15.id,\n          roles: rolePositions\n        }).guild;\n      });\n    }\n    /**\n     * Edits the guild's embed.\n     * @param {GuildEmbedData} embed The embed for the guild\n     * @param {string} [reason] Reason for changing the guild's embed\n     * @returns {Promise<Guild>}\n     */\n\n  }, {\n    key: \"setEmbed\",\n    value: function setEmbed(embed, reason) {\n      var _this16 = this;\n\n      return this.client.api.guilds(this.id).embed.patch({\n        data: {\n          enabled: embed.enabled,\n          channel_id: this.channels.resolveID(embed.channel)\n        },\n        reason: reason\n      }).then(function () {\n        return _this16;\n      });\n    }\n    /**\n     * Leaves the guild.\n     * @returns {Promise<Guild>}\n     * @example\n     * // Leave a guild\n     * guild.leave()\n     *   .then(g => console.log(`Left the guild ${g}`))\n     *   .catch(console.error);\n     */\n\n  }, {\n    key: \"leave\",\n    value: function leave() {\n      var _this17 = this;\n\n      if (this.ownerID === this.client.user.id) return Promise.reject(new Error('GUILD_OWNED'));\n      return this.client.api.users('@me').guilds(this.id)[\"delete\"]().then(function () {\n        return _this17.client.actions.GuildDelete.handle({\n          id: _this17.id\n        }).guild;\n      });\n    }\n    /**\n     * Deletes the guild.\n     * @returns {Promise<Guild>}\n     * @example\n     * // Delete a guild\n     * guild.delete()\n     *   .then(g => console.log(`Deleted the guild ${g}`))\n     *   .catch(console.error);\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      var _this18 = this;\n\n      return this.client.api.guilds(this.id)[\"delete\"]().then(function () {\n        return _this18.client.actions.GuildDelete.handle({\n          id: _this18.id\n        }).guild;\n      });\n    }\n    /**\n     * Whether this guild equals another guild. It compares all properties, so for most operations\n     * it is advisable to just compare `guild.id === guild2.id` as it is much faster and is often\n     * what most users need.\n     * @param {Guild} guild The guild to compare with\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"equals\",\n    value: function equals(guild) {\n      var equal = guild && guild instanceof this.constructor && this.id === guild.id && this.available === guild.available && this.splash === guild.splash && this.region === guild.region && this.name === guild.name && this.memberCount === guild.memberCount && this.large === guild.large && this.icon === guild.icon && this.ownerID === guild.ownerID && this.verificationLevel === guild.verificationLevel && this.embedEnabled === guild.embedEnabled && (this.features === guild.features || this.features.length === guild.features.length && this.features.every(function (feat, i) {\n        return feat === guild.features[i];\n      }));\n\n      if (equal) {\n        if (this.embedChannel) {\n          if (!guild.embedChannel || this.embedChannel.id !== guild.embedChannel.id) equal = false;\n        } else if (guild.embedChannel) {\n          equal = false;\n        }\n      }\n\n      return equal;\n    }\n    /**\n     * When concatenated with a string, this automatically returns the guild's name instead of the Guild object.\n     * @returns {string}\n     * @example\n     * // Logs: Hello from My Guild!\n     * console.log(`Hello from ${guild}!`);\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.name;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = _get(_getPrototypeOf(Guild.prototype), \"toJSON\", this).call(this, {\n        available: false,\n        createdTimestamp: true,\n        nameAcronym: true,\n        presences: false,\n        voiceStates: false\n      });\n\n      json.iconURL = this.iconURL();\n      json.splashURL = this.splashURL();\n      json.bannerURL = this.bannerURL();\n      return json;\n    }\n    /**\n     * Creates a collection of this guild's roles, sorted by their position and IDs.\n     * @returns {Collection<Role>}\n     * @private\n     */\n\n  }, {\n    key: \"_sortedRoles\",\n    value: function _sortedRoles() {\n      return Util.discordSort(this.roles.cache);\n    }\n    /**\n     * Creates a collection of this guild's or a specific category's channels, sorted by their position and IDs.\n     * @param {GuildChannel} [channel] Category to get the channels of\n     * @returns {Collection<GuildChannel>}\n     * @private\n     */\n\n  }, {\n    key: \"_sortedChannels\",\n    value: function _sortedChannels(channel) {\n      var category = channel.type === ChannelTypes.CATEGORY;\n      return Util.discordSort(this.channels.cache.filter(function (c) {\n        return (['text', 'news', 'store'].includes(channel.type) ? ['text', 'news', 'store'].includes(c.type) : c.type === channel.type) && (category || c.parent === channel.parent);\n      }));\n    }\n  }, {\n    key: \"shard\",\n    get: function get() {\n      return this.client.ws.shards.get(this.shardID);\n    }\n  }, {\n    key: \"createdTimestamp\",\n    get: function get() {\n      return Snowflake.deconstruct(this.id).timestamp;\n    }\n    /**\n     * The time the guild was created at\n     * @type {Date}\n     * @readonly\n     */\n\n  }, {\n    key: \"createdAt\",\n    get: function get() {\n      return new Date(this.createdTimestamp);\n    }\n    /**\n     * The time the client user joined the guild\n     * @type {Date}\n     * @readonly\n     */\n\n  }, {\n    key: \"joinedAt\",\n    get: function get() {\n      return new Date(this.joinedTimestamp);\n    }\n    /**\n     * If this guild is partnered\n     * @type {boolean}\n     * @readonly\n     */\n\n  }, {\n    key: \"partnered\",\n    get: function get() {\n      return this.features.includes('PARTNERED');\n    }\n    /**\n     * If this guild is verified\n     * @type {boolean}\n     * @readonly\n     */\n\n  }, {\n    key: \"verified\",\n    get: function get() {\n      return this.features.includes('VERIFIED');\n    }\n  }, {\n    key: \"nameAcronym\",\n    get: function get() {\n      return this.name.replace(/\\w+/g, function (name) {\n        return name[0];\n      }).replace(/\\s/g, '');\n    }\n  }, {\n    key: \"owner\",\n    get: function get() {\n      return this.members.cache.get(this.ownerID) || (this.client.options.partials.includes(PartialTypes.GUILD_MEMBER) ? this.members.add({\n        user: {\n          id: this.ownerID\n        }\n      }, true) : null);\n    }\n    /**\n     * AFK voice channel for this guild\n     * @type {?VoiceChannel}\n     * @readonly\n     */\n\n  }, {\n    key: \"afkChannel\",\n    get: function get() {\n      return this.client.channels.cache.get(this.afkChannelID) || null;\n    }\n    /**\n     * System channel for this guild\n     * @type {?TextChannel}\n     * @readonly\n     */\n\n  }, {\n    key: \"systemChannel\",\n    get: function get() {\n      return this.client.channels.cache.get(this.systemChannelID) || null;\n    }\n    /**\n     * Widget channel for this guild\n     * @type {?TextChannel}\n     * @readonly\n     */\n\n  }, {\n    key: \"widgetChannel\",\n    get: function get() {\n      return this.client.channels.cache.get(this.widgetChannelID) || null;\n    }\n    /**\n     * Embed channel for this guild\n     * @type {?TextChannel}\n     * @readonly\n     */\n\n  }, {\n    key: \"embedChannel\",\n    get: function get() {\n      return this.client.channels.cache.get(this.embedChannelID) || null;\n    }\n    /**\n     * Rules channel for this guild\n     * <info>This is only available on guilds with the `PUBLIC` feature</info>\n     * @type {?TextChannel}\n     * @readonly\n     */\n\n  }, {\n    key: \"rulesChannel\",\n    get: function get() {\n      return this.client.channels.cache.get(this.rulesChannelID) || null;\n    }\n    /**\n     * Public updates channel for this guild\n     * <info>This is only available on guilds with the `PUBLIC` feature</info>\n     * @type {?TextChannel}\n     * @readonly\n     */\n\n  }, {\n    key: \"publicUpdatesChannel\",\n    get: function get() {\n      return this.client.channels.cache.get(this.publicUpdatesChannelID) || null;\n    }\n    /**\n     * The client user as a GuildMember of this guild\n     * @type {?GuildMember}\n     * @readonly\n     */\n\n  }, {\n    key: \"me\",\n    get: function get() {\n      return this.members.cache.get(this.client.user.id) || (this.client.options.partials.includes(PartialTypes.GUILD_MEMBER) ? this.members.add({\n        user: {\n          id: this.client.user.id\n        }\n      }, true) : null);\n    }\n    /**\n     * The voice state for the client user of this guild, if any\n     * @type {?VoiceState}\n     * @readonly\n     */\n\n  }, {\n    key: \"voice\",\n    get: function get() {\n      return this.voiceStates.cache.get(this.client.user.id);\n    }\n  }]);\n\n  return Guild;\n}(Base);\n\nmodule.exports = Guild;","map":null,"metadata":{},"sourceType":"module"}