{"ast":null,"code":"'use strict';\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar EventEmitter = require('events');\n\nvar WebSocket = require('../../WebSocket');\n\nvar _require = require('../../util/Constants'),\n    browser = _require.browser,\n    Status = _require.Status,\n    Events = _require.Events,\n    ShardEvents = _require.ShardEvents,\n    OPCodes = _require.OPCodes,\n    WSEvents = _require.WSEvents;\n\nvar STATUS_KEYS = Object.keys(Status);\nvar CONNECTION_STATE = Object.keys(WebSocket.WebSocket);\nvar zlib;\n\nif (!browser) {\n  try {\n    zlib = require('zlib-sync');\n  } catch (_unused) {} // eslint-disable-line no-empty\n\n}\n/**\n * Represents a Shard's WebSocket connection\n */\n\n\nvar WebSocketShard = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(WebSocketShard, _EventEmitter);\n\n  var _super = _createSuper(WebSocketShard);\n\n  function WebSocketShard(manager, id) {\n    var _this;\n\n    _classCallCheck(this, WebSocketShard);\n\n    _this = _super.call(this);\n    /**\n     * The WebSocketManager of the shard\n     * @type {WebSocketManager}\n     */\n\n    _this.manager = manager;\n    /**\n     * The ID of the shard\n     * @type {number}\n     */\n\n    _this.id = id;\n    /**\n     * The current status of the shard\n     * @type {Status}\n     */\n\n    _this.status = Status.IDLE;\n    /**\n     * The current sequence of the shard\n     * @type {number}\n     * @private\n     */\n\n    _this.sequence = -1;\n    /**\n     * The sequence of the shard after close\n     * @type {number}\n     * @private\n     */\n\n    _this.closeSequence = 0;\n    /**\n     * The current session ID of the shard\n     * @type {string}\n     * @private\n     */\n\n    _this.sessionID = undefined;\n    /**\n     * The previous heartbeat ping of the shard\n     * @type {number}\n     */\n\n    _this.ping = -1;\n    /**\n     * The last time a ping was sent (a timestamp)\n     * @type {number}\n     * @private\n     */\n\n    _this.lastPingTimestamp = -1;\n    /**\n     * If we received a heartbeat ack back. Used to identify zombie connections\n     * @type {boolean}\n     * @private\n     */\n\n    _this.lastHeartbeatAcked = true;\n    /**\n     * Contains the rate limit queue and metadata\n     * @type {Object}\n     * @private\n     */\n\n    Object.defineProperty(_assertThisInitialized(_this), 'ratelimit', {\n      value: {\n        queue: [],\n        total: 120,\n        remaining: 120,\n        time: 60e3,\n        timer: null\n      }\n    });\n    /**\n     * The WebSocket connection for the current shard\n     * @type {?WebSocket}\n     * @private\n     */\n\n    Object.defineProperty(_assertThisInitialized(_this), 'connection', {\n      value: null,\n      writable: true\n    });\n    /**\n     * @external Inflate\n     * @see {@link https://www.npmjs.com/package/zlib-sync}\n     */\n\n    /**\n     * The compression to use\n     * @type {?Inflate}\n     * @private\n     */\n\n    Object.defineProperty(_assertThisInitialized(_this), 'inflate', {\n      value: null,\n      writable: true\n    });\n    /**\n     * The HELLO timeout\n     * @type {?NodeJS.Timer}\n     * @private\n     */\n\n    Object.defineProperty(_assertThisInitialized(_this), 'helloTimeout', {\n      value: undefined,\n      writable: true\n    });\n    /**\n     * If the manager attached its event handlers on the shard\n     * @type {boolean}\n     * @private\n     */\n\n    Object.defineProperty(_assertThisInitialized(_this), 'eventsAttached', {\n      value: false,\n      writable: true\n    });\n    /**\n     * A set of guild IDs this shard expects to receive\n     * @type {?Set<string>}\n     * @private\n     */\n\n    Object.defineProperty(_assertThisInitialized(_this), 'expectedGuilds', {\n      value: undefined,\n      writable: true\n    });\n    /**\n     * The ready timeout\n     * @type {?NodeJS.Timer}\n     * @private\n     */\n\n    Object.defineProperty(_assertThisInitialized(_this), 'readyTimeout', {\n      value: undefined,\n      writable: true\n    });\n    /**\n     * Time when the WebSocket connection was opened\n     * @type {number}\n     * @private\n     */\n\n    Object.defineProperty(_assertThisInitialized(_this), 'connectedAt', {\n      value: 0,\n      writable: true\n    });\n    return _this;\n  }\n  /**\n   * Emits a debug event.\n   * @param {string} message The debug message\n   * @private\n   */\n\n\n  _createClass(WebSocketShard, [{\n    key: \"debug\",\n    value: function debug(message) {\n      this.manager.debug(message, this);\n    }\n    /**\n     * Connects the shard to the gateway.\n     * @private\n     * @returns {Promise<void>} A promise that will resolve if the shard turns ready successfully,\n     * or reject if we couldn't connect\n     */\n\n  }, {\n    key: \"connect\",\n    value: function connect() {\n      var _this2 = this;\n\n      var _this$manager = this.manager,\n          gateway = _this$manager.gateway,\n          client = _this$manager.client;\n\n      if (this.connection && this.connection.readyState === WebSocket.OPEN && this.status === Status.READY) {\n        return Promise.resolve();\n      }\n\n      return new Promise(function (resolve, reject) {\n        var cleanup = function cleanup() {\n          _this2.removeListener(ShardEvents.CLOSE, onClose);\n\n          _this2.removeListener(ShardEvents.READY, onReady);\n\n          _this2.removeListener(ShardEvents.RESUMED, onResumed);\n\n          _this2.removeListener(ShardEvents.INVALID_SESSION, onInvalidOrDestroyed);\n\n          _this2.removeListener(ShardEvents.DESTROYED, onInvalidOrDestroyed);\n        };\n\n        var onReady = function onReady() {\n          cleanup();\n          resolve();\n        };\n\n        var onResumed = function onResumed() {\n          cleanup();\n          resolve();\n        };\n\n        var onClose = function onClose(event) {\n          cleanup();\n          reject(event);\n        };\n\n        var onInvalidOrDestroyed = function onInvalidOrDestroyed() {\n          cleanup(); // eslint-disable-next-line prefer-promise-reject-errors\n\n          reject();\n        };\n\n        _this2.once(ShardEvents.READY, onReady);\n\n        _this2.once(ShardEvents.RESUMED, onResumed);\n\n        _this2.once(ShardEvents.CLOSE, onClose);\n\n        _this2.once(ShardEvents.INVALID_SESSION, onInvalidOrDestroyed);\n\n        _this2.once(ShardEvents.DESTROYED, onInvalidOrDestroyed);\n\n        if (_this2.connection && _this2.connection.readyState === WebSocket.OPEN) {\n          _this2.debug('An open connection was found, attempting an immediate identify.');\n\n          _this2.identify();\n\n          return;\n        }\n\n        if (_this2.connection) {\n          _this2.debug(\"A connection object was found. Cleaning up before continuing.\\n    State: \".concat(CONNECTION_STATE[_this2.connection.readyState]));\n\n          _this2.destroy({\n            emit: false\n          });\n        }\n\n        var wsQuery = {\n          v: client.options.ws.version\n        };\n\n        if (zlib) {\n          _this2.inflate = new zlib.Inflate({\n            chunkSize: 65535,\n            flush: zlib.Z_SYNC_FLUSH,\n            to: WebSocket.encoding === 'json' ? 'string' : ''\n          });\n          wsQuery.compress = 'zlib-stream';\n        }\n\n        _this2.debug(\"[CONNECT]\\n    Gateway    : \".concat(gateway, \"\\n    Version    : \").concat(client.options.ws.version, \"\\n    Encoding   : \").concat(WebSocket.encoding, \"\\n    Compression: \").concat(zlib ? 'zlib-stream' : 'none'));\n\n        _this2.status = _this2.status === Status.DISCONNECTED ? Status.RECONNECTING : Status.CONNECTING;\n\n        _this2.setHelloTimeout();\n\n        _this2.connectedAt = Date.now();\n        var ws = _this2.connection = WebSocket.create(gateway, wsQuery);\n        ws.onopen = _this2.onOpen.bind(_this2);\n        ws.onmessage = _this2.onMessage.bind(_this2);\n        ws.onerror = _this2.onError.bind(_this2);\n        ws.onclose = _this2.onClose.bind(_this2);\n      });\n    }\n    /**\n     * Called whenever a connection is opened to the gateway.\n     * @private\n     */\n\n  }, {\n    key: \"onOpen\",\n    value: function onOpen() {\n      this.debug(\"[CONNECTED] \".concat(this.connection.url, \" in \").concat(Date.now() - this.connectedAt, \"ms\"));\n      this.status = Status.NEARLY;\n    }\n    /**\n     * Called whenever a message is received.\n     * @param {MessageEvent} event Event received\n     * @private\n     */\n\n  }, {\n    key: \"onMessage\",\n    value: function onMessage(_ref) {\n      var data = _ref.data;\n      var raw;\n      if (data instanceof ArrayBuffer) data = new Uint8Array(data);\n\n      if (zlib) {\n        var l = data.length;\n        var flush = l >= 4 && data[l - 4] === 0x00 && data[l - 3] === 0x00 && data[l - 2] === 0xff && data[l - 1] === 0xff;\n        this.inflate.push(data, flush && zlib.Z_SYNC_FLUSH);\n        if (!flush) return;\n        raw = this.inflate.result;\n      } else {\n        raw = data;\n      }\n\n      var packet;\n\n      try {\n        packet = WebSocket.unpack(raw);\n        this.manager.client.emit(Events.RAW, packet, this.id);\n        if (packet.op === OPCodes.DISPATCH) this.manager.emit(packet.t, packet.d, this.id);\n      } catch (err) {\n        this.manager.client.emit(Events.SHARD_ERROR, err, this.id);\n        return;\n      }\n\n      this.onPacket(packet);\n    }\n    /**\n     * Called whenever an error occurs with the WebSocket.\n     * @param {ErrorEvent} event The error that occurred\n     * @private\n     */\n\n  }, {\n    key: \"onError\",\n    value: function onError(event) {\n      var error = event && event.error ? event.error : event;\n      if (!error) return;\n      /**\n       * Emitted whenever a shard's WebSocket encounters a connection error.\n       * @event Client#shardError\n       * @param {Error} error The encountered error\n       * @param {number} shardID The shard that encountered this error\n       */\n\n      this.manager.client.emit(Events.SHARD_ERROR, error, this.id);\n    }\n    /**\n     * @external CloseEvent\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent}\n     */\n\n    /**\n     * @external ErrorEvent\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/ErrorEvent}\n     */\n\n    /**\n     * @external MessageEvent\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent}\n     */\n\n    /**\n     * Called whenever a connection to the gateway is closed.\n     * @param {CloseEvent} event Close event that was received\n     * @private\n     */\n\n  }, {\n    key: \"onClose\",\n    value: function onClose(event) {\n      if (this.sequence !== -1) this.closeSequence = this.sequence;\n      this.sequence = -1;\n      this.debug(\"[CLOSE]\\n    Event Code: \".concat(event.code, \"\\n    Clean     : \").concat(event.wasClean, \"\\n    Reason    : \").concat(event.reason || 'No reason received'));\n      this.setHeartbeatTimer(-1);\n      this.setHelloTimeout(-1); // If we still have a connection object, clean up its listeners\n\n      if (this.connection) this._cleanupConnection();\n      this.status = Status.DISCONNECTED;\n      /**\n       * Emitted when a shard's WebSocket closes.\n       * @private\n       * @event WebSocketShard#close\n       * @param {CloseEvent} event The received event\n       */\n\n      this.emit(ShardEvents.CLOSE, event);\n    }\n    /**\n     * Called whenever a packet is received.\n     * @param {Object} packet The received packet\n     * @private\n     */\n\n  }, {\n    key: \"onPacket\",\n    value: function onPacket(packet) {\n      if (!packet) {\n        this.debug(\"Received broken packet: '\".concat(packet, \"'.\"));\n        return;\n      }\n\n      switch (packet.t) {\n        case WSEvents.READY:\n          /**\n           * Emitted when the shard receives the READY payload and is now waiting for guilds\n           * @event WebSocketShard#ready\n           */\n          this.emit(ShardEvents.READY);\n          this.sessionID = packet.d.session_id;\n          this.expectedGuilds = new Set(packet.d.guilds.map(function (d) {\n            return d.id;\n          }));\n          this.status = Status.WAITING_FOR_GUILDS;\n          this.debug(\"[READY] Session \".concat(this.sessionID, \".\"));\n          this.lastHeartbeatAcked = true;\n          this.sendHeartbeat('ReadyHeartbeat');\n          break;\n\n        case WSEvents.RESUMED:\n          {\n            /**\n             * Emitted when the shard resumes successfully\n             * @event WebSocketShard#resumed\n             */\n            this.emit(ShardEvents.RESUMED);\n            this.status = Status.READY;\n            var replayed = packet.s - this.closeSequence;\n            this.debug(\"[RESUMED] Session \".concat(this.sessionID, \" | Replayed \").concat(replayed, \" events.\"));\n            this.lastHeartbeatAcked = true;\n            this.sendHeartbeat('ResumeHeartbeat');\n            break;\n          }\n      }\n\n      if (packet.s > this.sequence) this.sequence = packet.s;\n\n      switch (packet.op) {\n        case OPCodes.HELLO:\n          this.setHelloTimeout(-1);\n          this.setHeartbeatTimer(packet.d.heartbeat_interval);\n          this.identify();\n          break;\n\n        case OPCodes.RECONNECT:\n          this.debug('[RECONNECT] Discord asked us to reconnect');\n          this.destroy({\n            closeCode: 4000\n          });\n          break;\n\n        case OPCodes.INVALID_SESSION:\n          this.debug(\"[INVALID SESSION] Resumable: \".concat(packet.d, \".\")); // If we can resume the session, do so immediately\n\n          if (packet.d) {\n            this.identifyResume();\n            return;\n          } // Reset the sequence\n\n\n          this.sequence = -1; // Reset the session ID as it's invalid\n\n          this.sessionID = undefined; // Set the status to reconnecting\n\n          this.status = Status.RECONNECTING; // Finally, emit the INVALID_SESSION event\n\n          this.emit(ShardEvents.INVALID_SESSION);\n          break;\n\n        case OPCodes.HEARTBEAT_ACK:\n          this.ackHeartbeat();\n          break;\n\n        case OPCodes.HEARTBEAT:\n          this.sendHeartbeat('HeartbeatRequest', true);\n          break;\n\n        default:\n          this.manager.handlePacket(packet, this);\n\n          if (this.status === Status.WAITING_FOR_GUILDS && packet.t === WSEvents.GUILD_CREATE) {\n            this.expectedGuilds[\"delete\"](packet.d.id);\n            this.checkReady();\n          }\n\n      }\n    }\n    /**\n     * Checks if the shard can be marked as ready\n     * @private\n     */\n\n  }, {\n    key: \"checkReady\",\n    value: function checkReady() {\n      var _this3 = this;\n\n      // Step 0. Clear the ready timeout, if it exists\n      if (this.readyTimeout) {\n        this.manager.client.clearTimeout(this.readyTimeout);\n        this.readyTimeout = undefined;\n      } // Step 1. If we don't have any other guilds pending, we are ready\n\n\n      if (!this.expectedGuilds.size) {\n        this.debug('Shard received all its guilds. Marking as fully ready.');\n        this.status = Status.READY;\n        /**\n         * Emitted when the shard is fully ready.\n         * This event is emitted if:\n         * * all guilds were received by this shard\n         * * the ready timeout expired, and some guilds are unavailable\n         * @event WebSocketShard#allReady\n         * @param {?Set<string>} unavailableGuilds Set of unavailable guilds, if any\n         */\n\n        this.emit(ShardEvents.ALL_READY);\n        return;\n      } // Step 2. Create a 15s timeout that will mark the shard as ready if there are still unavailable guilds\n\n\n      this.readyTimeout = this.manager.client.setTimeout(function () {\n        _this3.debug(\"Shard did not receive any more guild packets in 15 seconds.\\n  Unavailable guild count: \".concat(_this3.expectedGuilds.size));\n\n        _this3.readyTimeout = undefined;\n        _this3.status = Status.READY;\n\n        _this3.emit(ShardEvents.ALL_READY, _this3.expectedGuilds);\n      }, 15000);\n    }\n    /**\n     * Sets the HELLO packet timeout.\n     * @param {number} [time] If set to -1, it will clear the hello timeout timeout\n     * @private\n     */\n\n  }, {\n    key: \"setHelloTimeout\",\n    value: function setHelloTimeout(time) {\n      var _this4 = this;\n\n      if (time === -1) {\n        if (this.helloTimeout) {\n          this.debug('Clearing the HELLO timeout.');\n          this.manager.client.clearTimeout(this.helloTimeout);\n          this.helloTimeout = undefined;\n        }\n\n        return;\n      }\n\n      this.debug('Setting a HELLO timeout for 20s.');\n      this.helloTimeout = this.manager.client.setTimeout(function () {\n        _this4.debug('Did not receive HELLO in time. Destroying and connecting again.');\n\n        _this4.destroy({\n          reset: true,\n          closeCode: 4009\n        });\n      }, 20000);\n    }\n    /**\n     * Sets the heartbeat timer for this shard.\n     * @param {number} time If -1, clears the interval, any other number sets an interval\n     * @private\n     */\n\n  }, {\n    key: \"setHeartbeatTimer\",\n    value: function setHeartbeatTimer(time) {\n      var _this5 = this;\n\n      if (time === -1) {\n        if (this.heartbeatInterval) {\n          this.debug('Clearing the heartbeat interval.');\n          this.manager.client.clearInterval(this.heartbeatInterval);\n          this.heartbeatInterval = undefined;\n        }\n\n        return;\n      }\n\n      this.debug(\"Setting a heartbeat interval for \".concat(time, \"ms.\")); // Sanity checks\n\n      if (this.heartbeatInterval) this.manager.client.clearInterval(this.heartbeatInterval);\n      this.heartbeatInterval = this.manager.client.setInterval(function () {\n        return _this5.sendHeartbeat();\n      }, time);\n    }\n    /**\n     * Sends a heartbeat to the WebSocket.\n     * If this shard didn't receive a heartbeat last time, it will destroy it and reconnect\n     * @param {string} [tag='HeartbeatTimer'] What caused this heartbeat to be sent\n     * @param {boolean} [ignoreHeartbeatAck] If we should send the heartbeat forcefully.\n     * @private\n     */\n\n  }, {\n    key: \"sendHeartbeat\",\n    value: function sendHeartbeat() {\n      var tag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'HeartbeatTimer';\n      var ignoreHeartbeatAck = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [Status.WAITING_FOR_GUILDS, Status.IDENTIFYING, Status.RESUMING].includes(this.status);\n\n      if (ignoreHeartbeatAck && !this.lastHeartbeatAcked) {\n        this.debug(\"[\".concat(tag, \"] Didn't process heartbeat ack yet but we are still connected. Sending one now.\"));\n      } else if (!this.lastHeartbeatAcked) {\n        this.debug(\"[\".concat(tag, \"] Didn't receive a heartbeat ack last time, assuming zombie connection. Destroying and reconnecting.\\n    Status          : \").concat(STATUS_KEYS[this.status], \"\\n    Sequence        : \").concat(this.sequence, \"\\n    Connection State: \").concat(this.connection ? CONNECTION_STATE[this.connection.readyState] : 'No Connection??'));\n        this.destroy({\n          closeCode: 4009,\n          reset: true\n        });\n        return;\n      }\n\n      this.debug(\"[\".concat(tag, \"] Sending a heartbeat.\"));\n      this.lastHeartbeatAcked = false;\n      this.lastPingTimestamp = Date.now();\n      this.send({\n        op: OPCodes.HEARTBEAT,\n        d: this.sequence\n      }, true);\n    }\n    /**\n     * Acknowledges a heartbeat.\n     * @private\n     */\n\n  }, {\n    key: \"ackHeartbeat\",\n    value: function ackHeartbeat() {\n      this.lastHeartbeatAcked = true;\n      var latency = Date.now() - this.lastPingTimestamp;\n      this.debug(\"Heartbeat acknowledged, latency of \".concat(latency, \"ms.\"));\n      this.ping = latency;\n    }\n    /**\n     * Identifies the client on the connection.\n     * @private\n     * @returns {void}\n     */\n\n  }, {\n    key: \"identify\",\n    value: function identify() {\n      return this.sessionID ? this.identifyResume() : this.identifyNew();\n    }\n    /**\n     * Identifies as a new connection on the gateway.\n     * @private\n     */\n\n  }, {\n    key: \"identifyNew\",\n    value: function identifyNew() {\n      var client = this.manager.client;\n\n      if (!client.token) {\n        this.debug('[IDENTIFY] No token available to identify a new session.');\n        return;\n      }\n\n      this.status = Status.IDENTIFYING; // Clone the identify payload and assign the token and shard info\n\n      var d = _objectSpread(_objectSpread({}, client.options.ws), {}, {\n        token: client.token,\n        shard: [this.id, Number(client.options.shardCount)]\n      });\n\n      this.debug(\"[IDENTIFY] Shard \".concat(this.id, \"/\").concat(client.options.shardCount));\n      this.send({\n        op: OPCodes.IDENTIFY,\n        d: d\n      }, true);\n    }\n    /**\n     * Resumes a session on the gateway.\n     * @private\n     */\n\n  }, {\n    key: \"identifyResume\",\n    value: function identifyResume() {\n      if (!this.sessionID) {\n        this.debug('[RESUME] No session ID was present; identifying as a new session.');\n        this.identifyNew();\n        return;\n      }\n\n      this.status = Status.RESUMING;\n      this.debug(\"[RESUME] Session \".concat(this.sessionID, \", sequence \").concat(this.closeSequence));\n      var d = {\n        token: this.manager.client.token,\n        session_id: this.sessionID,\n        seq: this.closeSequence\n      };\n      this.send({\n        op: OPCodes.RESUME,\n        d: d\n      }, true);\n    }\n    /**\n     * Adds a packet to the queue to be sent to the gateway.\n     * <warn>If you use this method, make sure you understand that you need to provide\n     * a full [Payload](https://discordapp.com/developers/docs/topics/gateway#commands-and-events-gateway-commands).\n     * Do not use this method if you don't know what you're doing.</warn>\n     * @param {Object} data The full packet to send\n     * @param {boolean} [important=false] If this packet should be added first in queue\n     */\n\n  }, {\n    key: \"send\",\n    value: function send(data) {\n      var important = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      this.ratelimit.queue[important ? 'unshift' : 'push'](data);\n      this.processQueue();\n    }\n    /**\n     * Sends data, bypassing the queue.\n     * @param {Object} data Packet to send\n     * @returns {void}\n     * @private\n     */\n\n  }, {\n    key: \"_send\",\n    value: function _send(data) {\n      var _this6 = this;\n\n      if (!this.connection || this.connection.readyState !== WebSocket.OPEN) {\n        this.debug(\"Tried to send packet '\".concat(JSON.stringify(data), \"' but no WebSocket is available!\"));\n        this.destroy({\n          close: 4000\n        });\n        return;\n      }\n\n      this.connection.send(WebSocket.pack(data), function (err) {\n        if (err) _this6.manager.client.emit(Events.SHARD_ERROR, err, _this6.id);\n      });\n    }\n    /**\n     * Processes the current WebSocket queue.\n     * @returns {void}\n     * @private\n     */\n\n  }, {\n    key: \"processQueue\",\n    value: function processQueue() {\n      var _this7 = this;\n\n      if (this.ratelimit.remaining === 0) return;\n      if (this.ratelimit.queue.length === 0) return;\n\n      if (this.ratelimit.remaining === this.ratelimit.total) {\n        this.ratelimit.timer = this.manager.client.setTimeout(function () {\n          _this7.ratelimit.remaining = _this7.ratelimit.total;\n\n          _this7.processQueue();\n        }, this.ratelimit.time);\n      }\n\n      while (this.ratelimit.remaining > 0) {\n        var item = this.ratelimit.queue.shift();\n        if (!item) return;\n\n        this._send(item);\n\n        this.ratelimit.remaining--;\n      }\n    }\n    /**\n     * Destroys this shard and closes its WebSocket connection.\n     * @param {Object} [options={ closeCode: 1000, reset: false, emit: true, log: true }] Options for destroying the shard\n     * @private\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref2$closeCode = _ref2.closeCode,\n          closeCode = _ref2$closeCode === void 0 ? 1000 : _ref2$closeCode,\n          _ref2$reset = _ref2.reset,\n          reset = _ref2$reset === void 0 ? false : _ref2$reset,\n          _ref2$emit = _ref2.emit,\n          emit = _ref2$emit === void 0 ? true : _ref2$emit,\n          _ref2$log = _ref2.log,\n          log = _ref2$log === void 0 ? true : _ref2$log;\n\n      if (log) {\n        this.debug(\"[DESTROY]\\n    Close Code    : \".concat(closeCode, \"\\n    Reset         : \").concat(reset, \"\\n    Emit DESTROYED: \").concat(emit));\n      } // Step 0: Remove all timers\n\n\n      this.setHeartbeatTimer(-1);\n      this.setHelloTimeout(-1); // Step 1: Close the WebSocket connection, if any, otherwise, emit DESTROYED\n\n      if (this.connection) {\n        // If the connection is currently opened, we will (hopefully) receive close\n        if (this.connection.readyState === WebSocket.OPEN) {\n          this.connection.close(closeCode);\n        } else {\n          // Connection is not OPEN\n          this.debug(\"WS State: \".concat(CONNECTION_STATE[this.connection.readyState])); // Remove listeners from the connection\n\n          this._cleanupConnection(); // Attempt to close the connection just in case\n\n\n          try {\n            this.connection.close(closeCode);\n          } catch (_unused2) {} // No-op\n          // Emit the destroyed event if needed\n\n\n          if (emit) this._emitDestroyed();\n        }\n      } else if (emit) {\n        // We requested a destroy, but we had no connection. Emit destroyed\n        this._emitDestroyed();\n      } // Step 2: Null the connection object\n\n\n      this.connection = null; // Step 3: Set the shard status to DISCONNECTED\n\n      this.status = Status.DISCONNECTED; // Step 4: Cache the old sequence (use to attempt a resume)\n\n      if (this.sequence !== -1) this.closeSequence = this.sequence; // Step 5: Reset the sequence and session ID if requested\n\n      if (reset) {\n        this.sequence = -1;\n        this.sessionID = undefined;\n      } // Step 6: reset the ratelimit data\n\n\n      this.ratelimit.remaining = this.ratelimit.total;\n      this.ratelimit.queue.length = 0;\n\n      if (this.ratelimit.timer) {\n        this.manager.client.clearTimeout(this.ratelimit.timer);\n        this.ratelimit.timer = null;\n      }\n    }\n    /**\n     * Cleans up the WebSocket connection listeners.\n     * @private\n     */\n\n  }, {\n    key: \"_cleanupConnection\",\n    value: function _cleanupConnection() {\n      this.connection.onopen = this.connection.onclose = this.connection.onerror = this.connection.onmessage = null;\n    }\n    /**\n     * Emits the DESTROYED event on the shard\n     * @private\n     */\n\n  }, {\n    key: \"_emitDestroyed\",\n    value: function _emitDestroyed() {\n      /**\n       * Emitted when a shard is destroyed, but no WebSocket connection was present.\n       * @private\n       * @event WebSocketShard#destroyed\n       */\n      this.emit(ShardEvents.DESTROYED);\n    }\n  }]);\n\n  return WebSocketShard;\n}(EventEmitter);\n\nmodule.exports = WebSocketShard;","map":null,"metadata":{},"sourceType":"module"}