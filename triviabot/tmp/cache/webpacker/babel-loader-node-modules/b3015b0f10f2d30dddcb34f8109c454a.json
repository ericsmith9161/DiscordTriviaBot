{"ast":null,"code":"'use strict';\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar Collector = require('./interfaces/Collector');\n\nvar Collection = require('../util/Collection');\n\nvar _require = require('../util/Constants'),\n    Events = _require.Events;\n/**\n * @typedef {CollectorOptions} ReactionCollectorOptions\n * @property {number} max The maximum total amount of reactions to collect\n * @property {number} maxEmojis The maximum number of emojis to collect\n * @property {number} maxUsers The maximum number of users to react\n */\n\n/**\n * Collects reactions on messages.\n * Will automatically stop if the message (`'messageDelete'`),\n * channel (`'channelDelete'`), or guild (`'guildDelete'`) are deleted.\n * @extends {Collector}\n */\n\n\nvar ReactionCollector = /*#__PURE__*/function (_Collector) {\n  _inherits(ReactionCollector, _Collector);\n\n  var _super = _createSuper(ReactionCollector);\n\n  /**\n   * @param {Message} message The message upon which to collect reactions\n   * @param {CollectorFilter} filter The filter to apply to this collector\n   * @param {ReactionCollectorOptions} [options={}] The options to apply to this collector\n   */\n  function ReactionCollector(message, filter) {\n    var _this;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, ReactionCollector);\n\n    _this = _super.call(this, message.client, filter, options);\n    /**\n     * The message upon which to collect reactions\n     * @type {Message}\n     */\n\n    _this.message = message;\n    /**\n     * The users which have reacted to this message\n     * @type {Collection}\n     */\n\n    _this.users = new Collection();\n    /**\n     * The total number of reactions collected\n     * @type {number}\n     */\n\n    _this.total = 0;\n    _this.empty = _this.empty.bind(_assertThisInitialized(_this));\n    _this._handleChannelDeletion = _this._handleChannelDeletion.bind(_assertThisInitialized(_this));\n    _this._handleGuildDeletion = _this._handleGuildDeletion.bind(_assertThisInitialized(_this));\n    _this._handleMessageDeletion = _this._handleMessageDeletion.bind(_assertThisInitialized(_this));\n    if (_this.client.getMaxListeners() !== 0) _this.client.setMaxListeners(_this.client.getMaxListeners() + 1);\n\n    _this.client.on(Events.MESSAGE_REACTION_ADD, _this.handleCollect);\n\n    _this.client.on(Events.MESSAGE_REACTION_REMOVE, _this.handleDispose);\n\n    _this.client.on(Events.MESSAGE_REACTION_REMOVE_ALL, _this.empty);\n\n    _this.client.on(Events.MESSAGE_DELETE, _this._handleMessageDeletion);\n\n    _this.client.on(Events.CHANNEL_DELETE, _this._handleChannelDeletion);\n\n    _this.client.on(Events.GUILD_DELETE, _this._handleGuildDeletion);\n\n    _this.once('end', function () {\n      _this.client.removeListener(Events.MESSAGE_REACTION_ADD, _this.handleCollect);\n\n      _this.client.removeListener(Events.MESSAGE_REACTION_REMOVE, _this.handleDispose);\n\n      _this.client.removeListener(Events.MESSAGE_REACTION_REMOVE_ALL, _this.empty);\n\n      _this.client.removeListener(Events.MESSAGE_DELETE, _this._handleMessageDeletion);\n\n      _this.client.removeListener(Events.CHANNEL_DELETE, _this._handleChannelDeletion);\n\n      _this.client.removeListener(Events.GUILD_DELETE, _this._handleGuildDeletion);\n\n      if (_this.client.getMaxListeners() !== 0) _this.client.setMaxListeners(_this.client.getMaxListeners() - 1);\n    });\n\n    _this.on('collect', function (reaction, user) {\n      _this.total++;\n\n      _this.users.set(user.id, user);\n    });\n\n    _this.on('remove', function (reaction, user) {\n      _this.total--;\n      if (!_this.collected.some(function (r) {\n        return r.users.cache.has(user.id);\n      })) _this.users[\"delete\"](user.id);\n    });\n\n    return _this;\n  }\n  /**\n   * Handles an incoming reaction for possible collection.\n   * @param {MessageReaction} reaction The reaction to possibly collect\n   * @returns {?Snowflake|string}\n   * @private\n   */\n\n\n  _createClass(ReactionCollector, [{\n    key: \"collect\",\n    value: function collect(reaction) {\n      /**\n       * Emitted whenever a reaction is collected.\n       * @event ReactionCollector#collect\n       * @param {MessageReaction} reaction The reaction that was collected\n       * @param {User} user The user that added the reaction\n       */\n      if (reaction.message.id !== this.message.id) return null;\n      return ReactionCollector.key(reaction);\n    }\n    /**\n     * Handles a reaction deletion for possible disposal.\n     * @param {MessageReaction} reaction The reaction to possibly dispose of\n     * @param {User} user The user that removed the reaction\n     * @returns {?Snowflake|string}\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose(reaction, user) {\n      /**\n       * Emitted whenever a reaction is disposed of.\n       * @event ReactionCollector#dispose\n       * @param {MessageReaction} reaction The reaction that was disposed of\n       * @param {User} user The user that removed the reaction\n       */\n      if (reaction.message.id !== this.message.id) return null;\n      /**\n       * Emitted whenever a reaction is removed from a message. Will emit on all reaction removals,\n       * as opposed to {@link Collector#dispose} which will only be emitted when the entire reaction\n       * is removed.\n       * @event ReactionCollector#remove\n       * @param {MessageReaction} reaction The reaction that was removed\n       * @param {User} user The user that removed the reaction\n       */\n\n      if (this.collected.has(ReactionCollector.key(reaction)) && this.users.has(user.id)) {\n        this.emit('remove', reaction, user);\n      }\n\n      return reaction.count ? null : ReactionCollector.key(reaction);\n    }\n    /**\n     * Empties this reaction collector.\n     */\n\n  }, {\n    key: \"empty\",\n    value: function empty() {\n      this.total = 0;\n      this.collected.clear();\n      this.users.clear();\n      this.checkEnd();\n    }\n  }, {\n    key: \"endReason\",\n    value: function endReason() {\n      if (this.options.max && this.total >= this.options.max) return 'limit';\n      if (this.options.maxEmojis && this.collected.size >= this.options.maxEmojis) return 'emojiLimit';\n      if (this.options.maxUsers && this.users.size >= this.options.maxUsers) return 'userLimit';\n      return null;\n    }\n    /**\n     * Handles checking if the message has been deleted, and if so, stops the collector with the reason 'messageDelete'.\n     * @private\n     * @param {Message} message The message that was deleted\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_handleMessageDeletion\",\n    value: function _handleMessageDeletion(message) {\n      if (message.id === this.message.id) {\n        this.stop('messageDelete');\n      }\n    }\n    /**\n     * Handles checking if the channel has been deleted, and if so, stops the collector with the reason 'channelDelete'.\n     * @private\n     * @param {GuildChannel} channel The channel that was deleted\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_handleChannelDeletion\",\n    value: function _handleChannelDeletion(channel) {\n      if (channel.id === this.message.channel.id) {\n        this.stop('channelDelete');\n      }\n    }\n    /**\n     * Handles checking if the guild has been deleted, and if so, stops the collector with the reason 'guildDelete'.\n     * @private\n     * @param {Guild} guild The guild that was deleted\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_handleGuildDeletion\",\n    value: function _handleGuildDeletion(guild) {\n      if (this.message.guild && guild.id === this.message.guild.id) {\n        this.stop('guildDelete');\n      }\n    }\n    /**\n     * Gets the collector key for a reaction.\n     * @param {MessageReaction} reaction The message reaction to get the key for\n     * @returns {Snowflake|string}\n     */\n\n  }], [{\n    key: \"key\",\n    value: function key(reaction) {\n      return reaction.emoji.id || reaction.emoji.name;\n    }\n  }]);\n\n  return ReactionCollector;\n}(Collector);\n\nmodule.exports = ReactionCollector;","map":null,"metadata":{},"sourceType":"module"}