{"ast":null,"code":"'use strict';\n\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _awaitAsyncGenerator(value) { return new _AwaitValue(value); }\n\nfunction _wrapAsyncGenerator(fn) { return function () { return new _AsyncGenerator(fn.apply(this, arguments)); }; }\n\nfunction _AsyncGenerator(gen) { var front, back; function send(key, arg) { return new Promise(function (resolve, reject) { var request = { key: key, arg: arg, resolve: resolve, reject: reject, next: null }; if (back) { back = back.next = request; } else { front = back = request; resume(key, arg); } }); } function resume(key, arg) { try { var result = gen[key](arg); var value = result.value; var wrappedAwait = value instanceof _AwaitValue; Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) { if (wrappedAwait) { resume(key === \"return\" ? \"return\" : \"next\", arg); return; } settle(result.done ? \"return\" : \"normal\", arg); }, function (err) { resume(\"throw\", err); }); } catch (err) { settle(\"throw\", err); } } function settle(type, value) { switch (type) { case \"return\": front.resolve({ value: value, done: true }); break; case \"throw\": front.reject(value); break; default: front.resolve({ value: value, done: false }); break; } front = front.next; if (front) { resume(front.key, front.arg); } else { back = null; } } this._invoke = send; if (typeof gen[\"return\"] !== \"function\") { this[\"return\"] = undefined; } }\n\nif (typeof Symbol === \"function\" && Symbol.asyncIterator) { _AsyncGenerator.prototype[Symbol.asyncIterator] = function () { return this; }; }\n\n_AsyncGenerator.prototype.next = function (arg) { return this._invoke(\"next\", arg); };\n\n_AsyncGenerator.prototype[\"throw\"] = function (arg) { return this._invoke(\"throw\", arg); };\n\n_AsyncGenerator.prototype[\"return\"] = function (arg) { return this._invoke(\"return\", arg); };\n\nfunction _AwaitValue(value) { this.wrapped = value; }\n\nvar EventEmitter = require('events');\n\nvar Collection = require('../../util/Collection');\n\nvar Util = require('../../util/Util');\n/**\n * Filter to be applied to the collector.\n * @typedef {Function} CollectorFilter\n * @param {...*} args Any arguments received by the listener\n * @param {Collection} collection The items collected by this collector\n * @returns {boolean}\n */\n\n/**\n * Options to be applied to the collector.\n * @typedef {Object} CollectorOptions\n * @property {number} [time] How long to run the collector for in milliseconds\n * @property {number} [idle] How long to stop the collector after inactivity in milliseconds\n * @property {boolean} [dispose=false] Whether to dispose data when it's deleted\n */\n\n/**\n * Abstract class for defining a new Collector.\n * @abstract\n */\n\n\nvar Collector = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Collector, _EventEmitter);\n\n  var _super = _createSuper(Collector);\n\n  function Collector(client, filter) {\n    var _this2;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, Collector);\n\n    _this2 = _super.call(this);\n    /**\n     * The client that instantiated this Collector\n     * @name Collector#client\n     * @type {Client}\n     * @readonly\n     */\n\n    Object.defineProperty(_assertThisInitialized(_this2), 'client', {\n      value: client\n    });\n    /**\n     * The filter applied to this collector\n     * @type {CollectorFilter}\n     */\n\n    _this2.filter = filter;\n    /**\n     * The options of this collector\n     * @type {CollectorOptions}\n     */\n\n    _this2.options = options;\n    /**\n     * The items collected by this collector\n     * @type {Collection}\n     */\n\n    _this2.collected = new Collection();\n    /**\n     * Whether this collector has finished collecting\n     * @type {boolean}\n     */\n\n    _this2.ended = false;\n    /**\n     * Timeout for cleanup\n     * @type {?Timeout}\n     * @private\n     */\n\n    _this2._timeout = null;\n    /**\n     * Timeout for cleanup due to inactivity\n     * @type {?Timeout}\n     * @private\n     */\n\n    _this2._idletimeout = null;\n    _this2.handleCollect = _this2.handleCollect.bind(_assertThisInitialized(_this2));\n    _this2.handleDispose = _this2.handleDispose.bind(_assertThisInitialized(_this2));\n    if (options.time) _this2._timeout = _this2.client.setTimeout(function () {\n      return _this2.stop('time');\n    }, options.time);\n    if (options.idle) _this2._idletimeout = _this2.client.setTimeout(function () {\n      return _this2.stop('idle');\n    }, options.idle);\n    return _this2;\n  }\n  /**\n   * Call this to handle an event as a collectable element. Accepts any event data as parameters.\n   * @param {...*} args The arguments emitted by the listener\n   * @emits Collector#collect\n   */\n\n\n  _createClass(Collector, [{\n    key: \"handleCollect\",\n    value: function handleCollect() {\n      var _this3 = this;\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var collect = this.collect.apply(this, args);\n\n      if (collect && this.filter.apply(this, args.concat([this.collected]))) {\n        this.collected.set(collect, args[0]);\n        /**\n         * Emitted whenever an element is collected.\n         * @event Collector#collect\n         * @param {...*} args The arguments emitted by the listener\n         */\n\n        this.emit.apply(this, ['collect'].concat(args));\n\n        if (this._idletimeout) {\n          this.client.clearTimeout(this._idletimeout);\n          this._idletimeout = this.client.setTimeout(function () {\n            return _this3.stop('idle');\n          }, this.options.idle);\n        }\n      }\n\n      this.checkEnd();\n    }\n    /**\n     * Call this to remove an element from the collection. Accepts any event data as parameters.\n     * @param {...*} args The arguments emitted by the listener\n     * @emits Collector#dispose\n     */\n\n  }, {\n    key: \"handleDispose\",\n    value: function handleDispose() {\n      if (!this.options.dispose) return;\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      var dispose = this.dispose.apply(this, args);\n      if (!dispose || !this.filter.apply(this, args) || !this.collected.has(dispose)) return;\n      this.collected[\"delete\"](dispose);\n      /**\n       * Emitted whenever an element is disposed of.\n       * @event Collector#dispose\n       * @param {...*} args The arguments emitted by the listener\n       */\n\n      this.emit.apply(this, ['dispose'].concat(args));\n      this.checkEnd();\n    }\n    /**\n     * Returns a promise that resolves with the next collected element;\n     * rejects with collected elements if the collector finishes without receiving a next element\n     * @type {Promise}\n     * @readonly\n     */\n\n  }, {\n    key: \"stop\",\n\n    /**\n     * Stops this collector and emits the `end` event.\n     * @param {string} [reason='user'] The reason this collector is ending\n     * @emits Collector#end\n     */\n    value: function stop() {\n      var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'user';\n      if (this.ended) return;\n\n      if (this._timeout) {\n        this.client.clearTimeout(this._timeout);\n        this._timeout = null;\n      }\n\n      if (this._idletimeout) {\n        this.client.clearTimeout(this._idletimeout);\n        this._idletimeout = null;\n      }\n\n      this.ended = true;\n      /**\n       * Emitted when the collector is finished collecting.\n       * @event Collector#end\n       * @param {Collection} collected The elements collected by the collector\n       * @param {string} reason The reason the collector ended\n       */\n\n      this.emit('end', this.collected, reason);\n    }\n    /**\n     * Resets the collectors timeout and idle timer.\n     * @param {Object} [options] Options\n     * @param {number} [options.time] How long to run the collector for in milliseconds\n     * @param {number} [options.idle] How long to stop the collector after inactivity in milliseconds\n     */\n\n  }, {\n    key: \"resetTimer\",\n    value: function resetTimer() {\n      var _this4 = this;\n\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          time = _ref.time,\n          idle = _ref.idle;\n\n      if (this._timeout) {\n        this.client.clearTimeout(this._timeout);\n        this._timeout = this.client.setTimeout(function () {\n          return _this4.stop('time');\n        }, time || this.options.time);\n      }\n\n      if (this._idletimeout) {\n        this.client.clearTimeout(this._idletimeout);\n        this._idletimeout = this.client.setTimeout(function () {\n          return _this4.stop('idle');\n        }, idle || this.options.idle);\n      }\n    }\n    /**\n     * Checks whether the collector should end, and if so, ends it.\n     */\n\n  }, {\n    key: \"checkEnd\",\n    value: function checkEnd() {\n      var reason = this.endReason();\n      if (reason) this.stop(reason);\n    }\n    /**\n     * Allows collectors to be consumed with for-await-of loops\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of}\n     */\n\n  }, {\n    key: Symbol.asyncIterator,\n    value: function value() {\n      var _this = this;\n\n      return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var queue, onCollect;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                queue = [];\n\n                onCollect = function onCollect(item) {\n                  return queue.push(item);\n                };\n\n                _this.on('collect', onCollect);\n\n                _context.prev = 3;\n\n              case 4:\n                if (!(queue.length || !_this.ended)) {\n                  _context.next = 14;\n                  break;\n                }\n\n                if (!queue.length) {\n                  _context.next = 10;\n                  break;\n                }\n\n                _context.next = 8;\n                return queue.shift();\n\n              case 8:\n                _context.next = 12;\n                break;\n\n              case 10:\n                _context.next = 12;\n                return _awaitAsyncGenerator(new Promise(function (resolve) {\n                  var tick = function tick() {\n                    _this.removeListener('collect', tick);\n\n                    _this.removeListener('end', tick);\n\n                    return resolve();\n                  };\n\n                  _this.on('collect', tick);\n\n                  _this.on('end', tick);\n                }));\n\n              case 12:\n                _context.next = 4;\n                break;\n\n              case 14:\n                _context.prev = 14;\n\n                _this.removeListener('collect', onCollect);\n\n                return _context.finish(14);\n\n              case 17:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[3,, 14, 17]]);\n      }))();\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return Util.flatten(this);\n    }\n    /* eslint-disable no-empty-function, valid-jsdoc */\n\n    /**\n     * Handles incoming events from the `handleCollect` function. Returns null if the event should not\n     * be collected, or returns an object describing the data that should be stored.\n     * @see Collector#handleCollect\n     * @param {...*} args Any args the event listener emits\n     * @returns {?{key, value}} Data to insert into collection, if any\n     * @abstract\n     */\n\n  }, {\n    key: \"collect\",\n    value: function collect() {}\n    /**\n     * Handles incoming events from the `handleDispose`. Returns null if the event should not\n     * be disposed, or returns the key that should be removed.\n     * @see Collector#handleDispose\n     * @param {...*} args Any args the event listener emits\n     * @returns {?*} Key to remove from the collection, if any\n     * @abstract\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {}\n    /**\n     * The reason this collector has ended or will end with.\n     * @returns {?string} Reason to end the collector, if any\n     * @abstract\n     */\n\n  }, {\n    key: \"endReason\",\n    value: function endReason() {}\n    /* eslint-enable no-empty-function, valid-jsdoc */\n\n  }, {\n    key: \"next\",\n    get: function get() {\n      var _this5 = this;\n\n      return new Promise(function (resolve, reject) {\n        if (_this5.ended) {\n          reject(_this5.collected);\n          return;\n        }\n\n        var cleanup = function cleanup() {\n          _this5.removeListener('collect', onCollect);\n\n          _this5.removeListener('end', onEnd);\n        };\n\n        var onCollect = function onCollect(item) {\n          cleanup();\n          resolve(item);\n        };\n\n        var onEnd = function onEnd() {\n          cleanup();\n          reject(_this5.collected); // eslint-disable-line prefer-promise-reject-errors\n        };\n\n        _this5.on('collect', onCollect);\n\n        _this5.on('end', onEnd);\n      });\n    }\n  }]);\n\n  return Collector;\n}(EventEmitter);\n\nmodule.exports = Collector;","map":null,"metadata":{},"sourceType":"module"}