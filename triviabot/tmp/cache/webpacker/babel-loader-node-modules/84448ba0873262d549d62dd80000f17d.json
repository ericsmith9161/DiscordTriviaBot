{"ast":null,"code":"'use strict';\n\nfunction _createForOfIteratorHelper(o) { if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Collection = require('../util/Collection');\n\nvar _require = require('../util/Constants'),\n    ChannelTypes = _require.ChannelTypes;\n\nvar Util = require('../util/Util');\n/**\n * Keeps track of mentions in a {@link Message}.\n */\n\n\nvar MessageMentions = /*#__PURE__*/function () {\n  function MessageMentions(message, users, roles, everyone, crosspostedChannels) {\n    _classCallCheck(this, MessageMentions);\n\n    /**\n     * The client the message is from\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, 'client', {\n      value: message.client\n    });\n    /**\n     * The guild the message is in\n     * @type {?Guild}\n     * @readonly\n     */\n\n    Object.defineProperty(this, 'guild', {\n      value: message.guild\n    });\n    /**\n     * The initial message content\n     * @type {string}\n     * @readonly\n     * @private\n     */\n\n    Object.defineProperty(this, '_content', {\n      value: message.content\n    });\n    /**\n     * Whether `@everyone` or `@here` were mentioned\n     * @type {boolean}\n     */\n\n    this.everyone = Boolean(everyone);\n\n    if (users) {\n      if (users instanceof Collection) {\n        /**\n         * Any users that were mentioned\n         * <info>Order as received from the API, not as they appear in the message content</info>\n         * @type {Collection<Snowflake, User>}\n         */\n        this.users = new Collection(users);\n      } else {\n        this.users = new Collection();\n\n        var _iterator = _createForOfIteratorHelper(users),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var mention = _step.value;\n\n            if (mention.member && message.guild) {\n              message.guild.members.add(Object.assign(mention.member, {\n                user: mention\n              }));\n            }\n\n            var user = message.client.users.add(mention);\n            this.users.set(user.id, user);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n    } else {\n      this.users = new Collection();\n    }\n\n    if (roles) {\n      if (roles instanceof Collection) {\n        /**\n         * Any roles that were mentioned\n         * <info>Order as received from the API, not as they appear in the message content</info>\n         * @type {Collection<Snowflake, Role>}\n         */\n        this.roles = new Collection(roles);\n      } else {\n        this.roles = new Collection();\n\n        var _iterator2 = _createForOfIteratorHelper(roles),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _mention = _step2.value;\n            var role = message.channel.guild.roles.cache.get(_mention);\n            if (role) this.roles.set(role.id, role);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n    } else {\n      this.roles = new Collection();\n    }\n    /**\n     * Cached members for {@link MessageMention#members}\n     * @type {?Collection<Snowflake, GuildMember>}\n     * @private\n     */\n\n\n    this._members = null;\n    /**\n     * Cached channels for {@link MessageMention#channels}\n     * @type {?Collection<Snowflake, GuildChannel>}\n     * @private\n     */\n\n    this._channels = null;\n    /**\n     * Crossposted channel data.\n     * @typedef {Object} CrosspostedChannel\n     * @property {string} channelID ID of the mentioned channel\n     * @property {string} guildID ID of the guild that has the channel\n     * @property {string} type Type of the channel\n     * @property {string} name The name of the channel\n     */\n\n    if (crosspostedChannels) {\n      if (crosspostedChannels instanceof Collection) {\n        /**\n         * A collection of crossposted channels\n         * <info>Order as received from the API, not as they appear in the message content</info>\n         * @type {Collection<Snowflake, CrosspostedChannel>}\n         */\n        this.crosspostedChannels = new Collection(crosspostedChannels);\n      } else {\n        this.crosspostedChannels = new Collection();\n        var channelTypes = Object.keys(ChannelTypes);\n\n        var _iterator3 = _createForOfIteratorHelper(crosspostedChannels),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var d = _step3.value;\n            var type = channelTypes[d.type];\n            this.crosspostedChannels.set(d.id, {\n              channelID: d.id,\n              guildID: d.guild_id,\n              type: type ? type.toLowerCase() : 'unknown',\n              name: d.name\n            });\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n    } else {\n      this.crosspostedChannels = new Collection();\n    }\n  }\n  /**\n   * Any members that were mentioned (only in {@link TextChannel}s)\n   * <info>Order as received from the API, not as they appear in the message content</info>\n   * @type {?Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n\n\n  _createClass(MessageMentions, [{\n    key: \"has\",\n\n    /**\n     * Checks if a user, guild member, role, or channel is mentioned.\n     * Takes into account user mentions, role mentions, and @everyone/@here mentions.\n     * @param {UserResolvable|GuildMember|Role|GuildChannel} data User/GuildMember/Role/Channel to check\n     * @param {Object} [options] Options\n     * @param {boolean} [options.ignoreDirect=false] - Whether to ignore direct mentions to the item\n     * @param {boolean} [options.ignoreRoles=false] - Whether to ignore role mentions to a guild member\n     * @param {boolean} [options.ignoreEveryone=false] - Whether to ignore everyone/here mentions\n     * @returns {boolean}\n     */\n    value: function has(data) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref$ignoreDirect = _ref.ignoreDirect,\n          ignoreDirect = _ref$ignoreDirect === void 0 ? false : _ref$ignoreDirect,\n          _ref$ignoreRoles = _ref.ignoreRoles,\n          ignoreRoles = _ref$ignoreRoles === void 0 ? false : _ref$ignoreRoles,\n          _ref$ignoreEveryone = _ref.ignoreEveryone,\n          ignoreEveryone = _ref$ignoreEveryone === void 0 ? false : _ref$ignoreEveryone;\n\n      if (!ignoreEveryone && this.everyone) return true;\n\n      var GuildMember = require('./GuildMember');\n\n      if (!ignoreRoles && data instanceof GuildMember) {\n        var _iterator4 = _createForOfIteratorHelper(this.roles.values()),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var role = _step4.value;\n            if (data.roles.cache.has(role.id)) return true;\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      }\n\n      if (!ignoreDirect) {\n        var id = data.id || data;\n        return this.users.has(id) || this.channels.has(id) || this.roles.has(id);\n      }\n\n      return false;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return Util.flatten(this, {\n        members: true,\n        channels: true\n      });\n    }\n  }, {\n    key: \"members\",\n    get: function get() {\n      var _this = this;\n\n      if (this._members) return this._members;\n      if (!this.guild) return null;\n      this._members = new Collection();\n      this.users.forEach(function (user) {\n        var member = _this.guild.member(user);\n\n        if (member) _this._members.set(member.user.id, member);\n      });\n      return this._members;\n    }\n    /**\n     * Any channels that were mentioned\n     * <info>Order as they appear first in the message content</info>\n     * @type {Collection<Snowflake, GuildChannel>}\n     * @readonly\n     */\n\n  }, {\n    key: \"channels\",\n    get: function get() {\n      if (this._channels) return this._channels;\n      this._channels = new Collection();\n      var matches;\n\n      while ((matches = this.constructor.CHANNELS_PATTERN.exec(this._content)) !== null) {\n        var chan = this.client.channels.cache.get(matches[1]);\n        if (chan) this._channels.set(chan.id, chan);\n      }\n\n      return this._channels;\n    }\n  }]);\n\n  return MessageMentions;\n}();\n/**\n * Regular expression that globally matches `@everyone` and `@here`\n * @type {RegExp}\n */\n\n\nMessageMentions.EVERYONE_PATTERN = /@(everyone|here)/g;\n/**\n * Regular expression that globally matches user mentions like `<@81440962496172032>`\n * @type {RegExp}\n */\n\nMessageMentions.USERS_PATTERN = /<@!?(\\d{17,19})>/g;\n/**\n * Regular expression that globally matches role mentions like `<@&297577916114403338>`\n * @type {RegExp}\n */\n\nMessageMentions.ROLES_PATTERN = /<@&(\\d{17,19})>/g;\n/**\n * Regular expression that globally matches channel mentions like `<#222079895583457280>`\n * @type {RegExp}\n */\n\nMessageMentions.CHANNELS_PATTERN = /<#(\\d{17,19})>/g;\nmodule.exports = MessageMentions;","map":null,"metadata":{},"sourceType":"module"}