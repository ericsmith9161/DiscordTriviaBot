{"ast":null,"code":"'use strict';\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar _require = require('../errors'),\n    RangeError = _require.RangeError;\n\nvar Util = require('../util/Util');\n/**\n * Represents an embed in a message (image/video preview, rich embed, etc.)\n */\n\n\nvar MessageEmbed = /*#__PURE__*/function () {\n  /**\n   * @name MessageEmbed\n   * @kind constructor\n   * @memberof MessageEmbed\n   * @param {MessageEmbed|Object} [data={}] MessageEmbed to clone or raw embed data\n   */\n  function MessageEmbed() {\n    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var skipValidation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    _classCallCheck(this, MessageEmbed);\n\n    this.setup(data, skipValidation);\n  }\n\n  _createClass(MessageEmbed, [{\n    key: \"setup\",\n    value: function setup(data, skipValidation) {\n      /**\n       * The type of this embed, either:\n       * * `rich` - a rich embed\n       * * `image` - an image embed\n       * * `video` - a video embed\n       * * `gifv` - a gifv embed\n       * * `article` - an article embed\n       * * `link` - a link embed\n       * @type {string}\n       */\n      this.type = data.type;\n      /**\n       * The title of this embed\n       * @type {?string}\n       */\n\n      this.title = data.title;\n      /**\n       * The description of this embed\n       * @type {?string}\n       */\n\n      this.description = data.description;\n      /**\n       * The URL of this embed\n       * @type {?string}\n       */\n\n      this.url = data.url;\n      /**\n       * The color of this embed\n       * @type {?number}\n       */\n\n      this.color = Util.resolveColor(data.color);\n      /**\n       * The timestamp of this embed\n       * @type {?number}\n       */\n\n      this.timestamp = data.timestamp ? new Date(data.timestamp).getTime() : null;\n      /**\n       * @typedef {Object} EmbedField\n       * @property {string} name The name of this field\n       * @property {string} value The value of this field\n       * @property {boolean} inline If this field will be displayed inline\n       */\n\n      /**\n       * The fields of this embed\n       * @type {EmbedField[]}\n       */\n\n      this.fields = [];\n\n      if (data.fields) {\n        this.fields = skipValidation ? data.fields.map(Util.cloneObject) : this.constructor.normalizeFields(data.fields);\n      }\n      /**\n       * @typedef {Object} MessageEmbedThumbnail\n       * @property {string} url URL for this thumbnail\n       * @property {string} proxyURL ProxyURL for this thumbnail\n       * @property {number} height Height of this thumbnail\n       * @property {number} width Width of this thumbnail\n       */\n\n      /**\n       * The thumbnail of this embed (if there is one)\n       * @type {?MessageEmbedThumbnail}\n       */\n\n\n      this.thumbnail = data.thumbnail ? {\n        url: data.thumbnail.url,\n        proxyURL: data.thumbnail.proxyURL || data.thumbnail.proxy_url,\n        height: data.thumbnail.height,\n        width: data.thumbnail.width\n      } : null;\n      /**\n       * @typedef {Object} MessageEmbedImage\n       * @property {string} url URL for this image\n       * @property {string} proxyURL ProxyURL for this image\n       * @property {number} height Height of this image\n       * @property {number} width Width of this image\n       */\n\n      /**\n       * The image of this embed, if there is one\n       * @type {?MessageEmbedImage}\n       */\n\n      this.image = data.image ? {\n        url: data.image.url,\n        proxyURL: data.image.proxyURL || data.image.proxy_url,\n        height: data.image.height,\n        width: data.image.width\n      } : null;\n      /**\n       * @typedef {Object} MessageEmbedVideo\n       * @property {string} url URL of this video\n       * @property {string} proxyURL ProxyURL for this video\n       * @property {number} height Height of this video\n       * @property {number} width Width of this video\n       */\n\n      /**\n       * The video of this embed (if there is one)\n       * @type {?MessageEmbedVideo}\n       * @readonly\n       */\n\n      this.video = data.video ? {\n        url: data.video.url,\n        proxyURL: data.video.proxyURL || data.video.proxy_url,\n        height: data.video.height,\n        width: data.video.width\n      } : null;\n      /**\n       * @typedef {Object} MessageEmbedAuthor\n       * @property {string} name The name of this author\n       * @property {string} url URL of this author\n       * @property {string} iconURL URL of the icon for this author\n       * @property {string} proxyIconURL Proxied URL of the icon for this author\n       */\n\n      /**\n       * The author of this embed (if there is one)\n       * @type {?MessageEmbedAuthor}\n       */\n\n      this.author = data.author ? {\n        name: data.author.name,\n        url: data.author.url,\n        iconURL: data.author.iconURL || data.author.icon_url,\n        proxyIconURL: data.author.proxyIconURL || data.author.proxy_icon_url\n      } : null;\n      /**\n       * @typedef {Object} MessageEmbedProvider\n       * @property {string} name The name of this provider\n       * @property {string} url URL of this provider\n       */\n\n      /**\n       * The provider of this embed (if there is one)\n       * @type {?MessageEmbedProvider}\n       */\n\n      this.provider = data.provider ? {\n        name: data.provider.name,\n        url: data.provider.name\n      } : null;\n      /**\n       * @typedef {Object} MessageEmbedFooter\n       * @property {string} text The text of this footer\n       * @property {string} iconURL URL of the icon for this footer\n       * @property {string} proxyIconURL Proxied URL of the icon for this footer\n       */\n\n      /**\n       * The footer of this embed\n       * @type {?MessageEmbedFooter}\n       */\n\n      this.footer = data.footer ? {\n        text: data.footer.text,\n        iconURL: data.footer.iconURL || data.footer.icon_url,\n        proxyIconURL: data.footer.proxyIconURL || data.footer.proxy_icon_url\n      } : null;\n      /**\n       * The files of this embed\n       * @type {Array<FileOptions|string|MessageAttachment>}\n       */\n\n      this.files = data.files || [];\n    }\n    /**\n     * The date displayed on this embed\n     * @type {?Date}\n     * @readonly\n     */\n\n  }, {\n    key: \"addField\",\n\n    /**\n     * Adds a field to the embed (max 25).\n     * @param {StringResolvable} name The name of this field\n     * @param {StringResolvable} value The value of this field\n     * @param {boolean} [inline=false] If this field will be displayed inline\n     * @returns {MessageEmbed}\n     */\n    value: function addField(name, value, inline) {\n      return this.addFields({\n        name: name,\n        value: value,\n        inline: inline\n      });\n    }\n    /**\n     * Adds fields to the embed (max 25).\n     * @param {...EmbedFieldData|EmbedFieldData[]} fields The fields to add\n     * @returns {MessageEmbed}\n     */\n\n  }, {\n    key: \"addFields\",\n    value: function addFields() {\n      var _this$fields;\n\n      for (var _len = arguments.length, fields = new Array(_len), _key = 0; _key < _len; _key++) {\n        fields[_key] = arguments[_key];\n      }\n\n      (_this$fields = this.fields).push.apply(_this$fields, _toConsumableArray(this.constructor.normalizeFields(fields)));\n\n      return this;\n    }\n    /**\n     * Removes, replaces, and inserts fields in the embed (max 25).\n     * @param {number} index The index to start at\n     * @param {number} deleteCount The number of fields to remove\n     * @param {...EmbedFieldData|EmbedFieldData[]} [fields] The replacing field objects\n     * @returns {MessageEmbed}\n     */\n\n  }, {\n    key: \"spliceFields\",\n    value: function spliceFields(index, deleteCount) {\n      var _this$fields2, _this$constructor;\n\n      for (var _len2 = arguments.length, fields = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        fields[_key2 - 2] = arguments[_key2];\n      }\n\n      (_this$fields2 = this.fields).splice.apply(_this$fields2, [index, deleteCount].concat(_toConsumableArray((_this$constructor = this.constructor).normalizeFields.apply(_this$constructor, fields))));\n\n      return this;\n    }\n    /**\n     * Sets the file to upload alongside the embed. This file can be accessed via `attachment://fileName.extension` when\n     * setting an embed image or author/footer icons. Multiple files can be attached.\n     * @param {Array<FileOptions|string|MessageAttachment>} files Files to attach\n     * @returns {MessageEmbed}\n     */\n\n  }, {\n    key: \"attachFiles\",\n    value: function attachFiles(files) {\n      this.files = this.files.concat(files);\n      return this;\n    }\n    /**\n     * Sets the author of this embed.\n     * @param {StringResolvable} name The name of the author\n     * @param {string} [iconURL] The icon URL of the author\n     * @param {string} [url] The URL of the author\n     * @returns {MessageEmbed}\n     */\n\n  }, {\n    key: \"setAuthor\",\n    value: function setAuthor(name, iconURL, url) {\n      this.author = {\n        name: Util.resolveString(name),\n        iconURL: iconURL,\n        url: url\n      };\n      return this;\n    }\n    /**\n     * Sets the color of this embed.\n     * @param {ColorResolvable} color The color of the embed\n     * @returns {MessageEmbed}\n     */\n\n  }, {\n    key: \"setColor\",\n    value: function setColor(color) {\n      this.color = Util.resolveColor(color);\n      return this;\n    }\n    /**\n     * Sets the description of this embed.\n     * @param {StringResolvable} description The description\n     * @returns {MessageEmbed}\n     */\n\n  }, {\n    key: \"setDescription\",\n    value: function setDescription(description) {\n      description = Util.resolveString(description);\n      this.description = description;\n      return this;\n    }\n    /**\n     * Sets the footer of this embed.\n     * @param {StringResolvable} text The text of the footer\n     * @param {string} [iconURL] The icon URL of the footer\n     * @returns {MessageEmbed}\n     */\n\n  }, {\n    key: \"setFooter\",\n    value: function setFooter(text, iconURL) {\n      text = Util.resolveString(text);\n      this.footer = {\n        text: text,\n        iconURL: iconURL\n      };\n      return this;\n    }\n    /**\n     * Sets the image of this embed.\n     * @param {string} url The URL of the image\n     * @returns {MessageEmbed}\n     */\n\n  }, {\n    key: \"setImage\",\n    value: function setImage(url) {\n      this.image = {\n        url: url\n      };\n      return this;\n    }\n    /**\n     * Sets the thumbnail of this embed.\n     * @param {string} url The URL of the thumbnail\n     * @returns {MessageEmbed}\n     */\n\n  }, {\n    key: \"setThumbnail\",\n    value: function setThumbnail(url) {\n      this.thumbnail = {\n        url: url\n      };\n      return this;\n    }\n    /**\n     * Sets the timestamp of this embed.\n     * @param {Date|number} [timestamp=Date.now()] The timestamp or date\n     * @returns {MessageEmbed}\n     */\n\n  }, {\n    key: \"setTimestamp\",\n    value: function setTimestamp() {\n      var timestamp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Date.now();\n      if (timestamp instanceof Date) timestamp = timestamp.getTime();\n      this.timestamp = timestamp;\n      return this;\n    }\n    /**\n     * Sets the title of this embed.\n     * @param {StringResolvable} title The title\n     * @returns {MessageEmbed}\n     */\n\n  }, {\n    key: \"setTitle\",\n    value: function setTitle(title) {\n      title = Util.resolveString(title);\n      this.title = title;\n      return this;\n    }\n    /**\n     * Sets the URL of this embed.\n     * @param {string} url The URL\n     * @returns {MessageEmbed}\n     */\n\n  }, {\n    key: \"setURL\",\n    value: function setURL(url) {\n      this.url = url;\n      return this;\n    }\n    /**\n     * Transforms the embed to a plain object.\n     * @returns {Object} The raw data of this embed\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        title: this.title,\n        type: 'rich',\n        description: this.description,\n        url: this.url,\n        timestamp: this.timestamp ? new Date(this.timestamp) : null,\n        color: this.color,\n        fields: this.fields,\n        thumbnail: this.thumbnail,\n        image: this.image,\n        author: this.author ? {\n          name: this.author.name,\n          url: this.author.url,\n          icon_url: this.author.iconURL\n        } : null,\n        footer: this.footer ? {\n          text: this.footer.text,\n          icon_url: this.footer.iconURL\n        } : null\n      };\n    }\n    /**\n     * Normalizes field input and resolves strings.\n     * @param {StringResolvable} name The name of the field\n     * @param {StringResolvable} value The value of the field\n     * @param {boolean} [inline=false] Set the field to display inline\n     * @returns {EmbedField}\n     */\n\n  }, {\n    key: \"createdAt\",\n    get: function get() {\n      return this.timestamp ? new Date(this.timestamp) : null;\n    }\n    /**\n     * The hexadecimal version of the embed color, with a leading hash\n     * @type {?string}\n     * @readonly\n     */\n\n  }, {\n    key: \"hexColor\",\n    get: function get() {\n      return this.color ? \"#\".concat(this.color.toString(16).padStart(6, '0')) : null;\n    }\n    /**\n     * The accumulated length for the embed title, description, fields and footer text\n     * @type {number}\n     * @readonly\n     */\n\n  }, {\n    key: \"length\",\n    get: function get() {\n      return (this.title ? this.title.length : 0) + (this.description ? this.description.length : 0) + (this.fields.length >= 1 ? this.fields.reduce(function (prev, curr) {\n        return prev + curr.name.length + curr.value.length;\n      }, 0) : 0) + (this.footer ? this.footer.text.length : 0);\n    }\n  }], [{\n    key: \"normalizeField\",\n    value: function normalizeField(name, value) {\n      var inline = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      name = Util.resolveString(name);\n      if (!name) throw new RangeError('EMBED_FIELD_NAME');\n      value = Util.resolveString(value);\n      if (!value) throw new RangeError('EMBED_FIELD_VALUE');\n      return {\n        name: name,\n        value: value,\n        inline: inline\n      };\n    }\n    /**\n     * @typedef {Object} EmbedFieldData\n     * @property {StringResolvable} name The name of this field\n     * @property {StringResolvable} value The value of this field\n     * @property {boolean} [inline] If this field will be displayed inline\n     */\n\n    /**\n     * Normalizes field input and resolves strings.\n     * @param  {...EmbedFieldData|EmbedFieldData[]} fields Fields to normalize\n     * @returns {EmbedField[]}\n     */\n\n  }, {\n    key: \"normalizeFields\",\n    value: function normalizeFields() {\n      var _this = this;\n\n      for (var _len3 = arguments.length, fields = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        fields[_key3] = arguments[_key3];\n      }\n\n      return fields.flat(2).map(function (field) {\n        return _this.normalizeField(field && field.name, field && field.value, field && typeof field.inline === 'boolean' ? field.inline : false);\n      });\n    }\n  }]);\n\n  return MessageEmbed;\n}();\n\nmodule.exports = MessageEmbed;","map":null,"metadata":{},"sourceType":"module"}