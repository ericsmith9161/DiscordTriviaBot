{"ast":null,"code":"'use strict';\n\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar GuildEmoji = require('./GuildEmoji');\n\nvar ReactionEmoji = require('./ReactionEmoji');\n\nvar ReactionUserManager = require('../managers/ReactionUserManager');\n\nvar Util = require('../util/Util');\n/**\n * Represents a reaction to a message.\n */\n\n\nvar MessageReaction = /*#__PURE__*/function () {\n  /**\n   * @param {Client} client The instantiating client\n   * @param {Object} data The data for the message reaction\n   * @param {Message} message The message the reaction refers to\n   */\n  function MessageReaction(client, data, message) {\n    _classCallCheck(this, MessageReaction);\n\n    /**\n     * The client that instantiated this message reaction\n     * @name MessageReaction#client\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, 'client', {\n      value: client\n    });\n    /**\n     * The message that this reaction refers to\n     * @type {Message}\n     */\n\n    this.message = message;\n    /**\n     * Whether the client has given this reaction\n     * @type {boolean}\n     */\n\n    this.me = data.me;\n    /**\n     * A manager of the users that have given this reaction\n     * @type {ReactionUserManager}\n     */\n\n    this.users = new ReactionUserManager(client, undefined, this);\n    this._emoji = new ReactionEmoji(this, data.emoji);\n\n    this._patch(data);\n  }\n\n  _createClass(MessageReaction, [{\n    key: \"_patch\",\n    value: function _patch(data) {\n      /**\n       * The number of people that have given the same reaction\n       * @type {?number}\n       * @name MessageReaction#count\n       */\n      // eslint-disable-next-line eqeqeq\n      if (this.count == undefined) this.count = data.count;\n    }\n    /**\n     * Removes all users from this reaction.\n     * @returns {Promise<MessageReaction>}\n     */\n\n  }, {\n    key: \"remove\",\n    value: function () {\n      var _remove2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.client.api.channels(this.message.channel.id).messages(this.message.id).reactions(this._emoji.identifier)[\"delete\"]();\n\n              case 2:\n                return _context.abrupt(\"return\", this);\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function remove() {\n        return _remove2.apply(this, arguments);\n      }\n\n      return remove;\n    }()\n    /**\n     * The emoji of this reaction, either an GuildEmoji object for known custom emojis, or a ReactionEmoji\n     * object which has fewer properties. Whatever the prototype of the emoji, it will still have\n     * `name`, `id`, `identifier` and `toString()`\n     * @type {GuildEmoji|ReactionEmoji}\n     * @readonly\n     */\n\n  }, {\n    key: \"fetch\",\n\n    /**\n     * Fetch this reaction.\n     * @returns {Promise<MessageReaction>}\n     */\n    value: function () {\n      var _fetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var message, existing;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.message.fetch();\n\n              case 2:\n                message = _context2.sent;\n                existing = message.reactions.cache.get(this.emoji.id || this.emoji.name); // The reaction won't get set when it has been completely removed\n\n                this._patch(existing || {\n                  count: 0\n                });\n\n                return _context2.abrupt(\"return\", this);\n\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function fetch() {\n        return _fetch.apply(this, arguments);\n      }\n\n      return fetch;\n    }()\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return Util.flatten(this, {\n        emoji: 'emojiID',\n        message: 'messageID'\n      });\n    }\n  }, {\n    key: \"_add\",\n    value: function _add(user) {\n      if (this.partial) return;\n      this.users.cache.set(user.id, user);\n      if (!this.me || user.id !== this.message.client.user.id || this.count === 0) this.count++;\n      if (!this.me) this.me = user.id === this.message.client.user.id;\n    }\n  }, {\n    key: \"_remove\",\n    value: function _remove(user) {\n      if (this.partial) return;\n      this.users.cache[\"delete\"](user.id);\n      if (!this.me || user.id !== this.message.client.user.id) this.count--;\n      if (user.id === this.message.client.user.id) this.me = false;\n\n      if (this.count <= 0 && this.users.cache.size === 0) {\n        this.message.reactions.cache[\"delete\"](this.emoji.id || this.emoji.name);\n      }\n    }\n  }, {\n    key: \"emoji\",\n    get: function get() {\n      if (this._emoji instanceof GuildEmoji) return this._emoji; // Check to see if the emoji has become known to the client\n\n      if (this._emoji.id) {\n        var emojis = this.message.client.emojis.cache;\n\n        if (emojis.has(this._emoji.id)) {\n          var emoji = emojis.get(this._emoji.id);\n          this._emoji = emoji;\n          return emoji;\n        }\n      }\n\n      return this._emoji;\n    }\n    /**\n     * Whether or not this reaction is a partial\n     * @type {boolean}\n     * @readonly\n     */\n\n  }, {\n    key: \"partial\",\n    get: function get() {\n      return this.count === null;\n    }\n  }]);\n\n  return MessageReaction;\n}();\n\nmodule.exports = MessageReaction;","map":null,"metadata":{},"sourceType":"module"}