{"ast":null,"code":"'use strict';\n\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar _require = require('../errors'),\n    RangeError = _require.RangeError;\n/**\n * Data structure that makes it easy to interact with a bitfield.\n */\n\n\nvar BitField = /*#__PURE__*/function () {\n  /**\n   * @param {BitFieldResolvable} [bits=0] Bit(s) to read from\n   */\n  function BitField(bits) {\n    _classCallCheck(this, BitField);\n\n    /**\n     * Bitfield of the packed bits\n     * @type {number}\n     */\n    this.bitfield = this.constructor.resolve(bits);\n  }\n  /**\n   * Checks whether the bitfield has a bit, or any of multiple bits.\n   * @param {BitFieldResolvable} bit Bit(s) to check for\n   * @returns {boolean}\n   */\n\n\n  _createClass(BitField, [{\n    key: \"any\",\n    value: function any(bit) {\n      return (this.bitfield & this.constructor.resolve(bit)) !== 0;\n    }\n    /**\n     * Checks if this bitfield equals another\n     * @param {BitFieldResolvable} bit Bit(s) to check for\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"equals\",\n    value: function equals(bit) {\n      return this.bitfield === this.constructor.resolve(bit);\n    }\n    /**\n     * Checks whether the bitfield has a bit, or multiple bits.\n     * @param {BitFieldResolvable} bit Bit(s) to check for\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"has\",\n    value: function has(bit) {\n      var _this = this;\n\n      if (Array.isArray(bit)) return bit.every(function (p) {\n        return _this.has(p);\n      });\n      bit = this.constructor.resolve(bit);\n      return (this.bitfield & bit) === bit;\n    }\n    /**\n     * Gets all given bits that are missing from the bitfield.\n     * @param {BitFieldResolvable} bits Bit(s) to check for\n     * @param {...*} hasParams Additional parameters for the has method, if any\n     * @returns {string[]}\n     */\n\n  }, {\n    key: \"missing\",\n    value: function missing(bits) {\n      var _this2 = this;\n\n      for (var _len = arguments.length, hasParams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        hasParams[_key - 1] = arguments[_key];\n      }\n\n      if (!Array.isArray(bits)) bits = new this.constructor(bits).toArray(false);\n      return bits.filter(function (p) {\n        return !_this2.has.apply(_this2, [p].concat(hasParams));\n      });\n    }\n    /**\n     * Freezes these bits, making them immutable.\n     * @returns {Readonly<BitField>} These bits\n     */\n\n  }, {\n    key: \"freeze\",\n    value: function freeze() {\n      return Object.freeze(this);\n    }\n    /**\n     * Adds bits to these ones.\n     * @param {...BitFieldResolvable} [bits] Bits to add\n     * @returns {BitField} These bits or new BitField if the instance is frozen.\n     */\n\n  }, {\n    key: \"add\",\n    value: function add() {\n      var total = 0;\n\n      for (var _len2 = arguments.length, bits = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        bits[_key2] = arguments[_key2];\n      }\n\n      for (var _i = 0, _bits = bits; _i < _bits.length; _i++) {\n        var bit = _bits[_i];\n        total |= this.constructor.resolve(bit);\n      }\n\n      if (Object.isFrozen(this)) return new this.constructor(this.bitfield | total);\n      this.bitfield |= total;\n      return this;\n    }\n    /**\n     * Removes bits from these.\n     * @param {...BitFieldResolvable} [bits] Bits to remove\n     * @returns {BitField} These bits or new BitField if the instance is frozen.\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var total = 0;\n\n      for (var _len3 = arguments.length, bits = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        bits[_key3] = arguments[_key3];\n      }\n\n      for (var _i2 = 0, _bits2 = bits; _i2 < _bits2.length; _i2++) {\n        var bit = _bits2[_i2];\n        total |= this.constructor.resolve(bit);\n      }\n\n      if (Object.isFrozen(this)) return new this.constructor(this.bitfield & ~total);\n      this.bitfield &= ~total;\n      return this;\n    }\n    /**\n     * Gets an object mapping field names to a {@link boolean} indicating whether the\n     * bit is available.\n     * @param {...*} hasParams Additional parameters for the has method, if any\n     * @returns {Object}\n     */\n\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      var serialized = {};\n\n      for (var _len4 = arguments.length, hasParams = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        hasParams[_key4] = arguments[_key4];\n      }\n\n      for (var _i3 = 0, _Object$entries = Object.entries(this.constructor.FLAGS); _i3 < _Object$entries.length; _i3++) {\n        var _ref3 = _Object$entries[_i3];\n\n        var _ref2 = _slicedToArray(_ref3, 2);\n\n        var flag = _ref2[0];\n        var bit = _ref2[1];\n        serialized[flag] = this.has.apply(this, [bit].concat(hasParams));\n      }\n\n      return serialized;\n    }\n    /**\n     * Gets an {@link Array} of bitfield names based on the bits available.\n     * @param {...*} hasParams Additional parameters for the has method, if any\n     * @returns {string[]}\n     */\n\n  }, {\n    key: \"toArray\",\n    value: function toArray() {\n      var _this3 = this;\n\n      for (var _len5 = arguments.length, hasParams = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        hasParams[_key5] = arguments[_key5];\n      }\n\n      return Object.keys(this.constructor.FLAGS).filter(function (bit) {\n        return _this3.has.apply(_this3, [bit].concat(hasParams));\n      });\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.bitfield;\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      return this.bitfield;\n    }\n  }, {\n    key: Symbol.iterator,\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function value() {\n      return _regeneratorRuntime.wrap(function value$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.delegateYield(this.toArray(), \"t0\", 1);\n\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, value, this);\n    })\n    /**\n     * Data that can be resolved to give a bitfield. This can be:\n     * * A string (see {@link BitField.FLAGS})\n     * * A bit number\n     * * An instance of BitField\n     * * An Array of BitFieldResolvable\n     * @typedef {string|number|BitField|BitFieldResolvable[]} BitFieldResolvable\n     */\n\n    /**\n     * Resolves bitfields to their numeric form.\n     * @param {BitFieldResolvable} [bit=0] - bit(s) to resolve\n     * @returns {number}\n     */\n\n  }], [{\n    key: \"resolve\",\n    value: function resolve() {\n      var _this4 = this;\n\n      var bit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      if (typeof bit === 'number' && bit >= 0) return bit;\n      if (bit instanceof BitField) return bit.bitfield;\n      if (Array.isArray(bit)) return bit.map(function (p) {\n        return _this4.resolve(p);\n      }).reduce(function (prev, p) {\n        return prev | p;\n      }, 0);\n      if (typeof bit === 'string' && typeof this.FLAGS[bit] !== 'undefined') return this.FLAGS[bit];\n      throw new RangeError('BITFIELD_INVALID');\n    }\n  }]);\n\n  return BitField;\n}();\n/**\n * Numeric bitfield flags.\n * <info>Defined in extension classes</info>\n * @type {Object}\n * @abstract\n */\n\n\nBitField.FLAGS = {};\nmodule.exports = BitField;","map":null,"metadata":{},"sourceType":"module"}