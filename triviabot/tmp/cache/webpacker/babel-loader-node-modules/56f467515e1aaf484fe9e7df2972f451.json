{"ast":null,"code":"'use strict';\n\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createForOfIteratorHelper(o) { if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Integration = require('./Integration');\n\nvar Webhook = require('./Webhook');\n\nvar Collection = require('../util/Collection');\n\nvar _require = require('../util/Constants'),\n    PartialTypes = _require.PartialTypes;\n\nvar Snowflake = require('../util/Snowflake');\n\nvar Util = require('../util/Util');\n/**\n * The target type of an entry, e.g. `GUILD`. Here are the available types:\n * * GUILD\n * * CHANNEL\n * * USER\n * * ROLE\n * * INVITE\n * * WEBHOOK\n * * EMOJI\n * * MESSAGE\n * * INTEGRATION\n * @typedef {string} AuditLogTargetType\n */\n\n/**\n * Key mirror of all available audit log targets.\n * @name GuildAuditLogs.Targets\n * @type {AuditLogTargetType}\n */\n\n\nvar Targets = {\n  ALL: 'ALL',\n  GUILD: 'GUILD',\n  CHANNEL: 'CHANNEL',\n  USER: 'USER',\n  ROLE: 'ROLE',\n  INVITE: 'INVITE',\n  WEBHOOK: 'WEBHOOK',\n  EMOJI: 'EMOJI',\n  MESSAGE: 'MESSAGE',\n  INTEGRATION: 'INTEGRATION',\n  UNKNOWN: 'UNKNOWN'\n};\n/**\n * The action of an entry. Here are the available actions:\n * * ALL: null\n * * GUILD_UPDATE: 1\n * * CHANNEL_CREATE: 10\n * * CHANNEL_UPDATE: 11\n * * CHANNEL_DELETE: 12\n * * CHANNEL_OVERWRITE_CREATE: 13\n * * CHANNEL_OVERWRITE_UPDATE: 14\n * * CHANNEL_OVERWRITE_DELETE: 15\n * * MEMBER_KICK: 20\n * * MEMBER_PRUNE: 21\n * * MEMBER_BAN_ADD: 22\n * * MEMBER_BAN_REMOVE: 23\n * * MEMBER_UPDATE: 24\n * * MEMBER_ROLE_UPDATE: 25\n * * MEMBER_MOVE: 26\n * * MEMBER_DISCONNECT: 27\n * * BOT_ADD: 28,\n * * ROLE_CREATE: 30\n * * ROLE_UPDATE: 31\n * * ROLE_DELETE: 32\n * * INVITE_CREATE: 40\n * * INVITE_UPDATE: 41\n * * INVITE_DELETE: 42\n * * WEBHOOK_CREATE: 50\n * * WEBHOOK_UPDATE: 51\n * * WEBHOOK_DELETE: 52\n * * EMOJI_CREATE: 60\n * * EMOJI_UPDATE: 61\n * * EMOJI_DELETE: 62\n * * MESSAGE_DELETE: 72\n * * MESSAGE_BULK_DELETE: 73\n * * MESSAGE_PIN: 74\n * * MESSAGE_UNPIN: 75\n * * INTEGRATION_CREATE: 80\n * * INTEGRATION_UPDATE: 81\n * * INTEGRATION_DELETE: 82\n * @typedef {?number|string} AuditLogAction\n */\n\n/**\n * All available actions keyed under their names to their numeric values.\n * @name GuildAuditLogs.Actions\n * @type {AuditLogAction}\n */\n\nvar Actions = {\n  ALL: null,\n  GUILD_UPDATE: 1,\n  CHANNEL_CREATE: 10,\n  CHANNEL_UPDATE: 11,\n  CHANNEL_DELETE: 12,\n  CHANNEL_OVERWRITE_CREATE: 13,\n  CHANNEL_OVERWRITE_UPDATE: 14,\n  CHANNEL_OVERWRITE_DELETE: 15,\n  MEMBER_KICK: 20,\n  MEMBER_PRUNE: 21,\n  MEMBER_BAN_ADD: 22,\n  MEMBER_BAN_REMOVE: 23,\n  MEMBER_UPDATE: 24,\n  MEMBER_ROLE_UPDATE: 25,\n  MEMBER_MOVE: 26,\n  MEMBER_DISCONNECT: 27,\n  BOT_ADD: 28,\n  ROLE_CREATE: 30,\n  ROLE_UPDATE: 31,\n  ROLE_DELETE: 32,\n  INVITE_CREATE: 40,\n  INVITE_UPDATE: 41,\n  INVITE_DELETE: 42,\n  WEBHOOK_CREATE: 50,\n  WEBHOOK_UPDATE: 51,\n  WEBHOOK_DELETE: 52,\n  EMOJI_CREATE: 60,\n  EMOJI_UPDATE: 61,\n  EMOJI_DELETE: 62,\n  MESSAGE_DELETE: 72,\n  MESSAGE_BULK_DELETE: 73,\n  MESSAGE_PIN: 74,\n  MESSAGE_UNPIN: 75,\n  INTEGRATION_CREATE: 80,\n  INTEGRATION_UPDATE: 81,\n  INTEGRATION_DELETE: 82\n};\n/**\n * Audit logs entries are held in this class.\n */\n\nvar GuildAuditLogs = /*#__PURE__*/function () {\n  function GuildAuditLogs(guild, data) {\n    _classCallCheck(this, GuildAuditLogs);\n\n    if (data.users) {\n      var _iterator = _createForOfIteratorHelper(data.users),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var user = _step.value;\n          guild.client.users.add(user);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    /**\n     * Cached webhooks\n     * @type {Collection<Snowflake, Webhook>}\n     * @private\n     */\n\n\n    this.webhooks = new Collection();\n\n    if (data.webhooks) {\n      var _iterator2 = _createForOfIteratorHelper(data.webhooks),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var hook = _step2.value;\n          this.webhooks.set(hook.id, new Webhook(guild.client, hook));\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n    /**\n     * Cached integrations\n     * @type {Collection<Snowflake, Integration>}\n     * @private\n     */\n\n\n    this.integrations = new Collection();\n\n    if (data.integrations) {\n      var _iterator3 = _createForOfIteratorHelper(data.integrations),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var integration = _step3.value;\n          this.integrations.set(integration.id, new Integration(guild.client, integration, guild));\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n    /**\n     * The entries for this guild's audit logs\n     * @type {Collection<Snowflake, GuildAuditLogsEntry>}\n     */\n\n\n    this.entries = new Collection();\n\n    var _iterator4 = _createForOfIteratorHelper(data.audit_log_entries),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var item = _step4.value;\n        var entry = new GuildAuditLogsEntry(this, guild, item);\n        this.entries.set(entry.id, entry);\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n  }\n  /**\n   * Handles possible promises for entry targets.\n   * @returns {Promise<GuildAuditLogs>}\n   */\n\n\n  _createClass(GuildAuditLogs, [{\n    key: \"toJSON\",\n    value: function toJSON() {\n      return Util.flatten(this);\n    }\n  }], [{\n    key: \"build\",\n    value: function build() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var logs = _construct(GuildAuditLogs, args);\n\n      return Promise.all(logs.entries.map(function (e) {\n        return e.target;\n      })).then(function () {\n        return logs;\n      });\n    }\n    /**\n     * The target of an entry. It can be one of:\n     * * A guild\n     * * A user\n     * * A role\n     * * An emoji\n     * * An invite\n     * * A webhook\n     * * An integration\n     * * An object with an id key if target was deleted\n     * * An object where the keys represent either the new value or the old value\n     * @typedef {?Object|Guild|User|Role|GuildEmoji|Invite|Webhook|Integration} AuditLogEntryTarget\n     */\n\n    /**\n     * Finds the target type from the entry action.\n     * @param {AuditLogAction} target The action target\n     * @returns {AuditLogTargetType}\n     */\n\n  }, {\n    key: \"targetType\",\n    value: function targetType(target) {\n      if (target < 10) return Targets.GUILD;\n      if (target < 20) return Targets.CHANNEL;\n      if (target < 30) return Targets.USER;\n      if (target < 40) return Targets.ROLE;\n      if (target < 50) return Targets.INVITE;\n      if (target < 60) return Targets.WEBHOOK;\n      if (target < 70) return Targets.EMOJI;\n      if (target < 80) return Targets.MESSAGE;\n      if (target < 90) return Targets.INTEGRATION;\n      return Targets.UNKNOWN;\n    }\n    /**\n     * The action type of an entry, e.g. `CREATE`. Here are the available types:\n     * * CREATE\n     * * DELETE\n     * * UPDATE\n     * * ALL\n     * @typedef {string} AuditLogActionType\n     */\n\n    /**\n     * Finds the action type from the entry action.\n     * @param {AuditLogAction} action The action target\n     * @returns {AuditLogActionType}\n     */\n\n  }, {\n    key: \"actionType\",\n    value: function actionType(action) {\n      if ([Actions.CHANNEL_CREATE, Actions.CHANNEL_OVERWRITE_CREATE, Actions.MEMBER_BAN_REMOVE, Actions.BOT_ADD, Actions.ROLE_CREATE, Actions.INVITE_CREATE, Actions.WEBHOOK_CREATE, Actions.EMOJI_CREATE, Actions.MESSAGE_PIN, Actions.INTEGRATION_CREATE].includes(action)) {\n        return 'CREATE';\n      }\n\n      if ([Actions.CHANNEL_DELETE, Actions.CHANNEL_OVERWRITE_DELETE, Actions.MEMBER_KICK, Actions.MEMBER_PRUNE, Actions.MEMBER_BAN_ADD, Actions.MEMBER_DISCONNECT, Actions.ROLE_DELETE, Actions.INVITE_DELETE, Actions.WEBHOOK_DELETE, Actions.EMOJI_DELETE, Actions.MESSAGE_DELETE, Actions.MESSAGE_BULK_DELETE, Actions.MESSAGE_UNPIN, Actions.INTEGRATION_DELETE].includes(action)) {\n        return 'DELETE';\n      }\n\n      if ([Actions.GUILD_UPDATE, Actions.CHANNEL_UPDATE, Actions.CHANNEL_OVERWRITE_UPDATE, Actions.MEMBER_UPDATE, Actions.MEMBER_ROLE_UPDATE, Actions.MEMBER_MOVE, Actions.ROLE_UPDATE, Actions.INVITE_UPDATE, Actions.WEBHOOK_UPDATE, Actions.EMOJI_UPDATE, Actions.INTEGRATION_UPDATE].includes(action)) {\n        return 'UPDATE';\n      }\n\n      return 'ALL';\n    }\n  }]);\n\n  return GuildAuditLogs;\n}();\n/**\n * Audit logs entry.\n */\n\n\nvar GuildAuditLogsEntry = /*#__PURE__*/function () {\n  function GuildAuditLogsEntry(logs, guild, data) {\n    var _this = this;\n\n    _classCallCheck(this, GuildAuditLogsEntry);\n\n    var targetType = GuildAuditLogs.targetType(data.action_type);\n    /**\n     * The target type of this entry\n     * @type {AuditLogTargetType}\n     */\n\n    this.targetType = targetType;\n    /**\n     * The action type of this entry\n     * @type {AuditLogActionType}\n     */\n\n    this.actionType = GuildAuditLogs.actionType(data.action_type);\n    /**\n     * Specific action type of this entry in its string presentation\n     * @type {AuditLogAction}\n     */\n\n    this.action = Object.keys(Actions).find(function (k) {\n      return Actions[k] === data.action_type;\n    });\n    /**\n     * The reason of this entry\n     * @type {?string}\n     */\n\n    this.reason = data.reason || null;\n    /**\n     * The user that executed this entry\n     * @type {User}\n     */\n\n    this.executor = guild.client.options.partials.includes(PartialTypes.USER) ? guild.client.users.add({\n      id: data.user_id\n    }) : guild.client.users.cache.get(data.user_id);\n    /**\n     * An entry in the audit log representing a specific change.\n     * @typedef {object} AuditLogChange\n     * @property {string} key The property that was changed, e.g. `nick` for nickname changes\n     * @property {*} [old] The old value of the change, e.g. for nicknames, the old nickname\n     * @property {*} [new] The new value of the change, e.g. for nicknames, the new nickname\n     */\n\n    /**\n     * Specific property changes\n     * @type {AuditLogChange[]}\n     */\n\n    this.changes = data.changes ? data.changes.map(function (c) {\n      return {\n        key: c.key,\n        old: c.old_value,\n        \"new\": c.new_value\n      };\n    }) : null;\n    /**\n     * The ID of this entry\n     * @type {Snowflake}\n     */\n\n    this.id = data.id;\n    /**\n     * Any extra data from the entry\n     * @type {?Object|Role|GuildMember}\n     */\n\n    this.extra = null;\n\n    switch (data.action_type) {\n      case Actions.MEMBER_PRUNE:\n        this.extra = {\n          removed: Number(data.options.members_removed),\n          days: Number(data.options.delete_member_days)\n        };\n        break;\n\n      case Actions.MEMBER_MOVE:\n      case Actions.MESSAGE_DELETE:\n      case Actions.MESSAGE_BULK_DELETE:\n        this.extra = {\n          channel: guild.channels.cache.get(data.options.channel_id) || {\n            id: data.options.channel_id\n          },\n          count: Number(data.options.count)\n        };\n        break;\n\n      case Actions.MESSAGE_PIN:\n      case Actions.MESSAGE_UNPIN:\n        this.extra = {\n          channel: guild.client.channels.cache.get(data.options.channel_id) || {\n            id: data.options.channel_id\n          },\n          messageID: data.options.message_id\n        };\n        break;\n\n      case Actions.MEMBER_DISCONNECT:\n        this.extra = {\n          count: Number(data.options.count)\n        };\n        break;\n\n      case Actions.CHANNEL_OVERWRITE_CREATE:\n      case Actions.CHANNEL_OVERWRITE_UPDATE:\n      case Actions.CHANNEL_OVERWRITE_DELETE:\n        switch (data.options.type) {\n          case 'member':\n            this.extra = guild.members.cache.get(data.options.id) || {\n              id: data.options.id,\n              type: 'member'\n            };\n            break;\n\n          case 'role':\n            this.extra = guild.roles.cache.get(data.options.id) || {\n              id: data.options.id,\n              name: data.options.role_name,\n              type: 'role'\n            };\n            break;\n\n          default:\n            break;\n        }\n\n        break;\n\n      default:\n        break;\n    }\n    /**\n     * The target of this entry\n     * @type {?AuditLogEntryTarget}\n     */\n\n\n    this.target = null;\n\n    if (targetType === Targets.UNKNOWN) {\n      this.target = this.changes.reduce(function (o, c) {\n        o[c.key] = c[\"new\"] || c.old;\n        return o;\n      }, {});\n      this.target.id = data.target_id; // MEMBER_DISCONNECT and similar types do not provide a target_id.\n    } else if (targetType === Targets.USER && data.target_id) {\n      this.target = guild.client.options.partials.includes(PartialTypes.USER) ? guild.client.users.add({\n        id: data.target_id\n      }) : guild.client.users.cache.get(data.target_id);\n    } else if (targetType === Targets.GUILD) {\n      this.target = guild.client.guilds.cache.get(data.target_id);\n    } else if (targetType === Targets.WEBHOOK) {\n      this.target = logs.webhooks.get(data.target_id) || new Webhook(guild.client, this.changes.reduce(function (o, c) {\n        o[c.key] = c[\"new\"] || c.old;\n        return o;\n      }, {\n        id: data.target_id,\n        guild_id: guild.id\n      }));\n    } else if (targetType === Targets.INVITE) {\n      this.target = guild.members.fetch(guild.client.user.id).then(function (me) {\n        if (me.permissions.has('MANAGE_GUILD')) {\n          var change = _this.changes.find(function (c) {\n            return c.key === 'code';\n          });\n\n          return guild.fetchInvites().then(function (invites) {\n            _this.target = invites.find(function (i) {\n              return i.code === (change[\"new\"] || change.old);\n            });\n          });\n        } else {\n          _this.target = _this.changes.reduce(function (o, c) {\n            o[c.key] = c[\"new\"] || c.old;\n            return o;\n          }, {});\n          return _this.target;\n        }\n      });\n    } else if (targetType === Targets.MESSAGE) {\n      // Discord sends a channel id for the MESSAGE_BULK_DELETE action type.\n      this.target = data.action_type === Actions.MESSAGE_BULK_DELETE ? guild.channels.cache.get(data.target_id) || {\n        id: data.target_id\n      } : guild.client.users.cache.get(data.target_id);\n    } else if (targetType === Targets.INTEGRATION) {\n      this.target = logs.integrations.get(data.target_id) || new Integration(guild.client, this.changes.reduce(function (o, c) {\n        o[c.key] = c[\"new\"] || c.old;\n        return o;\n      }, {\n        id: data.target_id\n      }), guild);\n    } else if (data.target_id) {\n      this.target = guild[\"\".concat(targetType.toLowerCase(), \"s\")].cache.get(data.target_id) || {\n        id: data.target_id\n      };\n    }\n  }\n  /**\n   * The timestamp this entry was created at\n   * @type {number}\n   * @readonly\n   */\n\n\n  _createClass(GuildAuditLogsEntry, [{\n    key: \"toJSON\",\n    value: function toJSON() {\n      return Util.flatten(this, {\n        createdTimestamp: true\n      });\n    }\n  }, {\n    key: \"createdTimestamp\",\n    get: function get() {\n      return Snowflake.deconstruct(this.id).timestamp;\n    }\n    /**\n     * The time this entry was created at\n     * @type {Date}\n     * @readonly\n     */\n\n  }, {\n    key: \"createdAt\",\n    get: function get() {\n      return new Date(this.createdTimestamp);\n    }\n  }]);\n\n  return GuildAuditLogsEntry;\n}();\n\nGuildAuditLogs.Actions = Actions;\nGuildAuditLogs.Targets = Targets;\nGuildAuditLogs.Entry = GuildAuditLogsEntry;\nmodule.exports = GuildAuditLogs;","map":null,"metadata":{},"sourceType":"module"}