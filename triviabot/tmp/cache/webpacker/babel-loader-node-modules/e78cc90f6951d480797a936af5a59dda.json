{"ast":null,"code":"'use strict';\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _createForOfIteratorHelper(o) { if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar BaseManager = require('./BaseManager');\n\nvar _require = require('../errors'),\n    Error = _require.Error,\n    _TypeError = _require.TypeError;\n\nvar GuildMember = require('../structures/GuildMember');\n\nvar Collection = require('../util/Collection');\n\nvar _require2 = require('../util/Constants'),\n    Events = _require2.Events,\n    OPCodes = _require2.OPCodes;\n/**\n * Manages API methods for GuildMembers and stores their cache.\n * @extends {BaseManager}\n */\n\n\nvar GuildMemberManager = /*#__PURE__*/function (_BaseManager) {\n  _inherits(GuildMemberManager, _BaseManager);\n\n  var _super = _createSuper(GuildMemberManager);\n\n  function GuildMemberManager(guild, iterable) {\n    var _this;\n\n    _classCallCheck(this, GuildMemberManager);\n\n    _this = _super.call(this, guild.client, iterable, GuildMember);\n    /**\n     * The guild this manager belongs to\n     * @type {Guild}\n     */\n\n    _this.guild = guild;\n    return _this;\n  }\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, GuildMember>}\n   * @name GuildMemberManager#cache\n   */\n\n\n  _createClass(GuildMemberManager, [{\n    key: \"add\",\n    value: function add(data) {\n      var cache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      return _get(_getPrototypeOf(GuildMemberManager.prototype), \"add\", this).call(this, data, cache, {\n        id: data.user.id,\n        extras: [this.guild]\n      });\n    }\n    /**\n     * Data that resolves to give a GuildMember object. This can be:\n     * * A GuildMember object\n     * * A User resolvable\n     * @typedef {GuildMember|UserResolvable} GuildMemberResolvable\n     */\n\n    /**\n     * Resolves a GuildMemberResolvable to a GuildMember object.\n     * @param {GuildMemberResolvable} member The user that is part of the guild\n     * @returns {?GuildMember}\n     */\n\n  }, {\n    key: \"resolve\",\n    value: function resolve(member) {\n      var memberResolvable = _get(_getPrototypeOf(GuildMemberManager.prototype), \"resolve\", this).call(this, member);\n\n      if (memberResolvable) return memberResolvable;\n      var userResolvable = this.client.users.resolveID(member);\n      if (userResolvable) return _get(_getPrototypeOf(GuildMemberManager.prototype), \"resolve\", this).call(this, userResolvable);\n      return null;\n    }\n    /**\n     * Resolves a GuildMemberResolvable to a member ID string.\n     * @param {GuildMemberResolvable} member The user that is part of the guild\n     * @returns {?Snowflake}\n     */\n\n  }, {\n    key: \"resolveID\",\n    value: function resolveID(member) {\n      var memberResolvable = _get(_getPrototypeOf(GuildMemberManager.prototype), \"resolveID\", this).call(this, member);\n\n      if (memberResolvable) return memberResolvable;\n      var userResolvable = this.client.users.resolveID(member);\n      return this.cache.has(userResolvable) ? userResolvable : null;\n    }\n    /**\n     * Options used to fetch a single member from a guild.\n     * @typedef {Object} FetchMemberOptions\n     * @property {UserResolvable} user The user to fetch\n     * @property {boolean} [cache=true] Whether or not to cache the fetched member\n     */\n\n    /**\n     * Options used to fetch multiple members from a guild.\n     * @typedef {Object} FetchMembersOptions\n     * @property {UserResolvable|UserResolvable[]} user The user(s) to fetch\n     * @property {?string} query Limit fetch to members with similar usernames\n     * @property {number} [limit=0] Maximum number of members to request\n     * @property {boolean} [withPresences=false] Whether or not to include the presences\n     * @property {number} [time=120e3] Timeout for receipt of members\n     */\n\n    /**\n     * Fetches member(s) from Discord, even if they're offline.\n     * @param {UserResolvable|FetchMemberOptions|FetchMembersOptions} [options] If a UserResolvable, the user to fetch.\n     * If undefined, fetches all members.\n     * If a query, it limits the results to users with similar usernames.\n     * @returns {Promise<GuildMember>|Promise<Collection<Snowflake, GuildMember>>}\n     * @example\n     * // Fetch all members from a guild\n     * guild.members.fetch()\n     *   .then(console.log)\n     *   .catch(console.error);\n     * @example\n     * // Fetch a single member\n     * guild.members.fetch('66564597481480192')\n     *   .then(console.log)\n     *   .catch(console.error);\n     * @example\n     * // Fetch a single member without caching\n     * guild.members.fetch({ user, cache: false })\n     *   .then(console.log)\n     *   .catch(console.error);\n     * @example\n     * // Fetch by an array of users including their presences\n     * guild.members.fetch({ user: ['66564597481480192', '191615925336670208'], withPresences: true })\n     *   .then(console.log)\n     *   .catch(console.error);\n     * @example\n     * // Fetch by query\n     * guild.members.fetch({ query: 'hydra', limit: 1 })\n     *   .then(console.log)\n     *   .catch(console.error);\n     */\n\n  }, {\n    key: \"fetch\",\n    value: function fetch(options) {\n      var _this2 = this;\n\n      if (!options) return this._fetchMany();\n      var user = this.client.users.resolveID(options);\n      if (user) return this._fetchSingle({\n        user: user,\n        cache: true\n      });\n\n      if (options.user) {\n        if (Array.isArray(options.user)) {\n          options.user = options.user.map(function (u) {\n            return _this2.client.users.resolveID(u);\n          });\n          return this._fetchMany(options);\n        } else {\n          options.user = this.client.users.resolveID(options.user);\n        }\n\n        if (!options.limit && !options.withPresences) return this._fetchSingle(options);\n      }\n\n      return this._fetchMany(options);\n    }\n    /**\n     * Prunes members from the guild based on how long they have been inactive.\n     * <info>It's recommended to set options.count to `false` for large guilds.</info>\n     * @param {Object} [options] Prune options\n     * @param {number} [options.days=7] Number of days of inactivity required to kick\n     * @param {boolean} [options.dry=false] Get number of users that will be kicked, without actually kicking them\n     * @param {boolean} [options.count=true] Whether or not to return the number of users that have been kicked.\n     * @param {string} [options.reason] Reason for this prune\n     * @returns {Promise<number|null>} The number of members that were/will be kicked\n     * @example\n     * // See how many members will be pruned\n     * guild.members.prune({ dry: true })\n     *   .then(pruned => console.log(`This will prune ${pruned} people!`))\n     *   .catch(console.error);\n     * @example\n     * // Actually prune the members\n     * guild.members.prune({ days: 1, reason: 'too many people!' })\n     *   .then(pruned => console.log(`I just pruned ${pruned} people!`))\n     *   .catch(console.error);\n     */\n\n  }, {\n    key: \"prune\",\n    value: function prune() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref$days = _ref.days,\n          days = _ref$days === void 0 ? 7 : _ref$days,\n          _ref$dry = _ref.dry,\n          dry = _ref$dry === void 0 ? false : _ref$dry,\n          _ref$count = _ref.count,\n          count = _ref$count === void 0 ? true : _ref$count,\n          reason = _ref.reason;\n\n      if (typeof days !== 'number') throw new _TypeError('PRUNE_DAYS_TYPE');\n      return this.client.api.guilds(this.guild.id).prune[dry ? 'get' : 'post']({\n        query: {\n          days: days,\n          compute_prune_count: count\n        },\n        reason: reason\n      }).then(function (data) {\n        return data.pruned;\n      });\n    }\n    /**\n     * Bans a user from the guild.\n     * @param {UserResolvable} user The user to ban\n     * @param {Object} [options] Options for the ban\n     * @param {number} [options.days=0] Number of days of messages to delete\n     * @param {string} [options.reason] Reason for banning\n     * @returns {Promise<GuildMember|User|Snowflake>} Result object will be resolved as specifically as possible.\n     * If the GuildMember cannot be resolved, the User will instead be attempted to be resolved. If that also cannot\n     * be resolved, the user ID will be the result.\n     * @example\n     * // Ban a user by ID (or with a user/guild member object)\n     * guild.members.ban('84484653687267328')\n     *   .then(user => console.log(`Banned ${user.username || user.id || user} from ${guild.name}`))\n     *   .catch(console.error);\n     */\n\n  }, {\n    key: \"ban\",\n    value: function ban(user) {\n      var _this3 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        days: 0\n      };\n      if (options.days) options['delete-message-days'] = options.days;\n      var id = this.client.users.resolveID(user);\n      if (!id) return Promise.reject(new Error('BAN_RESOLVE_ID', true));\n      return this.client.api.guilds(this.guild.id).bans[id].put({\n        query: options\n      }).then(function () {\n        if (user instanceof GuildMember) return user;\n\n        var _user = _this3.client.users.resolve(id);\n\n        if (_user) {\n          var member = _this3.resolve(_user);\n\n          return member || _user;\n        }\n\n        return id;\n      });\n    }\n    /**\n     * Unbans a user from the guild.\n     * @param {UserResolvable} user The user to unban\n     * @param {string} [reason] Reason for unbanning user\n     * @returns {Promise<User>}\n     * @example\n     * // Unban a user by ID (or with a user/guild member object)\n     * guild.members.unban('84484653687267328')\n     *   .then(user => console.log(`Unbanned ${user.username} from ${guild.name}`))\n     *   .catch(console.error);\n     */\n\n  }, {\n    key: \"unban\",\n    value: function unban(user, reason) {\n      var _this4 = this;\n\n      var id = this.client.users.resolveID(user);\n      if (!id) return Promise.reject(new Error('BAN_RESOLVE_ID'));\n      return this.client.api.guilds(this.guild.id).bans[id][\"delete\"]({\n        reason: reason\n      }).then(function () {\n        return _this4.client.users.resolve(user);\n      });\n    }\n  }, {\n    key: \"_fetchSingle\",\n    value: function _fetchSingle(_ref2) {\n      var _this5 = this;\n\n      var user = _ref2.user,\n          cache = _ref2.cache;\n      var existing = this.cache.get(user);\n      if (existing && !existing.partial) return Promise.resolve(existing);\n      return this.client.api.guilds(this.guild.id).members(user).get().then(function (data) {\n        return _this5.add(data, cache);\n      });\n    }\n  }, {\n    key: \"_fetchMany\",\n    value: function _fetchMany() {\n      var _this6 = this;\n\n      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref3$limit = _ref3.limit,\n          limit = _ref3$limit === void 0 ? 0 : _ref3$limit,\n          _ref3$withPresences = _ref3.withPresences,\n          presences = _ref3$withPresences === void 0 ? false : _ref3$withPresences,\n          user_ids = _ref3.user,\n          query = _ref3.query,\n          _ref3$time = _ref3.time,\n          time = _ref3$time === void 0 ? 120e3 : _ref3$time;\n\n      return new Promise(function (resolve, reject) {\n        if (_this6.guild.memberCount === _this6.cache.size && !query && !limit && !presences && !user_ids) {\n          resolve(_this6.cache);\n          return;\n        }\n\n        if (!query && !user_ids) query = '';\n\n        _this6.guild.shard.send({\n          op: OPCodes.REQUEST_GUILD_MEMBERS,\n          d: {\n            guild_id: _this6.guild.id,\n            presences: presences,\n            user_ids: user_ids,\n            query: query,\n            limit: limit\n          }\n        });\n\n        var fetchedMembers = new Collection();\n        var option = query || limit || presences || user_ids;\n\n        var handler = function handler(members, guild) {\n          if (guild.id !== _this6.guild.id) return;\n          timeout.refresh();\n\n          var _iterator = _createForOfIteratorHelper(members.values()),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var member = _step.value;\n              if (option) fetchedMembers.set(member.id, member);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n\n          if (_this6.guild.memberCount <= _this6.cache.size || option && members.size < 1000 || limit && fetchedMembers.size >= limit) {\n            _this6.guild.client.removeListener(Events.GUILD_MEMBERS_CHUNK, handler);\n\n            var fetched = option ? fetchedMembers : _this6.cache;\n            if (user_ids && !Array.isArray(user_ids) && fetched.size) fetched = fetched.first();\n            resolve(fetched);\n          }\n        };\n\n        var timeout = _this6.guild.client.setTimeout(function () {\n          _this6.guild.client.removeListener(Events.GUILD_MEMBERS_CHUNK, handler);\n\n          reject(new Error('GUILD_MEMBERS_TIMEOUT'));\n        }, time);\n\n        _this6.guild.client.on(Events.GUILD_MEMBERS_CHUNK, handler);\n      });\n    }\n  }]);\n\n  return GuildMemberManager;\n}(BaseManager);\n\nmodule.exports = GuildMemberManager;","map":null,"metadata":{},"sourceType":"module"}