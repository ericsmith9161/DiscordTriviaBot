{"ast":null,"code":"'use strict';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Role = require('./Role');\n\nvar _require = require('../errors'),\n    _TypeError = _require.TypeError;\n\nvar Permissions = require('../util/Permissions');\n\nvar Util = require('../util/Util');\n/**\n * Represents a permission overwrite for a role or member in a guild channel.\n */\n\n\nvar PermissionOverwrites = /*#__PURE__*/function () {\n  function PermissionOverwrites(guildChannel, data) {\n    _classCallCheck(this, PermissionOverwrites);\n\n    /**\n     * The GuildChannel this overwrite is for\n     * @name PermissionOverwrites#channel\n     * @type {GuildChannel}\n     * @readonly\n     */\n    Object.defineProperty(this, 'channel', {\n      value: guildChannel\n    });\n    if (data) this._patch(data);\n  }\n\n  _createClass(PermissionOverwrites, [{\n    key: \"_patch\",\n    value: function _patch(data) {\n      /**\n       * The ID of this overwrite, either a user ID or a role ID\n       * @type {Snowflake}\n       */\n      this.id = data.id;\n      /**\n       * The type of a permission overwrite. It can be one of:\n       * * member\n       * * role\n       * @typedef {string} OverwriteType\n       */\n\n      /**\n       * The type of this overwrite\n       * @type {OverwriteType}\n       */\n\n      this.type = data.type;\n      /**\n       * The permissions that are denied for the user or role.\n       * @type {Readonly<Permissions>}\n       */\n\n      this.deny = new Permissions(data.deny).freeze();\n      /**\n       * The permissions that are allowed for the user or role.\n       * @type {Readonly<Permissions>}\n       */\n\n      this.allow = new Permissions(data.allow).freeze();\n    }\n    /**\n     * Updates this permissionOverwrites.\n     * @param {PermissionOverwriteOptions} options The options for the update\n     * @param {string} [reason] Reason for creating/editing this overwrite\n     * @returns {Promise<PermissionOverwrites>}\n     * @example\n     * // Update permission overwrites\n     * permissionOverwrites.update({\n     *   SEND_MESSAGES: false\n     * })\n     *   .then(channel => console.log(channel.permissionOverwrites.get(message.author.id)))\n     *   .catch(console.error);\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(options, reason) {\n      var _this = this;\n\n      var _this$constructor$res = this.constructor.resolveOverwriteOptions(options, this),\n          allow = _this$constructor$res.allow,\n          deny = _this$constructor$res.deny;\n\n      return this.channel.client.api.channels(this.channel.id).permissions[this.id].put({\n        data: {\n          id: this.id,\n          type: this.type,\n          allow: allow.bitfield,\n          deny: deny.bitfield\n        },\n        reason: reason\n      }).then(function () {\n        return _this;\n      });\n    }\n    /**\n     * Deletes this Permission Overwrite.\n     * @param {string} [reason] Reason for deleting this overwrite\n     * @returns {Promise<PermissionOverwrites>}\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete(reason) {\n      var _this2 = this;\n\n      return this.channel.client.api.channels[this.channel.id].permissions[this.id][\"delete\"]({\n        reason: reason\n      }).then(function () {\n        return _this2;\n      });\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return Util.flatten(this);\n    }\n    /**\n     * An object mapping permission flags to `true` (enabled), `null` (unset) or `false` (disabled).\n     * ```js\n     * {\n     *  'SEND_MESSAGES': true,\n     *  'EMBED_LINKS': null,\n     *  'ATTACH_FILES': false,\n     * }\n     * ```\n     * @typedef {Object} PermissionOverwriteOptions\n     */\n\n    /**\n     * @typedef {object} ResolvedOverwriteOptions\n     * @property {Permissions} allow The allowed permissions\n     * @property {Permissions} deny The denied permissions\n     */\n\n    /**\n     * Resolves bitfield permissions overwrites from an object.\n     * @param {PermissionOverwriteOptions} options The options for the update\n     * @param {Object} initialPermissions The initial permissions\n     * @param {PermissionResolvable} initialPermissions.allow Initial allowed permissions\n     * @param {PermissionResolvable} initialPermissions.deny Initial denied permissions\n     * @returns {ResolvedOverwriteOptions}\n     */\n\n  }], [{\n    key: \"resolveOverwriteOptions\",\n    value: function resolveOverwriteOptions(options) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          allow = _ref.allow,\n          deny = _ref.deny;\n\n      allow = new Permissions(allow);\n      deny = new Permissions(deny);\n\n      for (var _i2 = 0, _Object$entries = Object.entries(options); _i2 < _Object$entries.length; _i2++) {\n        var _ref4 = _Object$entries[_i2];\n\n        var _ref3 = _slicedToArray(_ref4, 2);\n\n        var perm = _ref3[0];\n        var value = _ref3[1];\n\n        if (value === true) {\n          allow.add(Permissions.FLAGS[perm]);\n          deny.remove(Permissions.FLAGS[perm]);\n        } else if (value === false) {\n          allow.remove(Permissions.FLAGS[perm]);\n          deny.add(Permissions.FLAGS[perm]);\n        } else if (value === null) {\n          allow.remove(Permissions.FLAGS[perm]);\n          deny.remove(Permissions.FLAGS[perm]);\n        }\n      }\n\n      return {\n        allow: allow,\n        deny: deny\n      };\n    }\n    /**\n     * The raw data for a permission overwrite\n     * @typedef {Object} RawOverwriteData\n     * @property {Snowflake} id The id of the overwrite\n     * @property {number} allow The permissions to allow\n     * @property {number} deny The permissions to deny\n     * @property {OverwriteType} type The type of this OverwriteData\n     */\n\n    /**\n     * Data that can be resolved into {@link RawOverwriteData}\n     * @typedef {PermissionOverwrites|OverwriteData} OverwriteResolvable\n     */\n\n    /**\n     * Data that can be used for a permission overwrite\n     * @typedef {Object} OverwriteData\n     * @property {GuildMemberResolvable|RoleResolvable} id Member or role this overwrite is for\n     * @property {PermissionResolvable} [allow] The permissions to allow\n     * @property {PermissionResolvable} [deny] The permissions to deny\n     * @property {OverwriteType} [type] The type of this OverwriteData\n     */\n\n    /**\n     * Resolves an overwrite into {@link RawOverwriteData}.\n     * @param {OverwriteResolvable} overwrite The overwrite-like data to resolve\n     * @param {Guild} guild The guild to resolve from\n     * @returns {RawOverwriteData}\n     */\n\n  }, {\n    key: \"resolve\",\n    value: function resolve(overwrite, guild) {\n      if (overwrite instanceof this) return overwrite.toJSON();\n\n      if (typeof overwrite.id === 'string' && ['role', 'member'].includes(overwrite.type)) {\n        return _objectSpread(_objectSpread({}, overwrite), {}, {\n          allow: Permissions.resolve(overwrite.allow),\n          deny: Permissions.resolve(overwrite.deny)\n        });\n      }\n\n      var userOrRole = guild.roles.resolve(overwrite.id) || guild.client.users.resolve(overwrite.id);\n      if (!userOrRole) throw new _TypeError('INVALID_TYPE', 'parameter', 'User nor a Role', true);\n      var type = userOrRole instanceof Role ? 'role' : 'member';\n      return {\n        id: userOrRole.id,\n        type: type,\n        allow: Permissions.resolve(overwrite.allow),\n        deny: Permissions.resolve(overwrite.deny)\n      };\n    }\n  }]);\n\n  return PermissionOverwrites;\n}();\n\nmodule.exports = PermissionOverwrites;","map":null,"metadata":{},"sourceType":"module"}