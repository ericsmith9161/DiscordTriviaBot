{"ast":null,"code":"'use strict';\n/* eslint-disable import/order */\n\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar MessageCollector = require('../MessageCollector');\n\nvar APIMessage = require('../APIMessage');\n\nvar Snowflake = require('../../util/Snowflake');\n\nvar Collection = require('../../util/Collection');\n\nvar _require = require('../../errors'),\n    RangeError = _require.RangeError,\n    _TypeError = _require.TypeError;\n/**\n * Interface for classes that have text-channel-like features.\n * @interface\n */\n\n\nvar TextBasedChannel = /*#__PURE__*/function () {\n  function TextBasedChannel() {\n    _classCallCheck(this, TextBasedChannel);\n\n    /**\n     * A manager of the messages sent to this channel\n     * @type {MessageManager}\n     */\n    this.messages = new MessageManager(this);\n    /**\n     * The ID of the last message in the channel, if one was sent\n     * @type {?Snowflake}\n     */\n\n    this.lastMessageID = null;\n    /**\n     * The timestamp when the last pinned message was pinned, if there was one\n     * @type {?number}\n     */\n\n    this.lastPinTimestamp = null;\n  }\n  /**\n   * The Message object of the last message in the channel, if one was sent\n   * @type {?Message}\n   * @readonly\n   */\n\n\n  _createClass(TextBasedChannel, [{\n    key: \"send\",\n\n    /**\n     * Options provided when sending or editing a message.\n     * @typedef {Object} MessageOptions\n     * @property {boolean} [tts=false] Whether or not the message should be spoken aloud\n     * @property {string} [nonce=''] The nonce for the message\n     * @property {string} [content=''] The content for the message\n     * @property {MessageEmbed|Object} [embed] An embed for the message\n     * (see [here](https://discordapp.com/developers/docs/resources/channel#embed-object) for more details)\n     * @property {MessageMentionOptions} [allowedMentions] Which mentions should be parsed from the message content\n     * @property {DisableMentionType} [disableMentions=this.client.options.disableMentions] Whether or not all mentions or\n     * everyone/here mentions should be sanitized to prevent unexpected mentions\n     * @property {FileOptions[]|BufferResolvable[]} [files] Files to send with the message\n     * @property {string|boolean} [code] Language for optional codeblock formatting to apply\n     * @property {boolean|SplitOptions} [split=false] Whether or not the message should be split into multiple messages if\n     * it exceeds the character limit. If an object is provided, these are the options for splitting the message\n     * @property {UserResolvable} [reply] User to reply to (prefixes the message with a mention, except in DMs)\n     */\n\n    /**\n     * Options provided to control parsing of mentions by Discord\n     * @typedef {Object} MessageMentionOptions\n     * @property {MessageMentionTypes[]} [parse] Types of mentions to be parsed\n     * @property {Snowflake[]} [users] Snowflakes of Users to be parsed as mentions\n     * @property {Snowflake[]} [roles] Snowflakes of Roles to be parsed as mentions\n     */\n\n    /**\n     * Types of mentions to enable in MessageMentionOptions.\n     * - `roles`\n     * - `users`\n     * - `everyone`\n     * @typedef {string} MessageMentionTypes\n     */\n\n    /**\n     * The type of mentions to disable.\n     * - `none`\n     * - `all`\n     * - `everyone`\n     * @typedef {string} DisableMentionType\n     */\n\n    /**\n     * @typedef {Object} FileOptions\n     * @property {BufferResolvable} attachment File to attach\n     * @property {string} [name='file.jpg'] Filename of the attachment\n     */\n\n    /**\n     * Options for splitting a message.\n     * @typedef {Object} SplitOptions\n     * @property {number} [maxLength=2000] Maximum character length per message piece\n     * @property {string} [char='\\n'] Character to split the message with\n     * @property {string} [prepend=''] Text to prepend to every piece except the first\n     * @property {string} [append=''] Text to append to every piece except the last\n     */\n\n    /**\n     * Sends a message to this channel.\n     * @param {StringResolvable|APIMessage} [content=''] The content to send\n     * @param {MessageOptions|MessageAdditions} [options={}] The options to provide\n     * @returns {Promise<Message|Message[]>}\n     * @example\n     * // Send a basic message\n     * channel.send('hello!')\n     *   .then(message => console.log(`Sent message: ${message.content}`))\n     *   .catch(console.error);\n     * @example\n     * // Send a remote file\n     * channel.send({\n     *   files: ['https://cdn.discordapp.com/icons/222078108977594368/6e1019b3179d71046e463a75915e7244.png?size=2048']\n     * })\n     *   .then(console.log)\n     *   .catch(console.error);\n     * @example\n     * // Send a local file\n     * channel.send({\n     *   files: [{\n     *     attachment: 'entire/path/to/file.jpg',\n     *     name: 'file.jpg'\n     *   }]\n     * })\n     *   .then(console.log)\n     *   .catch(console.error);\n     * @example\n     * // Send an embed with a local image inside\n     * channel.send('This is an embed', {\n     *   embed: {\n     *     thumbnail: {\n     *          url: 'attachment://file.jpg'\n     *       }\n     *    },\n     *    files: [{\n     *       attachment: 'entire/path/to/file.jpg',\n     *       name: 'file.jpg'\n     *    }]\n     * })\n     *   .then(console.log)\n     *   .catch(console.error);\n     */\n    value: function () {\n      var _send = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(content, options) {\n        var _this = this;\n\n        var User, GuildMember, apiMessage, _yield$apiMessage$res, data, files;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                User = require('../User');\n                GuildMember = require('../GuildMember');\n\n                if (!(this instanceof User || this instanceof GuildMember)) {\n                  _context.next = 4;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", this.createDM().then(function (dm) {\n                  return dm.send(content, options);\n                }));\n\n              case 4:\n                if (!(content instanceof APIMessage)) {\n                  _context.next = 8;\n                  break;\n                }\n\n                apiMessage = content.resolveData();\n                _context.next = 11;\n                break;\n\n              case 8:\n                apiMessage = APIMessage.create(this, content, options).resolveData();\n\n                if (!Array.isArray(apiMessage.data.content)) {\n                  _context.next = 11;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", Promise.all(apiMessage.split().map(this.send.bind(this))));\n\n              case 11:\n                _context.next = 13;\n                return apiMessage.resolveFiles();\n\n              case 13:\n                _yield$apiMessage$res = _context.sent;\n                data = _yield$apiMessage$res.data;\n                files = _yield$apiMessage$res.files;\n                return _context.abrupt(\"return\", this.client.api.channels[this.id].messages.post({\n                  data: data,\n                  files: files\n                }).then(function (d) {\n                  return _this.client.actions.MessageCreate.handle(d).message;\n                }));\n\n              case 17:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function send(_x, _x2) {\n        return _send.apply(this, arguments);\n      }\n\n      return send;\n    }()\n    /**\n     * Starts a typing indicator in the channel.\n     * @param {number} [count=1] The number of times startTyping should be considered to have been called\n     * @returns {Promise} Resolves once the bot stops typing gracefully, or rejects when an error occurs\n     * @example\n     * // Start typing in a channel, or increase the typing count by one\n     * channel.startTyping();\n     * @example\n     * // Start typing in a channel with a typing count of five, or set it to five\n     * channel.startTyping(5);\n     */\n\n  }, {\n    key: \"startTyping\",\n    value: function startTyping(count) {\n      var _this2 = this;\n\n      if (typeof count !== 'undefined' && count < 1) throw new RangeError('TYPING_COUNT');\n\n      if (this.client.user._typing.has(this.id)) {\n        var _entry = this.client.user._typing.get(this.id);\n\n        _entry.count = count || _entry.count + 1;\n        return _entry.promise;\n      }\n\n      var entry = {};\n      entry.promise = new Promise(function (resolve, reject) {\n        var endpoint = _this2.client.api.channels[_this2.id].typing;\n        Object.assign(entry, {\n          count: count || 1,\n          interval: _this2.client.setInterval(function () {\n            endpoint.post()[\"catch\"](function (error) {\n              _this2.client.clearInterval(entry.interval);\n\n              _this2.client.user._typing[\"delete\"](_this2.id);\n\n              reject(error);\n            });\n          }, 9000),\n          resolve: resolve\n        });\n        endpoint.post()[\"catch\"](function (error) {\n          _this2.client.clearInterval(entry.interval);\n\n          _this2.client.user._typing[\"delete\"](_this2.id);\n\n          reject(error);\n        });\n\n        _this2.client.user._typing.set(_this2.id, entry);\n      });\n      return entry.promise;\n    }\n    /**\n     * Stops the typing indicator in the channel.\n     * The indicator will only stop if this is called as many times as startTyping().\n     * <info>It can take a few seconds for the client user to stop typing.</info>\n     * @param {boolean} [force=false] Whether or not to reset the call count and force the indicator to stop\n     * @example\n     * // Reduce the typing count by one and stop typing if it reached 0\n     * channel.stopTyping();\n     * @example\n     * // Force typing to fully stop regardless of typing count\n     * channel.stopTyping(true);\n     */\n\n  }, {\n    key: \"stopTyping\",\n    value: function stopTyping() {\n      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (this.client.user._typing.has(this.id)) {\n        var entry = this.client.user._typing.get(this.id);\n\n        entry.count--;\n\n        if (entry.count <= 0 || force) {\n          this.client.clearInterval(entry.interval);\n\n          this.client.user._typing[\"delete\"](this.id);\n\n          entry.resolve();\n        }\n      }\n    }\n    /**\n     * Whether or not the typing indicator is being shown in the channel\n     * @type {boolean}\n     * @readonly\n     */\n\n  }, {\n    key: \"createMessageCollector\",\n\n    /**\n     * Creates a Message Collector.\n     * @param {CollectorFilter} filter The filter to create the collector with\n     * @param {MessageCollectorOptions} [options={}] The options to pass to the collector\n     * @returns {MessageCollector}\n     * @example\n     * // Create a message collector\n     * const filter = m => m.content.includes('discord');\n     * const collector = channel.createMessageCollector(filter, { time: 15000 });\n     * collector.on('collect', m => console.log(`Collected ${m.content}`));\n     * collector.on('end', collected => console.log(`Collected ${collected.size} items`));\n     */\n    value: function createMessageCollector(filter) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return new MessageCollector(this, filter, options);\n    }\n    /**\n     * An object containing the same properties as CollectorOptions, but a few more:\n     * @typedef {MessageCollectorOptions} AwaitMessagesOptions\n     * @property {string[]} [errors] Stop/end reasons that cause the promise to reject\n     */\n\n    /**\n     * Similar to createMessageCollector but in promise form.\n     * Resolves with a collection of messages that pass the specified filter.\n     * @param {CollectorFilter} filter The filter function to use\n     * @param {AwaitMessagesOptions} [options={}] Optional options to pass to the internal collector\n     * @returns {Promise<Collection<Snowflake, Message>>}\n     * @example\n     * // Await !vote messages\n     * const filter = m => m.content.startsWith('!vote');\n     * // Errors: ['time'] treats ending because of the time limit as an error\n     * channel.awaitMessages(filter, { max: 4, time: 60000, errors: ['time'] })\n     *   .then(collected => console.log(collected.size))\n     *   .catch(collected => console.log(`After a minute, only ${collected.size} out of 4 voted.`));\n     */\n\n  }, {\n    key: \"awaitMessages\",\n    value: function awaitMessages(filter) {\n      var _this3 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return new Promise(function (resolve, reject) {\n        var collector = _this3.createMessageCollector(filter, options);\n\n        collector.once('end', function (collection, reason) {\n          if (options.errors && options.errors.includes(reason)) {\n            reject(collection);\n          } else {\n            resolve(collection);\n          }\n        });\n      });\n    }\n    /**\n     * Bulk deletes given messages that are newer than two weeks.\n     * @param {Collection<Snowflake, Message>|Message[]|Snowflake[]|number} messages\n     * Messages or number of messages to delete\n     * @param {boolean} [filterOld=false] Filter messages to remove those which are older than two weeks automatically\n     * @returns {Promise<Collection<Snowflake, Message>>} Deleted messages\n     * @example\n     * // Bulk delete messages\n     * channel.bulkDelete(5)\n     *   .then(messages => console.log(`Bulk deleted ${messages.size} messages`))\n     *   .catch(console.error);\n     */\n\n  }, {\n    key: \"bulkDelete\",\n    value: function () {\n      var _bulkDelete = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(messages) {\n        var _this4 = this;\n\n        var filterOld,\n            messageIDs,\n            message,\n            msgs,\n            _args2 = arguments;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                filterOld = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : false;\n\n                if (!(Array.isArray(messages) || messages instanceof Collection)) {\n                  _context2.next = 14;\n                  break;\n                }\n\n                messageIDs = messages instanceof Collection ? messages.keyArray() : messages.map(function (m) {\n                  return m.id || m;\n                });\n\n                if (filterOld) {\n                  messageIDs = messageIDs.filter(function (id) {\n                    return Date.now() - Snowflake.deconstruct(id).date.getTime() < 1209600000;\n                  });\n                }\n\n                if (!(messageIDs.length === 0)) {\n                  _context2.next = 6;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", new Collection());\n\n              case 6:\n                if (!(messageIDs.length === 1)) {\n                  _context2.next = 11;\n                  break;\n                }\n\n                _context2.next = 9;\n                return this.client.api.channels(this.id).messages(messageIDs[0])[\"delete\"]();\n\n              case 9:\n                message = this.client.actions.MessageDelete.getMessage({\n                  message_id: messageIDs[0]\n                }, this);\n                return _context2.abrupt(\"return\", message ? new Collection([[message.id, message]]) : new Collection());\n\n              case 11:\n                _context2.next = 13;\n                return this.client.api.channels[this.id].messages['bulk-delete'].post({\n                  data: {\n                    messages: messageIDs\n                  }\n                });\n\n              case 13:\n                return _context2.abrupt(\"return\", messageIDs.reduce(function (col, id) {\n                  return col.set(id, _this4.client.actions.MessageDeleteBulk.getMessage({\n                    message_id: id\n                  }, _this4));\n                }, new Collection()));\n\n              case 14:\n                if (isNaN(messages)) {\n                  _context2.next = 19;\n                  break;\n                }\n\n                _context2.next = 17;\n                return this.messages.fetch({\n                  limit: messages\n                });\n\n              case 17:\n                msgs = _context2.sent;\n                return _context2.abrupt(\"return\", this.bulkDelete(msgs, filterOld));\n\n              case 19:\n                throw new _TypeError('MESSAGE_BULK_DELETE_TYPE');\n\n              case 20:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function bulkDelete(_x3) {\n        return _bulkDelete.apply(this, arguments);\n      }\n\n      return bulkDelete;\n    }()\n  }, {\n    key: \"lastMessage\",\n    get: function get() {\n      return this.messages.cache.get(this.lastMessageID) || null;\n    }\n    /**\n     * The date when the last pinned message was pinned, if there was one\n     * @type {?Date}\n     * @readonly\n     */\n\n  }, {\n    key: \"lastPinAt\",\n    get: function get() {\n      return this.lastPinTimestamp ? new Date(this.lastPinTimestamp) : null;\n    }\n  }, {\n    key: \"typing\",\n    get: function get() {\n      return this.client.user._typing.has(this.id);\n    }\n    /**\n     * Number of times `startTyping` has been called\n     * @type {number}\n     * @readonly\n     */\n\n  }, {\n    key: \"typingCount\",\n    get: function get() {\n      if (this.client.user._typing.has(this.id)) return this.client.user._typing.get(this.id).count;\n      return 0;\n    }\n  }], [{\n    key: \"applyToClass\",\n    value: function applyToClass(structure) {\n      var full = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var ignore = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      var props = ['send'];\n\n      if (full) {\n        props.push('lastMessage', 'lastPinAt', 'bulkDelete', 'startTyping', 'stopTyping', 'typing', 'typingCount', 'createMessageCollector', 'awaitMessages');\n      }\n\n      for (var _i = 0, _props = props; _i < _props.length; _i++) {\n        var prop = _props[_i];\n        if (ignore.includes(prop)) continue;\n        Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(TextBasedChannel.prototype, prop));\n      }\n    }\n  }]);\n\n  return TextBasedChannel;\n}();\n\nmodule.exports = TextBasedChannel; // Fixes Circular\n\nvar MessageManager = require('../../managers/MessageManager');","map":null,"metadata":{},"sourceType":"module"}