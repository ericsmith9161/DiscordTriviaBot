{"ast":null,"code":"'use strict';\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _createForOfIteratorHelper(o) { if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar APIMessage = require('./APIMessage');\n\nvar Base = require('./Base');\n\nvar ClientApplication = require('./ClientApplication');\n\nvar MessageAttachment = require('./MessageAttachment');\n\nvar Embed = require('./MessageEmbed');\n\nvar Mentions = require('./MessageMentions');\n\nvar ReactionCollector = require('./ReactionCollector');\n\nvar _require = require('../errors'),\n    Error = _require.Error,\n    _TypeError = _require.TypeError;\n\nvar ReactionManager = require('../managers/ReactionManager');\n\nvar Collection = require('../util/Collection');\n\nvar _require2 = require('../util/Constants'),\n    MessageTypes = _require2.MessageTypes;\n\nvar MessageFlags = require('../util/MessageFlags');\n\nvar Permissions = require('../util/Permissions');\n\nvar Util = require('../util/Util');\n/**\n * Represents a message on Discord.\n * @extends {Base}\n */\n\n\nvar Message = /*#__PURE__*/function (_Base) {\n  _inherits(Message, _Base);\n\n  var _super = _createSuper(Message);\n\n  /**\n   * @param {Client} client The instantiating client\n   * @param {Object} data The data for the message\n   * @param {TextChannel|DMChannel} channel The channel the message was sent in\n   */\n  function Message(client, data, channel) {\n    var _this;\n\n    _classCallCheck(this, Message);\n\n    _this = _super.call(this, client);\n    /**\n     * The channel that the message was sent in\n     * @type {TextChannel|DMChannel}\n     */\n\n    _this.channel = channel;\n    /**\n     * Whether this message has been deleted\n     * @type {boolean}\n     */\n\n    _this.deleted = false;\n    if (data) _this._patch(data);\n    return _this;\n  }\n\n  _createClass(Message, [{\n    key: \"_patch\",\n    value: function _patch(data) {\n      /**\n       * The ID of the message\n       * @type {Snowflake}\n       */\n      this.id = data.id;\n      /**\n       * The type of the message\n       * @type {MessageType}\n       */\n\n      this.type = MessageTypes[data.type];\n      /**\n       * The content of the message\n       * @type {string}\n       */\n\n      this.content = data.content;\n      /**\n       * The author of the message\n       * @type {?User}\n       */\n\n      this.author = data.author ? this.client.users.add(data.author, !data.webhook_id) : null;\n      /**\n       * Whether or not this message is pinned\n       * @type {boolean}\n       */\n\n      this.pinned = data.pinned;\n      /**\n       * Whether or not the message was Text-To-Speech\n       * @type {boolean}\n       */\n\n      this.tts = data.tts;\n      /**\n       * A random number or string used for checking message delivery\n       * <warn>This is only received after the message was sent successfully, and\n       * lost if re-fetched</warn>\n       * @type {?string}\n       */\n\n      this.nonce = data.nonce;\n      /**\n       * Whether or not this message was sent by Discord, not actually a user (e.g. pin notifications)\n       * @type {boolean}\n       */\n\n      this.system = data.type !== 0;\n      /**\n       * A list of embeds in the message - e.g. YouTube Player\n       * @type {MessageEmbed[]}\n       */\n\n      this.embeds = (data.embeds || []).map(function (e) {\n        return new Embed(e, true);\n      });\n      /**\n       * A collection of attachments in the message - e.g. Pictures - mapped by their ID\n       * @type {Collection<Snowflake, MessageAttachment>}\n       */\n\n      this.attachments = new Collection();\n\n      if (data.attachments) {\n        var _iterator = _createForOfIteratorHelper(data.attachments),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var attachment = _step.value;\n            this.attachments.set(attachment.id, new MessageAttachment(attachment.url, attachment.filename, attachment));\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n      /**\n       * The timestamp the message was sent at\n       * @type {number}\n       */\n\n\n      this.createdTimestamp = new Date(data.timestamp).getTime();\n      /**\n       * The timestamp the message was last edited at (if applicable)\n       * @type {?number}\n       */\n\n      this.editedTimestamp = data.edited_timestamp ? new Date(data.edited_timestamp).getTime() : null;\n      /**\n       * A manager of the reactions belonging to this message\n       * @type {ReactionManager}\n       */\n\n      this.reactions = new ReactionManager(this);\n\n      if (data.reactions && data.reactions.length > 0) {\n        var _iterator2 = _createForOfIteratorHelper(data.reactions),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var reaction = _step2.value;\n            this.reactions.add(reaction);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n      /**\n       * All valid mentions that the message contains\n       * @type {MessageMentions}\n       */\n\n\n      this.mentions = new Mentions(this, data.mentions, data.mention_roles, data.mention_everyone, data.mention_channels);\n      /**\n       * ID of the webhook that sent the message, if applicable\n       * @type {?Snowflake}\n       */\n\n      this.webhookID = data.webhook_id || null;\n      /**\n       * Supplemental application information for group activities\n       * @type {?ClientApplication}\n       */\n\n      this.application = data.application ? new ClientApplication(this.client, data.application) : null;\n      /**\n       * Group activity\n       * @type {?MessageActivity}\n       */\n\n      this.activity = data.activity ? {\n        partyID: data.activity.party_id,\n        type: data.activity.type\n      } : null;\n      /**\n       * The previous versions of the message, sorted with the most recent first\n       * @type {Message[]}\n       * @private\n       */\n\n      this._edits = [];\n\n      if (this.member && data.member) {\n        this.member._patch(data.member);\n      } else if (data.member && this.guild && this.author) {\n        this.guild.members.add(Object.assign(data.member, {\n          user: this.author\n        }));\n      }\n      /**\n       * Flags that are applied to the message\n       * @type {Readonly<MessageFlags>}\n       */\n\n\n      this.flags = new MessageFlags(data.flags).freeze();\n      /**\n       * Reference data sent in a crossposted message.\n       * @typedef {Object} MessageReference\n       * @property {string} channelID ID of the channel the message was crossposted from\n       * @property {?string} guildID ID of the guild the message was crossposted from\n       * @property {?string} messageID ID of the message that was crossposted\n       */\n\n      /**\n       * Message reference data\n       * @type {?MessageReference}\n       */\n\n      this.reference = data.message_reference ? {\n        channelID: data.message_reference.channel_id,\n        guildID: data.message_reference.guild_id,\n        messageID: data.message_reference.message_id\n      } : null;\n    }\n    /**\n     * Whether or not this message is a partial\n     * @type {boolean}\n     * @readonly\n     */\n\n  }, {\n    key: \"patch\",\n\n    /**\n     * Updates the message.\n     * @param {Object} data Raw Discord message update data\n     * @private\n     */\n    value: function patch(data) {\n      var clone = this._clone();\n\n      this._edits.unshift(clone);\n\n      if ('edited_timestamp' in data) this.editedTimestamp = new Date(data.edited_timestamp).getTime();\n      if ('content' in data) this.content = data.content;\n      if ('pinned' in data) this.pinned = data.pinned;\n      if ('tts' in data) this.tts = data.tts;\n      if ('embeds' in data) this.embeds = data.embeds.map(function (e) {\n        return new Embed(e, true);\n      });else this.embeds = this.embeds.slice();\n\n      if ('attachments' in data) {\n        this.attachments = new Collection();\n\n        var _iterator3 = _createForOfIteratorHelper(data.attachments),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var attachment = _step3.value;\n            this.attachments.set(attachment.id, new MessageAttachment(attachment.url, attachment.filename, attachment));\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      } else {\n        this.attachments = new Collection(this.attachments);\n      }\n\n      this.mentions = new Mentions(this, 'mentions' in data ? data.mentions : this.mentions.users, 'mention_roles' in data ? data.mention_roles : this.mentions.roles, 'mention_everyone' in data ? data.mention_everyone : this.mentions.everyone, 'mention_channels' in data ? data.mention_channels : this.mentions.crosspostedChannels);\n      this.flags = new MessageFlags('flags' in data ? data.flags : 0).freeze();\n    }\n    /**\n     * Represents the author of the message as a guild member.\n     * Only available if the message comes from a guild where the author is still a member\n     * @type {?GuildMember}\n     * @readonly\n     */\n\n  }, {\n    key: \"createReactionCollector\",\n\n    /**\n     * Creates a reaction collector.\n     * @param {CollectorFilter} filter The filter to apply\n     * @param {ReactionCollectorOptions} [options={}] Options to send to the collector\n     * @returns {ReactionCollector}\n     * @example\n     * // Create a reaction collector\n     * const filter = (reaction, user) => reaction.emoji.name === '👌' && user.id === 'someID';\n     * const collector = message.createReactionCollector(filter, { time: 15000 });\n     * collector.on('collect', r => console.log(`Collected ${r.emoji.name}`));\n     * collector.on('end', collected => console.log(`Collected ${collected.size} items`));\n     */\n    value: function createReactionCollector(filter) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return new ReactionCollector(this, filter, options);\n    }\n    /**\n     * An object containing the same properties as CollectorOptions, but a few more:\n     * @typedef {ReactionCollectorOptions} AwaitReactionsOptions\n     * @property {string[]} [errors] Stop/end reasons that cause the promise to reject\n     */\n\n    /**\n     * Similar to createReactionCollector but in promise form.\n     * Resolves with a collection of reactions that pass the specified filter.\n     * @param {CollectorFilter} filter The filter function to use\n     * @param {AwaitReactionsOptions} [options={}] Optional options to pass to the internal collector\n     * @returns {Promise<Collection<string, MessageReaction>>}\n     * @example\n     * // Create a reaction collector\n     * const filter = (reaction, user) => reaction.emoji.name === '👌' && user.id === 'someID'\n     * message.awaitReactions(filter, { time: 15000 })\n     *   .then(collected => console.log(`Collected ${collected.size} reactions`))\n     *   .catch(console.error);\n     */\n\n  }, {\n    key: \"awaitReactions\",\n    value: function awaitReactions(filter) {\n      var _this2 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return new Promise(function (resolve, reject) {\n        var collector = _this2.createReactionCollector(filter, options);\n\n        collector.once('end', function (reactions, reason) {\n          if (options.errors && options.errors.includes(reason)) reject(reactions);else resolve(reactions);\n        });\n      });\n    }\n    /**\n     * An array of cached versions of the message, including the current version\n     * Sorted from latest (first) to oldest (last)\n     * @type {Message[]}\n     * @readonly\n     */\n\n  }, {\n    key: \"edit\",\n\n    /**\n     * Options that can be passed into editMessage.\n     * @typedef {Object} MessageEditOptions\n     * @property {string} [content] Content to be edited\n     * @property {Object} [embed] An embed to be added/edited\n     * @property {string|boolean} [code] Language for optional codeblock formatting to apply\n     * @property {MessageMentionOptions} [allowedMentions] Which mentions should be parsed from the message content\n     */\n\n    /**\n     * Edits the content of the message.\n     * @param {StringResolvable|APIMessage} [content] The new content for the message\n     * @param {MessageEditOptions|MessageEmbed} [options] The options to provide\n     * @returns {Promise<Message>}\n     * @example\n     * // Update the content of a message\n     * message.edit('This is my new content!')\n     *   .then(msg => console.log(`Updated the content of a message to ${msg.content}`))\n     *   .catch(console.error);\n     */\n    value: function edit(content, options) {\n      var _this3 = this;\n\n      var _ref = content instanceof APIMessage ? content.resolveData() : APIMessage.create(this, content, options).resolveData(),\n          data = _ref.data;\n\n      return this.client.api.channels[this.channel.id].messages[this.id].patch({\n        data: data\n      }).then(function (d) {\n        var clone = _this3._clone();\n\n        clone._patch(d);\n\n        return clone;\n      });\n    }\n    /**\n     * Pins this message to the channel's pinned messages.\n     * @returns {Promise<Message>}\n     */\n\n  }, {\n    key: \"pin\",\n    value: function pin() {\n      var _this4 = this;\n\n      return this.client.api.channels(this.channel.id).pins(this.id).put().then(function () {\n        return _this4;\n      });\n    }\n    /**\n     * Unpins this message from the channel's pinned messages.\n     * @returns {Promise<Message>}\n     */\n\n  }, {\n    key: \"unpin\",\n    value: function unpin() {\n      var _this5 = this;\n\n      return this.client.api.channels(this.channel.id).pins(this.id)[\"delete\"]().then(function () {\n        return _this5;\n      });\n    }\n    /**\n     * Adds a reaction to the message.\n     * @param {EmojiIdentifierResolvable} emoji The emoji to react with\n     * @returns {Promise<MessageReaction>}\n     * @example\n     * // React to a message with a unicode emoji\n     * message.react('🤔')\n     *   .then(console.log)\n     *   .catch(console.error);\n     * @example\n     * // React to a message with a custom emoji\n     * message.react(message.guild.emojis.cache.get('123456789012345678'))\n     *   .then(console.log)\n     *   .catch(console.error);\n     */\n\n  }, {\n    key: \"react\",\n    value: function react(emoji) {\n      var _this6 = this;\n\n      emoji = this.client.emojis.resolveIdentifier(emoji);\n      if (!emoji) throw new _TypeError('EMOJI_TYPE');\n      return this.client.api.channels(this.channel.id).messages(this.id).reactions(emoji, '@me').put().then(function () {\n        return _this6.client.actions.MessageReactionAdd.handle({\n          user: _this6.client.user,\n          channel: _this6.channel,\n          message: _this6,\n          emoji: Util.parseEmoji(emoji)\n        }).reaction;\n      });\n    }\n    /**\n     * Deletes the message.\n     * @param {Object} [options] Options\n     * @param {number} [options.timeout=0] How long to wait to delete the message in milliseconds\n     * @param {string} [options.reason] Reason for deleting this message, if it does not belong to the client user\n     * @returns {Promise<Message>}\n     * @example\n     * // Delete a message\n     * message.delete()\n     *   .then(msg => console.log(`Deleted message from ${msg.author.username}`))\n     *   .catch(console.error);\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      var _this7 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      if (_typeof(options) !== 'object') throw new _TypeError('INVALID_TYPE', 'options', 'object', true);\n      var _options$timeout = options.timeout,\n          timeout = _options$timeout === void 0 ? 0 : _options$timeout,\n          reason = options.reason;\n\n      if (timeout <= 0) {\n        return this.channel.messages[\"delete\"](this.id, reason).then(function () {\n          return _this7;\n        });\n      } else {\n        return new Promise(function (resolve) {\n          _this7.client.setTimeout(function () {\n            resolve(_this7[\"delete\"]({\n              reason: reason\n            }));\n          }, timeout);\n        });\n      }\n    }\n    /**\n     * Replies to the message.\n     * @param {StringResolvable|APIMessage} [content=''] The content for the message\n     * @param {MessageOptions|MessageAdditions} [options={}] The options to provide\n     * @returns {Promise<Message|Message[]>}\n     * @example\n     * // Reply to a message\n     * message.reply('Hey, I\\'m a reply!')\n     *   .then(() => console.log(`Sent a reply to ${message.author.username}`))\n     *   .catch(console.error);\n     */\n\n  }, {\n    key: \"reply\",\n    value: function reply(content, options) {\n      return this.channel.send(content instanceof APIMessage ? content : APIMessage.transformOptions(content, options, {\n        reply: this.member || this.author\n      }));\n    }\n    /**\n     * Fetch this message.\n     * @returns {Promise<Message>}\n     */\n\n  }, {\n    key: \"fetch\",\n    value: function fetch() {\n      return this.channel.messages.fetch(this.id, true);\n    }\n    /**\n     * Fetches the webhook used to create this message.\n     * @returns {Promise<?Webhook>}\n     */\n\n  }, {\n    key: \"fetchWebhook\",\n    value: function fetchWebhook() {\n      if (!this.webhookID) return Promise.reject(new Error('WEBHOOK_MESSAGE'));\n      return this.client.fetchWebhook(this.webhookID);\n    }\n    /**\n     * Suppresses or unsuppresses embeds on a message\n     * @param {boolean} [suppress=true] If the embeds should be suppressed or not\n     * @returns {Promise<Message>}\n     */\n\n  }, {\n    key: \"suppressEmbeds\",\n    value: function suppressEmbeds() {\n      var suppress = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var flags = new MessageFlags(this.flags.bitfield);\n\n      if (suppress) {\n        flags.add(MessageFlags.FLAGS.SUPPRESS_EMBEDS);\n      } else {\n        flags.remove(MessageFlags.FLAGS.SUPPRESS_EMBEDS);\n      }\n\n      return this.edit({\n        flags: flags\n      });\n    }\n    /**\n     * Used mainly internally. Whether two messages are identical in properties. If you want to compare messages\n     * without checking all the properties, use `message.id === message2.id`, which is much more efficient. This\n     * method allows you to see if there are differences in content, embeds, attachments, nonce and tts properties.\n     * @param {Message} message The message to compare it to\n     * @param {Object} rawData Raw data passed through the WebSocket about this message\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"equals\",\n    value: function equals(message, rawData) {\n      if (!message) return false;\n      var embedUpdate = !message.author && !message.attachments;\n      if (embedUpdate) return this.id === message.id && this.embeds.length === message.embeds.length;\n      var equal = this.id === message.id && this.author.id === message.author.id && this.content === message.content && this.tts === message.tts && this.nonce === message.nonce && this.embeds.length === message.embeds.length && this.attachments.length === message.attachments.length;\n\n      if (equal && rawData) {\n        equal = this.mentions.everyone === message.mentions.everyone && this.createdTimestamp === new Date(rawData.timestamp).getTime() && this.editedTimestamp === new Date(rawData.edited_timestamp).getTime();\n      }\n\n      return equal;\n    }\n    /**\n     * When concatenated with a string, this automatically concatenates the message's content instead of the object.\n     * @returns {string}\n     * @example\n     * // Logs: Message: This is a message!\n     * console.log(`Message: ${message}`);\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.content;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return _get(_getPrototypeOf(Message.prototype), \"toJSON\", this).call(this, {\n        channel: 'channelID',\n        author: 'authorID',\n        application: 'applicationID',\n        guild: 'guildID',\n        cleanContent: true,\n        member: false,\n        reactions: false\n      });\n    }\n  }, {\n    key: \"partial\",\n    get: function get() {\n      return typeof this.content !== 'string' || !this.author;\n    }\n  }, {\n    key: \"member\",\n    get: function get() {\n      return this.guild ? this.guild.member(this.author) || null : null;\n    }\n    /**\n     * The time the message was sent at\n     * @type {Date}\n     * @readonly\n     */\n\n  }, {\n    key: \"createdAt\",\n    get: function get() {\n      return new Date(this.createdTimestamp);\n    }\n    /**\n     * The time the message was last edited at (if applicable)\n     * @type {?Date}\n     * @readonly\n     */\n\n  }, {\n    key: \"editedAt\",\n    get: function get() {\n      return this.editedTimestamp ? new Date(this.editedTimestamp) : null;\n    }\n    /**\n     * The guild the message was sent in (if in a guild channel)\n     * @type {?Guild}\n     * @readonly\n     */\n\n  }, {\n    key: \"guild\",\n    get: function get() {\n      return this.channel.guild || null;\n    }\n    /**\n     * The url to jump to this message\n     * @type {string}\n     * @readonly\n     */\n\n  }, {\n    key: \"url\",\n    get: function get() {\n      return \"https://discordapp.com/channels/\".concat(this.guild ? this.guild.id : '@me', \"/\").concat(this.channel.id, \"/\").concat(this.id);\n    }\n    /**\n     * The message contents with all mentions replaced by the equivalent text.\n     * If mentions cannot be resolved to a name, the relevant mention in the message content will not be converted.\n     * @type {string}\n     * @readonly\n     */\n\n  }, {\n    key: \"cleanContent\",\n    get: function get() {\n      // eslint-disable-next-line eqeqeq\n      return this.content != null ? Util.cleanContent(this.content, this) : null;\n    }\n  }, {\n    key: \"edits\",\n    get: function get() {\n      var copy = this._edits.slice();\n\n      copy.unshift(this);\n      return copy;\n    }\n    /**\n     * Whether the message is editable by the client user\n     * @type {boolean}\n     * @readonly\n     */\n\n  }, {\n    key: \"editable\",\n    get: function get() {\n      return this.author.id === this.client.user.id;\n    }\n    /**\n     * Whether the message is deletable by the client user\n     * @type {boolean}\n     * @readonly\n     */\n\n  }, {\n    key: \"deletable\",\n    get: function get() {\n      return !this.deleted && (this.author.id === this.client.user.id || this.guild && this.channel.permissionsFor(this.client.user).has(Permissions.FLAGS.MANAGE_MESSAGES, false));\n    }\n    /**\n     * Whether the message is pinnable by the client user\n     * @type {boolean}\n     * @readonly\n     */\n\n  }, {\n    key: \"pinnable\",\n    get: function get() {\n      return this.type === 'DEFAULT' && (!this.guild || this.channel.permissionsFor(this.client.user).has(Permissions.FLAGS.MANAGE_MESSAGES, false));\n    }\n  }]);\n\n  return Message;\n}(Base);\n\nmodule.exports = Message;","map":null,"metadata":{},"sourceType":"module"}