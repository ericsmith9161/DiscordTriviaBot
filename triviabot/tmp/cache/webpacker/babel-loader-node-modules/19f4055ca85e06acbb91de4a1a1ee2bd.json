{"ast":null,"code":"'use strict';\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar _require = require('./DJSError'),\n    register = _require.register;\n\nvar Messages = {\n  CLIENT_INVALID_OPTION: function CLIENT_INVALID_OPTION(prop, must) {\n    return \"The \".concat(prop, \" option must be \").concat(must);\n  },\n  CLIENT_INVALID_PROVIDED_SHARDS: 'None of the provided shards were valid.',\n  TOKEN_INVALID: 'An invalid token was provided.',\n  TOKEN_MISSING: 'Request to use token, but token was unavailable to the client.',\n  WS_CLOSE_REQUESTED: 'WebSocket closed due to user request.',\n  WS_CONNECTION_EXISTS: 'There is already an existing WebSocket connection.',\n  WS_NOT_OPEN: function WS_NOT_OPEN() {\n    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'data';\n    return \"Websocket not open to send \".concat(data);\n  },\n  BITFIELD_INVALID: 'Invalid bitfield flag or number.',\n  SHARDING_INVALID: 'Invalid shard settings were provided.',\n  SHARDING_REQUIRED: 'This session would have handled too many guilds - Sharding is required.',\n  INVALID_INTENTS: 'Invalid intent provided for WebSocket intents.',\n  DISALLOWED_INTENTS: 'Privileged intent provided is not enabled or whitelisted.',\n  SHARDING_NO_SHARDS: 'No shards have been spawned.',\n  SHARDING_IN_PROCESS: 'Shards are still being spawned.',\n  SHARDING_ALREADY_SPAWNED: function SHARDING_ALREADY_SPAWNED(count) {\n    return \"Already spawned \".concat(count, \" shards.\");\n  },\n  SHARDING_PROCESS_EXISTS: function SHARDING_PROCESS_EXISTS(id) {\n    return \"Shard \".concat(id, \" already has an active process.\");\n  },\n  SHARDING_READY_TIMEOUT: function SHARDING_READY_TIMEOUT(id) {\n    return \"Shard \".concat(id, \"'s Client took too long to become ready.\");\n  },\n  SHARDING_READY_DISCONNECTED: function SHARDING_READY_DISCONNECTED(id) {\n    return \"Shard \".concat(id, \"'s Client disconnected before becoming ready.\");\n  },\n  SHARDING_READY_DIED: function SHARDING_READY_DIED(id) {\n    return \"Shard \".concat(id, \"'s process exited before its Client became ready.\");\n  },\n  COLOR_RANGE: 'Color must be within the range 0 - 16777215 (0xFFFFFF).',\n  COLOR_CONVERT: 'Unable to convert color to a number.',\n  EMBED_FIELD_NAME: 'MessageEmbed field names may not be empty.',\n  EMBED_FIELD_VALUE: 'MessageEmbed field values may not be empty.',\n  FILE_NOT_FOUND: function FILE_NOT_FOUND(file) {\n    return \"File could not be found: \".concat(file);\n  },\n  USER_NO_DMCHANNEL: 'No DM Channel exists!',\n  VOICE_INVALID_HEARTBEAT: 'Tried to set voice heartbeat but no valid interval was specified.',\n  VOICE_USER_MISSING: \"Couldn't resolve the user to create stream.\",\n  VOICE_JOIN_CHANNEL: function VOICE_JOIN_CHANNEL() {\n    var full = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return \"You do not have permission to join this voice channel\".concat(full ? '; it is full.' : '.');\n  },\n  VOICE_CONNECTION_TIMEOUT: 'Connection not established within 15 seconds.',\n  VOICE_TOKEN_ABSENT: 'Token not provided from voice server packet.',\n  VOICE_SESSION_ABSENT: 'Session ID not supplied.',\n  VOICE_INVALID_ENDPOINT: 'Invalid endpoint received.',\n  VOICE_NO_BROWSER: 'Voice connections are not available in browsers.',\n  VOICE_CONNECTION_ATTEMPTS_EXCEEDED: function VOICE_CONNECTION_ATTEMPTS_EXCEEDED(attempts) {\n    return \"Too many connection attempts (\".concat(attempts, \").\");\n  },\n  VOICE_JOIN_SOCKET_CLOSED: 'Tried to send join packet, but the WebSocket is not open.',\n  VOICE_PLAY_INTERFACE_NO_BROADCAST: 'A broadcast cannot be played in this context.',\n  VOICE_PLAY_INTERFACE_BAD_TYPE: 'Unknown stream type',\n  VOICE_PRISM_DEMUXERS_NEED_STREAM: 'To play a webm/ogg stream, you need to pass a ReadableStream.',\n  VOICE_STATE_UNCACHED_MEMBER: 'The member of this voice state is uncached.',\n  VOICE_STATE_NOT_OWN: 'You cannot self-deafen/mute on VoiceStates that do not belong to the ClientUser.',\n  VOICE_STATE_INVALID_TYPE: function VOICE_STATE_INVALID_TYPE(name) {\n    return \"\".concat(name, \" must be a boolean.\");\n  },\n  UDP_SEND_FAIL: 'Tried to send a UDP packet, but there is no socket available.',\n  UDP_ADDRESS_MALFORMED: 'Malformed UDP address or port.',\n  UDP_CONNECTION_EXISTS: 'There is already an existing UDP connection.',\n  REQ_RESOURCE_TYPE: 'The resource must be a string, Buffer or a valid file stream.',\n  IMAGE_FORMAT: function IMAGE_FORMAT(format) {\n    return \"Invalid image format: \".concat(format);\n  },\n  IMAGE_SIZE: function IMAGE_SIZE(size) {\n    return \"Invalid image size: \".concat(size);\n  },\n  MESSAGE_BULK_DELETE_TYPE: 'The messages must be an Array, Collection, or number.',\n  MESSAGE_NONCE_TYPE: 'Message nonce must fit in an unsigned 64-bit integer.',\n  TYPING_COUNT: 'Count must be at least 1',\n  SPLIT_MAX_LEN: 'Chunk exceeds the max length and contains no split characters.',\n  BAN_RESOLVE_ID: function BAN_RESOLVE_ID() {\n    var ban = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return \"Couldn't resolve the user ID to \".concat(ban ? 'ban' : 'unban', \".\");\n  },\n  FETCH_BAN_RESOLVE_ID: \"Couldn't resolve the user ID to fetch the ban.\",\n  PRUNE_DAYS_TYPE: 'Days must be a number',\n  GUILD_CHANNEL_RESOLVE: 'Could not resolve channel to a guild channel.',\n  GUILD_VOICE_CHANNEL_RESOLVE: 'Could not resolve channel to a guild voice channel.',\n  GUILD_CHANNEL_ORPHAN: 'Could not find a parent to this guild channel.',\n  GUILD_OWNED: 'Guild is owned by the client.',\n  GUILD_MEMBERS_TIMEOUT: \"Members didn't arrive in time.\",\n  GUILD_UNCACHED_ME: 'The client user as a member of this guild is uncached.',\n  INVALID_TYPE: function INVALID_TYPE(name, expected) {\n    var an = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    return \"Supplied \".concat(name, \" is not a\").concat(an ? 'n' : '', \" \").concat(expected, \".\");\n  },\n  WEBHOOK_MESSAGE: 'The message was not sent by a webhook.',\n  EMOJI_TYPE: 'Emoji must be a string or GuildEmoji/ReactionEmoji',\n  EMOJI_MANAGED: 'Emoji is managed and has no Author.',\n  MISSING_MANAGE_EMOJIS_PERMISSION: function MISSING_MANAGE_EMOJIS_PERMISSION(guild) {\n    return \"Client must have Manage Emoji permission in guild \".concat(guild, \" to see emoji authors.\");\n  },\n  REACTION_RESOLVE_USER: \"Couldn't resolve the user ID to remove from the reaction.\",\n  VANITY_URL: 'This guild does not have the VANITY_URL feature enabled.',\n  DELETE_GROUP_DM_CHANNEL: \"Bots don't have access to Group DM Channels and cannot delete them\",\n  FETCH_GROUP_DM_CHANNEL: \"Bots don't have access to Group DM Channels and cannot fetch them\"\n};\n\nfor (var _i2 = 0, _Object$entries = Object.entries(Messages); _i2 < _Object$entries.length; _i2++) {\n  var _ref3 = _Object$entries[_i2];\n\n  var _ref2 = _slicedToArray(_ref3, 2);\n\n  var name = _ref2[0];\n  var message = _ref2[1];\n  register(name, message);\n}","map":null,"metadata":{},"sourceType":"module"}