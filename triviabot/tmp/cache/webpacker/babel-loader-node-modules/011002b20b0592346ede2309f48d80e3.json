{"ast":null,"code":"'use strict';\n\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar Base = require('./Base');\n\nvar _require = require('./Presence'),\n    Presence = _require.Presence;\n\nvar Role = require('./Role');\n\nvar VoiceState = require('./VoiceState');\n\nvar TextBasedChannel = require('./interfaces/TextBasedChannel');\n\nvar _require2 = require('../errors'),\n    Error = _require2.Error;\n\nvar GuildMemberRoleManager = require('../managers/GuildMemberRoleManager');\n\nvar Permissions = require('../util/Permissions');\n/**\n * Represents a member of a guild on Discord.\n * @implements {TextBasedChannel}\n * @extends {Base}\n */\n\n\nvar GuildMember = /*#__PURE__*/function (_Base) {\n  _inherits(GuildMember, _Base);\n\n  var _super = _createSuper(GuildMember);\n\n  /**\n   * @param {Client} client The instantiating client\n   * @param {Object} data The data for the guild member\n   * @param {Guild} guild The guild the member is part of\n   */\n  function GuildMember(client, data, guild) {\n    var _this;\n\n    _classCallCheck(this, GuildMember);\n\n    _this = _super.call(this, client);\n    /**\n     * The guild that this member is part of\n     * @type {Guild}\n     */\n\n    _this.guild = guild;\n    /**\n     * The user that this guild member instance represents\n     * @type {User}\n     * @name GuildMember#user\n     */\n\n    if (data.user) _this.user = client.users.add(data.user, true);\n    /**\n     * The timestamp the member joined the guild at\n     * @type {?number}\n     */\n\n    _this.joinedTimestamp = null;\n    /**\n     * The ID of the last message sent by the member in their guild, if one was sent\n     * @type {?Snowflake}\n     */\n\n    _this.lastMessageID = null;\n    /**\n     * The ID of the channel for the last message sent by the member in their guild, if one was sent\n     * @type {?Snowflake}\n     */\n\n    _this.lastMessageChannelID = null;\n    /**\n     * The timestamp of when the member used their Nitro boost on the guild, if it was used\n     * @type {?number}\n     */\n\n    _this.premiumSinceTimestamp = null;\n    /**\n     * Whether the member has been removed from the guild\n     * @type {boolean}\n     */\n\n    _this.deleted = false;\n    _this._roles = [];\n    if (data) _this._patch(data);\n    return _this;\n  }\n\n  _createClass(GuildMember, [{\n    key: \"_patch\",\n    value: function _patch(data) {\n      /**\n       * The nickname of this member, if they have one\n       * @type {?string}\n       * @name GuildMember#nickname\n       */\n      if (typeof data.nick !== 'undefined') this.nickname = data.nick;\n      if (data.joined_at) this.joinedTimestamp = new Date(data.joined_at).getTime();\n      if (data.premium_since) this.premiumSinceTimestamp = new Date(data.premium_since).getTime();\n      if (data.user) this.user = this.guild.client.users.add(data.user);\n      if (data.roles) this._roles = data.roles;\n    }\n  }, {\n    key: \"_clone\",\n    value: function _clone() {\n      var clone = _get(_getPrototypeOf(GuildMember.prototype), \"_clone\", this).call(this);\n\n      clone._roles = this._roles.slice();\n      return clone;\n    }\n    /**\n     * Whether this GuildMember is a partial\n     * @type {boolean}\n     * @readonly\n     */\n\n  }, {\n    key: \"permissionsIn\",\n\n    /**\n     * Returns `channel.permissionsFor(guildMember)`. Returns permissions for a member in a guild channel,\n     * taking into account roles and permission overwrites.\n     * @param {ChannelResolvable} channel The guild channel to use as context\n     * @returns {Readonly<Permissions>}\n     */\n    value: function permissionsIn(channel) {\n      channel = this.guild.channels.resolve(channel);\n      if (!channel) throw new Error('GUILD_CHANNEL_RESOLVE');\n      return channel.memberPermissions(this);\n    }\n    /**\n     * Checks if any of this member's roles have a permission.\n     * @param {PermissionResolvable} permission Permission(s) to check for\n     * @param {Object} [options] Options\n     * @param {boolean} [options.checkAdmin=true] Whether to allow the administrator permission to override\n     * @param {boolean} [options.checkOwner=true] Whether to allow being the guild's owner to override\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"hasPermission\",\n    value: function hasPermission(permission) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref$checkAdmin = _ref.checkAdmin,\n          checkAdmin = _ref$checkAdmin === void 0 ? true : _ref$checkAdmin,\n          _ref$checkOwner = _ref.checkOwner,\n          checkOwner = _ref$checkOwner === void 0 ? true : _ref$checkOwner;\n\n      if (checkOwner && this.user.id === this.guild.ownerID) return true;\n      return this.roles.cache.some(function (r) {\n        return r.permissions.has(permission, checkAdmin);\n      });\n    }\n    /**\n     * The data for editing a guild member.\n     * @typedef {Object} GuildMemberEditData\n     * @property {string} [nick] The nickname to set for the member\n     * @property {Collection<Snowflake, Role>|RoleResolvable[]} [roles] The roles or role IDs to apply\n     * @property {boolean} [mute] Whether or not the member should be muted\n     * @property {boolean} [deaf] Whether or not the member should be deafened\n     * @property {ChannelResolvable|null} [channel] Channel to move member to (if they are connected to voice), or `null`\n     * if you want to kick them from voice\n     */\n\n    /**\n     * Edits this member.\n     * @param {GuildMemberEditData} data The data to edit the member with\n     * @param {string} [reason] Reason for editing this user\n     * @returns {Promise<GuildMember>}\n     */\n\n  }, {\n    key: \"edit\",\n    value: function () {\n      var _edit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(data, reason) {\n        var endpoint, keys, clone;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!data.channel) {\n                  _context.next = 8;\n                  break;\n                }\n\n                data.channel = this.guild.channels.resolve(data.channel);\n\n                if (!(!data.channel || data.channel.type !== 'voice')) {\n                  _context.next = 4;\n                  break;\n                }\n\n                throw new Error('GUILD_VOICE_CHANNEL_RESOLVE');\n\n              case 4:\n                data.channel_id = data.channel.id;\n                data.channel = undefined;\n                _context.next = 9;\n                break;\n\n              case 8:\n                if (data.channel === null) {\n                  data.channel_id = null;\n                  data.channel = undefined;\n                }\n\n              case 9:\n                if (data.roles) data.roles = data.roles.map(function (role) {\n                  return role instanceof Role ? role.id : role;\n                });\n                endpoint = this.client.api.guilds(this.guild.id);\n\n                if (this.user.id === this.client.user.id) {\n                  keys = Object.keys(data);\n                  if (keys.length === 1 && keys[0] === 'nick') endpoint = endpoint.members('@me').nick;else endpoint = endpoint.members(this.id);\n                } else {\n                  endpoint = endpoint.members(this.id);\n                }\n\n                _context.next = 14;\n                return endpoint.patch({\n                  data: data,\n                  reason: reason\n                });\n\n              case 14:\n                clone = this._clone();\n                data.user = this.user;\n\n                clone._patch(data);\n\n                return _context.abrupt(\"return\", clone);\n\n              case 18:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function edit(_x, _x2) {\n        return _edit.apply(this, arguments);\n      }\n\n      return edit;\n    }()\n    /**\n     * Sets the nickname for this member.\n     * @param {string} nick The nickname for the guild member\n     * @param {string} [reason] Reason for setting the nickname\n     * @returns {Promise<GuildMember>}\n     */\n\n  }, {\n    key: \"setNickname\",\n    value: function setNickname(nick, reason) {\n      return this.edit({\n        nick: nick\n      }, reason);\n    }\n    /**\n     * Creates a DM channel between the client and this member.\n     * @returns {Promise<DMChannel>}\n     */\n\n  }, {\n    key: \"createDM\",\n    value: function createDM() {\n      return this.user.createDM();\n    }\n    /**\n     * Deletes any DMs with this member.\n     * @returns {Promise<DMChannel>}\n     */\n\n  }, {\n    key: \"deleteDM\",\n    value: function deleteDM() {\n      return this.user.deleteDM();\n    }\n    /**\n     * Kicks this member from the guild.\n     * @param {string} [reason] Reason for kicking user\n     * @returns {Promise<GuildMember>}\n     */\n\n  }, {\n    key: \"kick\",\n    value: function kick(reason) {\n      var _this2 = this;\n\n      return this.client.api.guilds(this.guild.id).members(this.user.id)[\"delete\"]({\n        reason: reason\n      }).then(function () {\n        return _this2;\n      });\n    }\n    /**\n     * Bans this guild member.\n     * @param {Object} [options] Options for the ban\n     * @param {number} [options.days=0] Number of days of messages to delete\n     * @param {string} [options.reason] Reason for banning\n     * @returns {Promise<GuildMember>}\n     * @example\n     * // ban a guild member\n     * guildMember.ban({ days: 7, reason: 'They deserved it' })\n     *   .then(console.log)\n     *   .catch(console.error);\n     */\n\n  }, {\n    key: \"ban\",\n    value: function ban(options) {\n      return this.guild.members.ban(this, options);\n    }\n    /**\n     * Fetches this GuildMember.\n     * @returns {Promise<GuildMember>}\n     */\n\n  }, {\n    key: \"fetch\",\n    value: function fetch() {\n      return this.guild.members.fetch(this.id, true);\n    }\n    /**\n     * When concatenated with a string, this automatically returns the user's mention instead of the GuildMember object.\n     * @returns {string}\n     * @example\n     * // Logs: Hello from <@123456789012345678>!\n     * console.log(`Hello from ${member}!`);\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"<@\".concat(this.nickname ? '!' : '').concat(this.user.id, \">\");\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return _get(_getPrototypeOf(GuildMember.prototype), \"toJSON\", this).call(this, {\n        guild: 'guildID',\n        user: 'userID',\n        displayName: true,\n        speaking: false,\n        lastMessage: false,\n        lastMessageID: false,\n        roles: true\n      });\n    } // These are here only for documentation purposes - they are implemented by TextBasedChannel\n\n    /* eslint-disable no-empty-function */\n\n  }, {\n    key: \"send\",\n    value: function send() {}\n  }, {\n    key: \"partial\",\n    get: function get() {\n      return !this.joinedTimestamp;\n    }\n    /**\n     * A manager for the roles belonging to this member\n     * @type {GuildMemberRoleManager}\n     * @readonly\n     */\n\n  }, {\n    key: \"roles\",\n    get: function get() {\n      return new GuildMemberRoleManager(this);\n    }\n    /**\n     * The Message object of the last message sent by the member in their guild, if one was sent\n     * @type {?Message}\n     * @readonly\n     */\n\n  }, {\n    key: \"lastMessage\",\n    get: function get() {\n      var channel = this.guild.channels.cache.get(this.lastMessageChannelID);\n      return channel && channel.messages.cache.get(this.lastMessageID) || null;\n    }\n    /**\n     * The voice state of this member\n     * @type {VoiceState}\n     * @readonly\n     */\n\n  }, {\n    key: \"voice\",\n    get: function get() {\n      return this.guild.voiceStates.cache.get(this.id) || new VoiceState(this.guild, {\n        user_id: this.id\n      });\n    }\n    /**\n     * The time this member joined the guild\n     * @type {?Date}\n     * @readonly\n     */\n\n  }, {\n    key: \"joinedAt\",\n    get: function get() {\n      return this.joinedTimestamp ? new Date(this.joinedTimestamp) : null;\n    }\n    /**\n     * The time of when the member used their Nitro boost on the guild, if it was used\n     * @type {?Date}\n     * @readonly\n     */\n\n  }, {\n    key: \"premiumSince\",\n    get: function get() {\n      return this.premiumSinceTimestamp ? new Date(this.premiumSinceTimestamp) : null;\n    }\n    /**\n     * The presence of this guild member\n     * @type {Presence}\n     * @readonly\n     */\n\n  }, {\n    key: \"presence\",\n    get: function get() {\n      return this.guild.presences.cache.get(this.id) || new Presence(this.client, {\n        user: {\n          id: this.id\n        },\n        guild: this.guild\n      });\n    }\n    /**\n     * The displayed color of this member in base 10\n     * @type {number}\n     * @readonly\n     */\n\n  }, {\n    key: \"displayColor\",\n    get: function get() {\n      var role = this.roles.color;\n      return role && role.color || 0;\n    }\n    /**\n     * The displayed color of this member in hexadecimal\n     * @type {string}\n     * @readonly\n     */\n\n  }, {\n    key: \"displayHexColor\",\n    get: function get() {\n      var role = this.roles.color;\n      return role && role.hexColor || '#000000';\n    }\n    /**\n     * The ID of this member\n     * @type {Snowflake}\n     * @readonly\n     */\n\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this.user.id;\n    }\n    /**\n     * The nickname of this member, or their username if they don't have one\n     * @type {string}\n     * @readonly\n     */\n\n  }, {\n    key: \"displayName\",\n    get: function get() {\n      return this.nickname || this.user.username;\n    }\n    /**\n     * The overall set of permissions for this member, taking only roles into account\n     * @type {Readonly<Permissions>}\n     * @readonly\n     */\n\n  }, {\n    key: \"permissions\",\n    get: function get() {\n      if (this.user.id === this.guild.ownerID) return new Permissions(Permissions.ALL).freeze();\n      return new Permissions(this.roles.cache.map(function (role) {\n        return role.permissions;\n      })).freeze();\n    }\n    /**\n     * Whether the client user is above this user in the hierarchy, according to role position and guild ownership.\n     * This is a prerequisite for many moderative actions.\n     * @type {boolean}\n     * @readonly\n     */\n\n  }, {\n    key: \"manageable\",\n    get: function get() {\n      if (this.user.id === this.guild.ownerID) return false;\n      if (this.user.id === this.client.user.id) return false;\n      if (this.client.user.id === this.guild.ownerID) return true;\n      if (!this.guild.me) throw new Error('GUILD_UNCACHED_ME');\n      return this.guild.me.roles.highest.comparePositionTo(this.roles.highest) > 0;\n    }\n    /**\n     * Whether this member is kickable by the client user\n     * @type {boolean}\n     * @readonly\n     */\n\n  }, {\n    key: \"kickable\",\n    get: function get() {\n      return this.manageable && this.guild.me.permissions.has(Permissions.FLAGS.KICK_MEMBERS);\n    }\n    /**\n     * Whether this member is bannable by the client user\n     * @type {boolean}\n     * @readonly\n     */\n\n  }, {\n    key: \"bannable\",\n    get: function get() {\n      return this.manageable && this.guild.me.permissions.has(Permissions.FLAGS.BAN_MEMBERS);\n    }\n  }]);\n\n  return GuildMember;\n}(Base);\n\nTextBasedChannel.applyToClass(GuildMember);\nmodule.exports = GuildMember;","map":null,"metadata":{},"sourceType":"module"}