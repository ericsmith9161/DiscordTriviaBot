{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _createForOfIteratorHelper(o) { if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\n\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * A Map with additional utility methods. This is used throughout discord.js rather than Arrays for anything that has\n * an ID, for significantly improved performance and ease-of-use.\n * @extends {Map}\n * @property {number} size - The amount of elements in this collection.\n */\n\nvar Collection = /*#__PURE__*/function (_Map) {\n  _inherits(Collection, _Map);\n\n  var _super = _createSuper(Collection);\n\n  function Collection(entries) {\n    var _this;\n\n    _classCallCheck(this, Collection);\n\n    _this = _super.call(this, entries);\n    /**\n     * Cached array for the `array()` method - will be reset to `null` whenever `set()` or `delete()` are called\n     * @name Collection#_array\n     * @type {?Array}\n     * @private\n     */\n\n    Object.defineProperty(_assertThisInitialized(_this), '_array', {\n      value: null,\n      writable: true,\n      configurable: true\n    });\n    /**\n     * Cached array for the `keyArray()` method - will be reset to `null` whenever `set()` or `delete()` are called\n     * @name Collection#_keyArray\n     * @type {?Array}\n     * @private\n     */\n\n    Object.defineProperty(_assertThisInitialized(_this), '_keyArray', {\n      value: null,\n      writable: true,\n      configurable: true\n    });\n    return _this;\n  }\n  /**\n   * Identical to [Map.get()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/get).\n   * Gets an element with the specified key, and returns its value, or `undefined` if the element does not exist.\n   * @param {*} key - The key to get from this collection\n   * @returns {* | undefined}\n   */\n\n\n  _createClass(Collection, [{\n    key: \"get\",\n    value: function get(key) {\n      return _get(_getPrototypeOf(Collection.prototype), \"get\", this).call(this, key);\n    }\n    /**\n     * Identical to [Map.set()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/set).\n     * Sets a new element in the collection with the specified key and value.\n     * @param {*} key - The key of the element to add\n     * @param {*} value - The value of the element to add\n     * @returns {Collection}\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      this._array = null;\n      this._keyArray = null;\n      return _get(_getPrototypeOf(Collection.prototype), \"set\", this).call(this, key, value);\n    }\n    /**\n     * Identical to [Map.has()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/has).\n     * Checks if an element exists in the collection.\n     * @param {*} key - The key of the element to check for\n     * @returns {boolean} `true` if the element exists, `false` if it does not exist.\n     */\n\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      return _get(_getPrototypeOf(Collection.prototype), \"has\", this).call(this, key);\n    }\n    /**\n     * Identical to [Map.delete()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/delete).\n     * Deletes an element from the collection.\n     * @param {*} key - The key to delete from the collection\n     * @returns {boolean} `true` if the element was removed, `false` if the element does not exist.\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete(key) {\n      this._array = null;\n      this._keyArray = null;\n      return _get(_getPrototypeOf(Collection.prototype), \"delete\", this).call(this, key);\n    }\n    /**\n     * Identical to [Map.clear()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/clear).\n     * Removes all elements from the collection.\n     * @returns {undefined}\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      return _get(_getPrototypeOf(Collection.prototype), \"clear\", this).call(this);\n    }\n    /**\n     * Creates an ordered array of the values of this collection, and caches it internally. The array will only be\n     * reconstructed if an item is added to or removed from the collection, or if you change the length of the array\n     * itself. If you don't want this caching behavior, use `[...collection.values()]` or\n     * `Array.from(collection.values())` instead.\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"array\",\n    value: function array() {\n      if (!this._array || this._array.length !== this.size) this._array = _toConsumableArray(this.values());\n      return this._array;\n    }\n    /**\n     * Creates an ordered array of the keys of this collection, and caches it internally. The array will only be\n     * reconstructed if an item is added to or removed from the collection, or if you change the length of the array\n     * itself. If you don't want this caching behavior, use `[...collection.keys()]` or\n     * `Array.from(collection.keys())` instead.\n     * @returns {Array}\n     */\n\n  }, {\n    key: \"keyArray\",\n    value: function keyArray() {\n      if (!this._keyArray || this._keyArray.length !== this.size) this._keyArray = _toConsumableArray(this.keys());\n      return this._keyArray;\n    }\n  }, {\n    key: \"first\",\n    value: function first(amount) {\n      if (typeof amount === 'undefined') return this.values().next().value;\n      if (amount < 0) return this.last(amount * -1);\n      amount = Math.min(this.size, amount);\n      var iter = this.values();\n      return Array.from({\n        length: amount\n      }, function () {\n        return iter.next().value;\n      });\n    }\n  }, {\n    key: \"firstKey\",\n    value: function firstKey(amount) {\n      if (typeof amount === 'undefined') return this.keys().next().value;\n      if (amount < 0) return this.lastKey(amount * -1);\n      amount = Math.min(this.size, amount);\n      var iter = this.keys();\n      return Array.from({\n        length: amount\n      }, function () {\n        return iter.next().value;\n      });\n    }\n  }, {\n    key: \"last\",\n    value: function last(amount) {\n      var arr = this.array();\n      if (typeof amount === 'undefined') return arr[arr.length - 1];\n      if (amount < 0) return this.first(amount * -1);\n      if (!amount) return [];\n      return arr.slice(-amount);\n    }\n  }, {\n    key: \"lastKey\",\n    value: function lastKey(amount) {\n      var arr = this.keyArray();\n      if (typeof amount === 'undefined') return arr[arr.length - 1];\n      if (amount < 0) return this.firstKey(amount * -1);\n      if (!amount) return [];\n      return arr.slice(-amount);\n    }\n  }, {\n    key: \"random\",\n    value: function random(amount) {\n      var arr = this.array();\n      if (typeof amount === 'undefined') return arr[Math.floor(Math.random() * arr.length)];\n      if (arr.length === 0 || !amount) return [];\n      arr = arr.slice();\n      return Array.from({\n        length: amount\n      }, function () {\n        return arr.splice(Math.floor(Math.random() * arr.length), 1)[0];\n      });\n    }\n  }, {\n    key: \"randomKey\",\n    value: function randomKey(amount) {\n      var arr = this.keyArray();\n      if (typeof amount === 'undefined') return arr[Math.floor(Math.random() * arr.length)];\n      if (arr.length === 0 || !amount) return [];\n      arr = arr.slice();\n      return Array.from({\n        length: amount\n      }, function () {\n        return arr.splice(Math.floor(Math.random() * arr.length), 1)[0];\n      });\n    }\n  }, {\n    key: \"find\",\n    value: function find(fn, thisArg) {\n      if (typeof thisArg !== 'undefined') fn = fn.bind(thisArg);\n\n      var _iterator = _createForOfIteratorHelper(this),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _ref3 = _step.value;\n\n          var _ref2 = _slicedToArray(_ref3, 2);\n\n          var key = _ref2[0];\n          var val = _ref2[1];\n          if (fn(val, key, this)) return val;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return undefined;\n    }\n  }, {\n    key: \"findKey\",\n    value: function findKey(fn, thisArg) {\n      if (typeof thisArg !== 'undefined') fn = fn.bind(thisArg);\n\n      var _iterator2 = _createForOfIteratorHelper(this),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _ref6 = _step2.value;\n\n          var _ref5 = _slicedToArray(_ref6, 2);\n\n          var key = _ref5[0];\n          var val = _ref5[1];\n          if (fn(val, key, this)) return key;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return undefined;\n    }\n  }, {\n    key: \"sweep\",\n    value: function sweep(fn, thisArg) {\n      if (typeof thisArg !== 'undefined') fn = fn.bind(thisArg);\n      var previousSize = this.size;\n\n      var _iterator3 = _createForOfIteratorHelper(this),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _ref9 = _step3.value;\n\n          var _ref8 = _slicedToArray(_ref9, 2);\n\n          var key = _ref8[0];\n          var val = _ref8[1];\n          if (fn(val, key, this)) this[\"delete\"](key);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return previousSize - this.size;\n    }\n  }, {\n    key: \"filter\",\n    value: function filter(fn, thisArg) {\n      if (typeof thisArg !== 'undefined') fn = fn.bind(thisArg);\n      var results = new this.constructor[Symbol.species]();\n\n      var _iterator4 = _createForOfIteratorHelper(this),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _ref12 = _step4.value;\n\n          var _ref11 = _slicedToArray(_ref12, 2);\n\n          var key = _ref11[0];\n          var val = _ref11[1];\n          if (fn(val, key, this)) results.set(key, val);\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      return results;\n    }\n  }, {\n    key: \"partition\",\n    value: function partition(fn, thisArg) {\n      if (typeof thisArg !== 'undefined') fn = fn.bind(thisArg); // TODO: consider removing the <K, V> from the constructors after TS 3.7.0 is released, as it infers it\n\n      var results = [new this.constructor[Symbol.species](), new this.constructor[Symbol.species]()];\n\n      var _iterator5 = _createForOfIteratorHelper(this),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _ref15 = _step5.value;\n\n          var _ref14 = _slicedToArray(_ref15, 2);\n\n          var key = _ref14[0];\n          var val = _ref14[1];\n\n          if (fn(val, key, this)) {\n            results[0].set(key, val);\n          } else {\n            results[1].set(key, val);\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      return results;\n    }\n  }, {\n    key: \"flatMap\",\n    value: function flatMap(fn, thisArg) {\n      var _this$constructor$Sym;\n\n      var collections = this.map(fn, thisArg);\n      return (_this$constructor$Sym = new this.constructor[Symbol.species]()).concat.apply(_this$constructor$Sym, _toConsumableArray(collections));\n    }\n  }, {\n    key: \"map\",\n    value: function map(fn, thisArg) {\n      var _this2 = this;\n\n      if (typeof thisArg !== 'undefined') fn = fn.bind(thisArg);\n      var iter = this.entries();\n      return Array.from({\n        length: this.size\n      }, function () {\n        var _iter$next$value = _slicedToArray(iter.next().value, 2),\n            key = _iter$next$value[0],\n            value = _iter$next$value[1];\n\n        return fn(value, key, _this2);\n      });\n    }\n  }, {\n    key: \"mapValues\",\n    value: function mapValues(fn, thisArg) {\n      if (typeof thisArg !== 'undefined') fn = fn.bind(thisArg);\n      var coll = new this.constructor[Symbol.species]();\n\n      var _iterator6 = _createForOfIteratorHelper(this),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var _ref18 = _step6.value;\n\n          var _ref17 = _slicedToArray(_ref18, 2);\n\n          var key = _ref17[0];\n          var val = _ref17[1];\n          coll.set(key, fn(val, key, this));\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      return coll;\n    }\n  }, {\n    key: \"some\",\n    value: function some(fn, thisArg) {\n      if (typeof thisArg !== 'undefined') fn = fn.bind(thisArg);\n\n      var _iterator7 = _createForOfIteratorHelper(this),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var _ref21 = _step7.value;\n\n          var _ref20 = _slicedToArray(_ref21, 2);\n\n          var key = _ref20[0];\n          var val = _ref20[1];\n          if (fn(val, key, this)) return true;\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      return false;\n    }\n  }, {\n    key: \"every\",\n    value: function every(fn, thisArg) {\n      if (typeof thisArg !== 'undefined') fn = fn.bind(thisArg);\n\n      var _iterator8 = _createForOfIteratorHelper(this),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var _ref24 = _step8.value;\n\n          var _ref23 = _slicedToArray(_ref24, 2);\n\n          var key = _ref23[0];\n          var val = _ref23[1];\n          if (!fn(val, key, this)) return false;\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n\n      return true;\n    }\n    /**\n     * Applies a function to produce a single value. Identical in behavior to\n     * [Array.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce).\n     * @param {Function} fn Function used to reduce, taking four arguments; `accumulator`, `currentValue`, `currentKey`,\n     * and `collection`\n     * @param {*} [initialValue] Starting value for the accumulator\n     * @returns {*}\n     * @example collection.reduce((acc, guild) => acc + guild.memberCount, 0);\n     */\n\n  }, {\n    key: \"reduce\",\n    value: function reduce(fn, initialValue) {\n      var accumulator;\n\n      if (typeof initialValue !== 'undefined') {\n        accumulator = initialValue;\n\n        var _iterator9 = _createForOfIteratorHelper(this),\n            _step9;\n\n        try {\n          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n            var _ref27 = _step9.value;\n\n            var _ref26 = _slicedToArray(_ref27, 2);\n\n            var key = _ref26[0];\n            var val = _ref26[1];\n            accumulator = fn(accumulator, val, key, this);\n          }\n        } catch (err) {\n          _iterator9.e(err);\n        } finally {\n          _iterator9.f();\n        }\n\n        return accumulator;\n      }\n\n      var first = true;\n\n      var _iterator10 = _createForOfIteratorHelper(this),\n          _step10;\n\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var _ref30 = _step10.value;\n\n          var _ref29 = _slicedToArray(_ref30, 2);\n\n          var _key = _ref29[0];\n          var _val = _ref29[1];\n\n          if (first) {\n            accumulator = _val;\n            first = false;\n            continue;\n          }\n\n          accumulator = fn(accumulator, _val, _key, this);\n        } // No items iterated.\n\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n\n      if (first) {\n        throw new TypeError('Reduce of empty collection with no initial value');\n      }\n\n      return accumulator;\n    }\n  }, {\n    key: \"each\",\n    value: function each(fn, thisArg) {\n      this.forEach(fn, thisArg);\n      return this;\n    }\n  }, {\n    key: \"tap\",\n    value: function tap(fn, thisArg) {\n      if (typeof thisArg !== 'undefined') fn = fn.bind(thisArg);\n      fn(this);\n      return this;\n    }\n    /**\n     * Creates an identical shallow copy of this collection.\n     * @returns {Collection}\n     * @example const newColl = someColl.clone();\n     */\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new this.constructor[Symbol.species](this);\n    }\n    /**\n     * Combines this collection with others into a new collection. None of the source collections are modified.\n     * @param {...Collection} collections Collections to merge\n     * @returns {Collection}\n     * @example const newColl = someColl.concat(someOtherColl, anotherColl, ohBoyAColl);\n     */\n\n  }, {\n    key: \"concat\",\n    value: function concat() {\n      var newColl = this.clone();\n\n      for (var _len = arguments.length, collections = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {\n        collections[_key2] = arguments[_key2];\n      }\n\n      for (var _i2 = 0, _collections = collections; _i2 < _collections.length; _i2++) {\n        var coll = _collections[_i2];\n\n        var _iterator11 = _createForOfIteratorHelper(coll),\n            _step11;\n\n        try {\n          for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n            var _ref33 = _step11.value;\n\n            var _ref32 = _slicedToArray(_ref33, 2);\n\n            var key = _ref32[0];\n            var val = _ref32[1];\n            newColl.set(key, val);\n          }\n        } catch (err) {\n          _iterator11.e(err);\n        } finally {\n          _iterator11.f();\n        }\n      }\n\n      return newColl;\n    }\n    /**\n     * Checks if this collection shares identical items with another.\n     * This is different to checking for equality using equal-signs, because\n     * the collections may be different objects, but contain the same data.\n     * @param {Collection} collection Collection to compare with\n     * @returns {boolean} Whether the collections have identical contents\n     */\n\n  }, {\n    key: \"equals\",\n    value: function equals(collection) {\n      if (!collection) return false;\n      if (this === collection) return true;\n      if (this.size !== collection.size) return false;\n\n      var _iterator12 = _createForOfIteratorHelper(this),\n          _step12;\n\n      try {\n        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n          var _ref36 = _step12.value;\n\n          var _ref35 = _slicedToArray(_ref36, 2);\n\n          var key = _ref35[0];\n          var value = _ref35[1];\n\n          if (!collection.has(key) || value !== collection.get(key)) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _iterator12.e(err);\n      } finally {\n        _iterator12.f();\n      }\n\n      return true;\n    }\n    /**\n     * The sort method sorts the items of a collection in place and returns it.\n     * The sort is not necessarily stable. The default sort order is according to string Unicode code points.\n     * @param {Function} [compareFunction] Specifies a function that defines the sort order.\n     * If omitted, the collection is sorted according to each character's Unicode code point value,\n     * according to the string conversion of each element.\n     * @returns {Collection}\n     * @example collection.sort((userA, userB) => userA.createdTimestamp - userB.createdTimestamp);\n     */\n\n  }, {\n    key: \"sort\",\n    value: function sort() {\n      var compareFunction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (x, y) {\n        return Number(x > y) || Number(x === y) - 1;\n      };\n\n      var entries = _toConsumableArray(this.entries());\n\n      entries.sort(function (a, b) {\n        return compareFunction(a[1], b[1], a[0], b[0]);\n      }); // Perform clean-up\n\n      _get(_getPrototypeOf(Collection.prototype), \"clear\", this).call(this);\n\n      this._array = null;\n      this._keyArray = null; // Set the new entries\n\n      var _iterator13 = _createForOfIteratorHelper(entries),\n          _step13;\n\n      try {\n        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n          var _ref39 = _step13.value;\n\n          var _ref38 = _slicedToArray(_ref39, 2);\n\n          var k = _ref38[0];\n          var v = _ref38[1];\n\n          _get(_getPrototypeOf(Collection.prototype), \"set\", this).call(this, k, v);\n        }\n      } catch (err) {\n        _iterator13.e(err);\n      } finally {\n        _iterator13.f();\n      }\n\n      return this;\n    }\n    /**\n     * The intersect method returns a new structure containing items where the keys are present in both original structures.\n     * @param {Collection} other The other Collection to filter against\n     * @returns {Collection}\n     */\n\n  }, {\n    key: \"intersect\",\n    value: function intersect(other) {\n      var _this3 = this;\n\n      return other.filter(function (_, k) {\n        return _this3.has(k);\n      });\n    }\n    /**\n     * The difference method returns a new structure containing items where the key is present in one of the original structures but not the other.\n     * @param {Collection} other The other Collection to filter against\n     * @returns {Collection}\n     */\n\n  }, {\n    key: \"difference\",\n    value: function difference(other) {\n      var _this4 = this;\n\n      return other.filter(function (_, k) {\n        return !_this4.has(k);\n      }).concat(this.filter(function (_, k) {\n        return !other.has(k);\n      }));\n    }\n    /**\n     * The sorted method sorts the items of a collection and returns it.\n     * The sort is not necessarily stable. The default sort order is according to string Unicode code points.\n     * @param {Function} [compareFunction] Specifies a function that defines the sort order.\n     * If omitted, the collection is sorted according to each character's Unicode code point value,\n     * according to the string conversion of each element.\n     * @returns {Collection}\n     * @example collection.sorted((userA, userB) => userA.createdTimestamp - userB.createdTimestamp);\n     */\n\n  }, {\n    key: \"sorted\",\n    value: function sorted() {\n      var compareFunction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (x, y) {\n        return Number(x > y) || Number(x === y) - 1;\n      };\n      return new this.constructor[Symbol.species](_toConsumableArray(this.entries())).sort(function (av, bv, ak, bk) {\n        return compareFunction(av, bv, ak, bk);\n      });\n    }\n  }]);\n\n  return Collection;\n}( /*#__PURE__*/_wrapNativeSuper(Map));\n\nexports.Collection = Collection;\nCollection[\"default\"] = Collection;\nexports[\"default\"] = Collection;\nmodule.exports = Collection;","map":null,"metadata":{},"sourceType":"module"}