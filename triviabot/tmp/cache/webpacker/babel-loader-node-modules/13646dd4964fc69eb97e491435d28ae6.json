{"ast":null,"code":"'use strict';\n\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar APIMessage = require('./APIMessage');\n\nvar Channel = require('./Channel');\n\nvar _require = require('../util/Constants'),\n    WebhookTypes = _require.WebhookTypes;\n\nvar DataResolver = require('../util/DataResolver');\n\nvar Snowflake = require('../util/Snowflake');\n/**\n * Represents a webhook.\n */\n\n\nvar Webhook = /*#__PURE__*/function () {\n  function Webhook(client, data) {\n    _classCallCheck(this, Webhook);\n\n    /**\n     * The client that instantiated the webhook\n     * @name Webhook#client\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, 'client', {\n      value: client\n    });\n    if (data) this._patch(data);\n  }\n\n  _createClass(Webhook, [{\n    key: \"_patch\",\n    value: function _patch(data) {\n      /**\n       * The name of the webhook\n       * @type {string}\n       */\n      this.name = data.name;\n      /**\n       * The token for the webhook\n       * @name Webhook#token\n       * @type {?string}\n       */\n\n      Object.defineProperty(this, 'token', {\n        value: data.token || null,\n        writable: true,\n        configurable: true\n      });\n      /**\n       * The avatar for the webhook\n       * @type {?string}\n       */\n\n      this.avatar = data.avatar;\n      /**\n       * The ID of the webhook\n       * @type {Snowflake}\n       */\n\n      this.id = data.id;\n      /**\n       * The type of the webhook\n       * @type {WebhookTypes}\n       */\n\n      this.type = WebhookTypes[data.type];\n      /**\n       * The guild the webhook belongs to\n       * @type {Snowflake}\n       */\n\n      this.guildID = data.guild_id;\n      /**\n       * The channel the webhook belongs to\n       * @type {Snowflake}\n       */\n\n      this.channelID = data.channel_id;\n\n      if (data.user) {\n        /**\n         * The owner of the webhook\n         * @type {?User|Object}\n         */\n        this.owner = this.client.users ? this.client.users.cache.get(data.user.id) : data.user;\n      } else {\n        this.owner = null;\n      }\n    }\n    /**\n     * Options that can be passed into send.\n     * @typedef {Object} WebhookMessageOptions\n     * @property {string} [username=this.name] Username override for the message\n     * @property {string} [avatarURL] Avatar URL override for the message\n     * @property {boolean} [tts=false] Whether or not the message should be spoken aloud\n     * @property {string} [nonce=''] The nonce for the message\n     * @property {Object[]} [embeds] An array of embeds for the message\n     * @property {MessageMentionOptions} [allowedMentions] Which mentions should be parsed from the message content\n     * (see [here](https://discordapp.com/developers/docs/resources/channel#embed-object) for more details)\n     * @property {DisableMentionType} [disableMentions=this.client.options.disableMentions] Whether or not all mentions or\n     * everyone/here mentions should be sanitized to prevent unexpected mentions\n     * @property {FileOptions[]|string[]} [files] Files to send with the message\n     * @property {string|boolean} [code] Language for optional codeblock formatting to apply\n     * @property {boolean|SplitOptions} [split=false] Whether or not the message should be split into multiple messages if\n     * it exceeds the character limit. If an object is provided, these are the options for splitting the message.\n     */\n\n    /**\n     * Sends a message with this webhook.\n     * @param {StringResolvable|APIMessage} [content=''] The content to send\n     * @param {WebhookMessageOptions|MessageAdditions} [options={}] The options to provide\n     * @returns {Promise<Message|Object>}\n     * @example\n     * // Send a basic message\n     * webhook.send('hello!')\n     *   .then(message => console.log(`Sent message: ${message.content}`))\n     *   .catch(console.error);\n     * @example\n     * // Send a remote file\n     * webhook.send({\n     *   files: ['https://cdn.discordapp.com/icons/222078108977594368/6e1019b3179d71046e463a75915e7244.png?size=2048']\n     * })\n     *   .then(console.log)\n     *   .catch(console.error);\n     * @example\n     * // Send a local file\n     * webhook.send({\n     *   files: [{\n     *     attachment: 'entire/path/to/file.jpg',\n     *     name: 'file.jpg'\n     *   }]\n     * })\n     *   .then(console.log)\n     *   .catch(console.error);\n     * @example\n     * // Send an embed with a local image inside\n     * webhook.send('This is an embed', {\n     *   embeds: [{\n     *     thumbnail: {\n     *          url: 'attachment://file.jpg'\n     *       }\n     *    }],\n     *    files: [{\n     *       attachment: 'entire/path/to/file.jpg',\n     *       name: 'file.jpg'\n     *    }]\n     * })\n     *   .then(console.log)\n     *   .catch(console.error);\n     */\n\n  }, {\n    key: \"send\",\n    value: function () {\n      var _send = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(content, options) {\n        var _this = this;\n\n        var apiMessage, _yield$apiMessage$res, data, files;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(content instanceof APIMessage)) {\n                  _context.next = 4;\n                  break;\n                }\n\n                apiMessage = content.resolveData();\n                _context.next = 7;\n                break;\n\n              case 4:\n                apiMessage = APIMessage.create(this, content, options).resolveData();\n\n                if (!Array.isArray(apiMessage.data.content)) {\n                  _context.next = 7;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", Promise.all(apiMessage.split().map(this.send.bind(this))));\n\n              case 7:\n                _context.next = 9;\n                return apiMessage.resolveFiles();\n\n              case 9:\n                _yield$apiMessage$res = _context.sent;\n                data = _yield$apiMessage$res.data;\n                files = _yield$apiMessage$res.files;\n                return _context.abrupt(\"return\", this.client.api.webhooks(this.id, this.token).post({\n                  data: data,\n                  files: files,\n                  query: {\n                    wait: true\n                  },\n                  auth: false\n                }).then(function (d) {\n                  var channel = _this.client.channels ? _this.client.channels.cache.get(d.channel_id) : undefined;\n                  if (!channel) return d;\n                  return channel.messages.add(d, false);\n                }));\n\n              case 13:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function send(_x, _x2) {\n        return _send.apply(this, arguments);\n      }\n\n      return send;\n    }()\n    /**\n     * Sends a raw slack message with this webhook.\n     * @param {Object} body The raw body to send\n     * @returns {Promise<boolean>}\n     * @example\n     * // Send a slack message\n     * webhook.sendSlackMessage({\n     *   'username': 'Wumpus',\n     *   'attachments': [{\n     *     'pretext': 'this looks pretty cool',\n     *     'color': '#F0F',\n     *     'footer_icon': 'http://snek.s3.amazonaws.com/topSnek.png',\n     *     'footer': 'Powered by sneks',\n     *     'ts': Date.now() / 1000\n     *   }]\n     * }).catch(console.error);\n     */\n\n  }, {\n    key: \"sendSlackMessage\",\n    value: function sendSlackMessage(body) {\n      return this.client.api.webhooks(this.id, this.token).slack.post({\n        query: {\n          wait: true\n        },\n        auth: false,\n        data: body\n      }).then(function (data) {\n        return data.toString() === 'ok';\n      });\n    }\n    /**\n     * Edits the webhook.\n     * @param {Object} options Options\n     * @param {string} [options.name=this.name] New name for this webhook\n     * @param {BufferResolvable} [options.avatar] New avatar for this webhook\n     * @param {ChannelResolvable} [options.channel] New channel for this webhook\n     * @param {string} [reason] Reason for editing this webhook\n     * @returns {Promise<Webhook>}\n     */\n\n  }, {\n    key: \"edit\",\n    value: function () {\n      var _edit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref, reason) {\n        var _ref$name, name, avatar, channel, data;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _ref$name = _ref.name, name = _ref$name === void 0 ? this.name : _ref$name, avatar = _ref.avatar, channel = _ref.channel;\n\n                if (!(avatar && typeof avatar === 'string' && !avatar.startsWith('data:'))) {\n                  _context2.next = 5;\n                  break;\n                }\n\n                _context2.next = 4;\n                return DataResolver.resolveImage(avatar);\n\n              case 4:\n                avatar = _context2.sent;\n\n              case 5:\n                if (channel) channel = channel instanceof Channel ? channel.id : channel;\n                _context2.next = 8;\n                return this.client.api.webhooks(this.id, channel ? undefined : this.token).patch({\n                  data: {\n                    name: name,\n                    avatar: avatar,\n                    channel_id: channel\n                  },\n                  reason: reason\n                });\n\n              case 8:\n                data = _context2.sent;\n                this.name = data.name;\n                this.avatar = data.avatar;\n                this.channelID = data.channel_id;\n                return _context2.abrupt(\"return\", this);\n\n              case 13:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function edit(_x3, _x4) {\n        return _edit.apply(this, arguments);\n      }\n\n      return edit;\n    }()\n    /**\n     * Deletes the webhook.\n     * @param {string} [reason] Reason for deleting this webhook\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete(reason) {\n      return this.client.api.webhooks(this.id, this.token)[\"delete\"]({\n        reason: reason\n      });\n    }\n    /**\n     * The timestamp the webhook was created at\n     * @type {number}\n     * @readonly\n     */\n\n  }, {\n    key: \"avatarURL\",\n\n    /**\n     * A link to the webhook's avatar.\n     * @param {ImageURLOptions} [options={}] Options for the Image URL\n     * @returns {?string}\n     */\n    value: function avatarURL() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          format = _ref2.format,\n          size = _ref2.size;\n\n      if (!this.avatar) return null;\n      return this.client.rest.cdn.Avatar(this.id, this.avatar, format, size);\n    }\n  }, {\n    key: \"createdTimestamp\",\n    get: function get() {\n      return Snowflake.deconstruct(this.id).timestamp;\n    }\n    /**\n     * The time the webhook was created at\n     * @type {Date}\n     * @readonly\n     */\n\n  }, {\n    key: \"createdAt\",\n    get: function get() {\n      return new Date(this.createdTimestamp);\n    }\n    /**\n     * The url of this webhook\n     * @type {string}\n     * @readonly\n     */\n\n  }, {\n    key: \"url\",\n    get: function get() {\n      return this.client.options.http.api + this.client.api.webhooks(this.id, this.token);\n    }\n  }], [{\n    key: \"applyToClass\",\n    value: function applyToClass(structure) {\n      for (var _i = 0, _arr = ['send', 'sendSlackMessage', 'edit', 'delete', 'createdTimestamp', 'createdAt', 'url']; _i < _arr.length; _i++) {\n        var prop = _arr[_i];\n        Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(Webhook.prototype, prop));\n      }\n    }\n  }]);\n\n  return Webhook;\n}();\n\nmodule.exports = Webhook;","map":null,"metadata":{},"sourceType":"module"}