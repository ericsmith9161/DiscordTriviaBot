{"ast":null,"code":"'use strict';\n\nfunction _createForOfIteratorHelper(o) { if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar _require = require('path'),\n    parse = _require.parse;\n\nvar fetch = require('node-fetch');\n\nvar _require2 = require('./Constants'),\n    Colors = _require2.Colors,\n    DefaultOptions = _require2.DefaultOptions,\n    Endpoints = _require2.Endpoints;\n\nvar _require3 = require('../errors'),\n    DiscordError = _require3.Error,\n    RangeError = _require3.RangeError,\n    _TypeError = _require3.TypeError;\n\nvar has = function has(o, k) {\n  return Object.prototype.hasOwnProperty.call(o, k);\n};\n\nvar isObject = function isObject(d) {\n  return _typeof(d) === 'object' && d !== null;\n};\n/**\n * Contains various general-purpose utility methods. These functions are also available on the base `Discord` object.\n */\n\n\nvar Util = /*#__PURE__*/function () {\n  function Util() {\n    _classCallCheck(this, Util);\n\n    throw new Error(\"The \".concat(this.constructor.name, \" class may not be instantiated.\"));\n  }\n  /**\n   * Flatten an object. Any properties that are collections will get converted to an array of keys.\n   * @param {Object} obj The object to flatten.\n   * @param {...Object<string, boolean|string>} [props] Specific properties to include/exclude.\n   * @returns {Object}\n   */\n\n\n  _createClass(Util, null, [{\n    key: \"flatten\",\n    value: function flatten(obj) {\n      for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        props[_key - 1] = arguments[_key];\n      }\n\n      if (!isObject(obj)) return obj;\n      props = Object.assign.apply(Object, _toConsumableArray(Object.keys(obj).filter(function (k) {\n        return !k.startsWith('_');\n      }).map(function (k) {\n        return _defineProperty({}, k, true);\n      })).concat(_toConsumableArray(props)));\n      var out = {};\n\n      for (var _i2 = 0, _Object$entries = Object.entries(props); _i2 < _Object$entries.length; _i2++) {\n        var _ref4 = _Object$entries[_i2];\n\n        var _ref3 = _slicedToArray(_ref4, 2);\n\n        var prop = _ref3[0];\n        var newProp = _ref3[1];\n        if (!newProp) continue;\n        newProp = newProp === true ? prop : newProp;\n        var element = obj[prop];\n        var elemIsObj = isObject(element);\n\n        var _valueOf = elemIsObj && typeof element.valueOf === 'function' ? element.valueOf() : null; // If it's a Collection, make the array of keys\n\n\n        if (element instanceof require('./Collection')) out[newProp] = Array.from(element.keys()); // If the valueOf is a Collection, use its array of keys\n        else if (_valueOf instanceof require('./Collection')) out[newProp] = Array.from(_valueOf.keys()); // If it's an array, flatten each element\n          else if (Array.isArray(element)) out[newProp] = element.map(function (e) {\n              return Util.flatten(e);\n            }); // If it's an object with a primitive `valueOf`, use that value\n            else if (_typeof(_valueOf) !== 'object') out[newProp] = _valueOf; // If it's a primitive\n              else if (!elemIsObj) out[newProp] = element;\n      }\n\n      return out;\n    }\n    /**\n     * Splits a string into multiple chunks at a designated character that do not exceed a specific length.\n     * @param {StringResolvable} text Content to split\n     * @param {SplitOptions} [options] Options controlling the behavior of the split\n     * @returns {string[]}\n     */\n\n  }, {\n    key: \"splitMessage\",\n    value: function splitMessage(text) {\n      var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref5$maxLength = _ref5.maxLength,\n          maxLength = _ref5$maxLength === void 0 ? 2000 : _ref5$maxLength,\n          _ref5$char = _ref5[\"char\"],\n          _char = _ref5$char === void 0 ? '\\n' : _ref5$char,\n          _ref5$prepend = _ref5.prepend,\n          prepend = _ref5$prepend === void 0 ? '' : _ref5$prepend,\n          _ref5$append = _ref5.append,\n          append = _ref5$append === void 0 ? '' : _ref5$append;\n\n      text = Util.resolveString(text);\n      if (text.length <= maxLength) return [text];\n      var splitText = text.split(_char);\n      if (splitText.some(function (chunk) {\n        return chunk.length > maxLength;\n      })) throw new RangeError('SPLIT_MAX_LEN');\n      var messages = [];\n      var msg = '';\n\n      var _iterator = _createForOfIteratorHelper(splitText),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var chunk = _step.value;\n\n          if (msg && (msg + _char + chunk + append).length > maxLength) {\n            messages.push(msg + append);\n            msg = prepend;\n          }\n\n          msg += (msg && msg !== prepend ? _char : '') + chunk;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return messages.concat(msg).filter(function (m) {\n        return m;\n      });\n    }\n    /**\n     * Escapes any Discord-flavour markdown in a string.\n     * @param {string} text Content to escape\n     * @param {Object} [options={}] What types of markdown to escape\n     * @param {boolean} [options.codeBlock=true] Whether to escape code blocks or not\n     * @param {boolean} [options.inlineCode=true] Whether to escape inline code or not\n     * @param {boolean} [options.bold=true] Whether to escape bolds or not\n     * @param {boolean} [options.italic=true] Whether to escape italics or not\n     * @param {boolean} [options.underline=true] Whether to escape underlines or not\n     * @param {boolean} [options.strikethrough=true] Whether to escape strikethroughs or not\n     * @param {boolean} [options.spoiler=true] Whether to escape spoilers or not\n     * @param {boolean} [options.codeBlockContent=true] Whether to escape text inside code blocks or not\n     * @param {boolean} [options.inlineCodeContent=true] Whether to escape text inside inline code or not\n     * @returns {string}\n     */\n\n  }, {\n    key: \"escapeMarkdown\",\n    value: function escapeMarkdown(text) {\n      var _ref6 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref6$codeBlock = _ref6.codeBlock,\n          codeBlock = _ref6$codeBlock === void 0 ? true : _ref6$codeBlock,\n          _ref6$inlineCode = _ref6.inlineCode,\n          inlineCode = _ref6$inlineCode === void 0 ? true : _ref6$inlineCode,\n          _ref6$bold = _ref6.bold,\n          bold = _ref6$bold === void 0 ? true : _ref6$bold,\n          _ref6$italic = _ref6.italic,\n          italic = _ref6$italic === void 0 ? true : _ref6$italic,\n          _ref6$underline = _ref6.underline,\n          underline = _ref6$underline === void 0 ? true : _ref6$underline,\n          _ref6$strikethrough = _ref6.strikethrough,\n          strikethrough = _ref6$strikethrough === void 0 ? true : _ref6$strikethrough,\n          _ref6$spoiler = _ref6.spoiler,\n          spoiler = _ref6$spoiler === void 0 ? true : _ref6$spoiler,\n          _ref6$codeBlockConten = _ref6.codeBlockContent,\n          codeBlockContent = _ref6$codeBlockConten === void 0 ? true : _ref6$codeBlockConten,\n          _ref6$inlineCodeConte = _ref6.inlineCodeContent,\n          inlineCodeContent = _ref6$inlineCodeConte === void 0 ? true : _ref6$inlineCodeConte;\n\n      if (!codeBlockContent) {\n        return text.split('```').map(function (subString, index, array) {\n          if (index % 2 && index !== array.length - 1) return subString;\n          return Util.escapeMarkdown(subString, {\n            inlineCode: inlineCode,\n            bold: bold,\n            italic: italic,\n            underline: underline,\n            strikethrough: strikethrough,\n            spoiler: spoiler,\n            inlineCodeContent: inlineCodeContent\n          });\n        }).join(codeBlock ? '\\\\`\\\\`\\\\`' : '```');\n      }\n\n      if (!inlineCodeContent) {\n        return text.split(/(?<=^|[^`])`(?=[^`]|$)/g).map(function (subString, index, array) {\n          if (index % 2 && index !== array.length - 1) return subString;\n          return Util.escapeMarkdown(subString, {\n            codeBlock: codeBlock,\n            bold: bold,\n            italic: italic,\n            underline: underline,\n            strikethrough: strikethrough,\n            spoiler: spoiler\n          });\n        }).join(inlineCode ? '\\\\`' : '`');\n      }\n\n      if (inlineCode) text = Util.escapeInlineCode(text);\n      if (codeBlock) text = Util.escapeCodeBlock(text);\n      if (italic) text = Util.escapeItalic(text);\n      if (bold) text = Util.escapeBold(text);\n      if (underline) text = Util.escapeUnderline(text);\n      if (strikethrough) text = Util.escapeStrikethrough(text);\n      if (spoiler) text = Util.escapeSpoiler(text);\n      return text;\n    }\n    /**\n     * Escapes code block markdown in a string.\n     * @param {string} text Content to escape\n     * @returns {string}\n     */\n\n  }, {\n    key: \"escapeCodeBlock\",\n    value: function escapeCodeBlock(text) {\n      return text.replace(/```/g, '\\\\`\\\\`\\\\`');\n    }\n    /**\n     * Escapes inline code markdown in a string.\n     * @param {string} text Content to escape\n     * @returns {string}\n     */\n\n  }, {\n    key: \"escapeInlineCode\",\n    value: function escapeInlineCode(text) {\n      return text.replace(/(?<=^|[^`])`(?=[^`]|$)/g, '\\\\`');\n    }\n    /**\n     * Escapes italic markdown in a string.\n     * @param {string} text Content to escape\n     * @returns {string}\n     */\n\n  }, {\n    key: \"escapeItalic\",\n    value: function escapeItalic(text) {\n      var i = 0;\n      text = text.replace(/(?<=^|[^*])\\*([^*]|\\*\\*|$)/g, function (_, match) {\n        if (match === '**') return ++i % 2 ? \"\\\\*\".concat(match) : \"\".concat(match, \"\\\\*\");\n        return \"\\\\*\".concat(match);\n      });\n      i = 0;\n      return text.replace(/(?<=^|[^_])_([^_]|__|$)/g, function (_, match) {\n        if (match === '__') return ++i % 2 ? \"\\\\_\".concat(match) : \"\".concat(match, \"\\\\_\");\n        return \"\\\\_\".concat(match);\n      });\n    }\n    /**\n     * Escapes bold markdown in a string.\n     * @param {string} text Content to escape\n     * @returns {string}\n     */\n\n  }, {\n    key: \"escapeBold\",\n    value: function escapeBold(text) {\n      var i = 0;\n      return text.replace(/\\*\\*(\\*)?/g, function (_, match) {\n        if (match) return ++i % 2 ? \"\".concat(match, \"\\\\*\\\\*\") : \"\\\\*\\\\*\".concat(match);\n        return '\\\\*\\\\*';\n      });\n    }\n    /**\n     * Escapes underline markdown in a string.\n     * @param {string} text Content to escape\n     * @returns {string}\n     */\n\n  }, {\n    key: \"escapeUnderline\",\n    value: function escapeUnderline(text) {\n      var i = 0;\n      return text.replace(/__(_)?/g, function (_, match) {\n        if (match) return ++i % 2 ? \"\".concat(match, \"\\\\_\\\\_\") : \"\\\\_\\\\_\".concat(match);\n        return '\\\\_\\\\_';\n      });\n    }\n    /**\n     * Escapes strikethrough markdown in a string.\n     * @param {string} text Content to escape\n     * @returns {string}\n     */\n\n  }, {\n    key: \"escapeStrikethrough\",\n    value: function escapeStrikethrough(text) {\n      return text.replace(/~~/g, '\\\\~\\\\~');\n    }\n    /**\n     * Escapes spoiler markdown in a string.\n     * @param {string} text Content to escape\n     * @returns {string}\n     */\n\n  }, {\n    key: \"escapeSpoiler\",\n    value: function escapeSpoiler(text) {\n      return text.replace(/\\|\\|/g, '\\\\|\\\\|');\n    }\n    /**\n     * Gets the recommended shard count from Discord.\n     * @param {string} token Discord auth token\n     * @param {number} [guildsPerShard=1000] Number of guilds per shard\n     * @returns {Promise<number>} The recommended number of shards\n     */\n\n  }, {\n    key: \"fetchRecommendedShards\",\n    value: function fetchRecommendedShards(token) {\n      var guildsPerShard = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n      if (!token) throw new DiscordError('TOKEN_MISSING');\n      return fetch(\"\".concat(DefaultOptions.http.api, \"/v\").concat(DefaultOptions.http.version).concat(Endpoints.botGateway), {\n        method: 'GET',\n        headers: {\n          Authorization: \"Bot \".concat(token.replace(/^Bot\\s*/i, ''))\n        }\n      }).then(function (res) {\n        if (res.ok) return res.json();\n        throw res;\n      }).then(function (data) {\n        return data.shards * (1000 / guildsPerShard);\n      });\n    }\n    /**\n     * Parses emoji info out of a string. The string must be one of:\n     * * A UTF-8 emoji (no ID)\n     * * A URL-encoded UTF-8 emoji (no ID)\n     * * A Discord custom emoji (`<:name:id>` or `<a:name:id>`)\n     * @param {string} text Emoji string to parse\n     * @returns {Object} Object with `animated`, `name`, and `id` properties\n     * @private\n     */\n\n  }, {\n    key: \"parseEmoji\",\n    value: function parseEmoji(text) {\n      if (text.includes('%')) text = decodeURIComponent(text);\n      if (!text.includes(':')) return {\n        animated: false,\n        name: text,\n        id: null\n      };\n      var m = text.match(/<?(?:(a):)?(\\w{2,32}):(\\d{17,19})?>?/);\n      if (!m) return null;\n      return {\n        animated: Boolean(m[1]),\n        name: m[2],\n        id: m[3] || null\n      };\n    }\n    /**\n     * Shallow-copies an object with its class/prototype intact.\n     * @param {Object} obj Object to clone\n     * @returns {Object}\n     * @private\n     */\n\n  }, {\n    key: \"cloneObject\",\n    value: function cloneObject(obj) {\n      return Object.assign(Object.create(obj), obj);\n    }\n    /**\n     * Sets default properties on an object that aren't already specified.\n     * @param {Object} def Default properties\n     * @param {Object} given Object to assign defaults to\n     * @returns {Object}\n     * @private\n     */\n\n  }, {\n    key: \"mergeDefault\",\n    value: function mergeDefault(def, given) {\n      if (!given) return def;\n\n      for (var key in def) {\n        if (!has(given, key) || given[key] === undefined) {\n          given[key] = def[key];\n        } else if (given[key] === Object(given[key])) {\n          given[key] = Util.mergeDefault(def[key], given[key]);\n        }\n      }\n\n      return given;\n    }\n    /**\n     * Converts an ArrayBuffer or string to a Buffer.\n     * @param {ArrayBuffer|string} ab ArrayBuffer to convert\n     * @returns {Buffer}\n     * @private\n     */\n\n  }, {\n    key: \"convertToBuffer\",\n    value: function convertToBuffer(ab) {\n      if (typeof ab === 'string') ab = Util.str2ab(ab);\n      return Buffer.from(ab);\n    }\n    /**\n     * Converts a string to an ArrayBuffer.\n     * @param {string} str String to convert\n     * @returns {ArrayBuffer}\n     * @private\n     */\n\n  }, {\n    key: \"str2ab\",\n    value: function str2ab(str) {\n      var buffer = new ArrayBuffer(str.length * 2);\n      var view = new Uint16Array(buffer);\n\n      for (var i = 0, strLen = str.length; i < strLen; i++) {\n        view[i] = str.charCodeAt(i);\n      }\n\n      return buffer;\n    }\n    /**\n     * Makes an Error from a plain info object.\n     * @param {Object} obj Error info\n     * @param {string} obj.name Error type\n     * @param {string} obj.message Message for the error\n     * @param {string} obj.stack Stack for the error\n     * @returns {Error}\n     * @private\n     */\n\n  }, {\n    key: \"makeError\",\n    value: function makeError(obj) {\n      var err = new Error(obj.message);\n      err.name = obj.name;\n      err.stack = obj.stack;\n      return err;\n    }\n    /**\n     * Makes a plain error info object from an Error.\n     * @param {Error} err Error to get info from\n     * @returns {Object}\n     * @private\n     */\n\n  }, {\n    key: \"makePlainError\",\n    value: function makePlainError(err) {\n      return {\n        name: err.name,\n        message: err.message,\n        stack: err.stack\n      };\n    }\n    /**\n     * Moves an element in an array *in place*.\n     * @param {Array<*>} array Array to modify\n     * @param {*} element Element to move\n     * @param {number} newIndex Index or offset to move the element to\n     * @param {boolean} [offset=false] Move the element by an offset amount rather than to a set index\n     * @returns {number}\n     * @private\n     */\n\n  }, {\n    key: \"moveElementInArray\",\n    value: function moveElementInArray(array, element, newIndex) {\n      var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var index = array.indexOf(element);\n      newIndex = (offset ? index : 0) + newIndex;\n\n      if (newIndex > -1 && newIndex < array.length) {\n        var removedElement = array.splice(index, 1)[0];\n        array.splice(newIndex, 0, removedElement);\n      }\n\n      return array.indexOf(element);\n    }\n    /**\n     * Data that can be resolved to give a string. This can be:\n     * * A string\n     * * An array (joined with a new line delimiter to give a string)\n     * * Any value\n     * @typedef {string|Array|*} StringResolvable\n     */\n\n    /**\n     * Resolves a StringResolvable to a string.\n     * @param {StringResolvable} data The string resolvable to resolve\n     * @returns {string}\n     */\n\n  }, {\n    key: \"resolveString\",\n    value: function resolveString(data) {\n      if (typeof data === 'string') return data;\n      if (Array.isArray(data)) return data.join('\\n');\n      return String(data);\n    }\n    /**\n     * Can be a number, hex string, an RGB array like:\n     * ```js\n     * [255, 0, 255] // purple\n     * ```\n     * or one of the following strings:\n     * - `DEFAULT`\n     * - `WHITE`\n     * - `AQUA`\n     * - `GREEN`\n     * - `BLUE`\n     * - `YELLOW`\n     * - `PURPLE`\n     * - `LUMINOUS_VIVID_PINK`\n     * - `GOLD`\n     * - `ORANGE`\n     * - `RED`\n     * - `GREY`\n     * - `DARKER_GREY`\n     * - `NAVY`\n     * - `DARK_AQUA`\n     * - `DARK_GREEN`\n     * - `DARK_BLUE`\n     * - `DARK_PURPLE`\n     * - `DARK_VIVID_PINK`\n     * - `DARK_GOLD`\n     * - `DARK_ORANGE`\n     * - `DARK_RED`\n     * - `DARK_GREY`\n     * - `LIGHT_GREY`\n     * - `DARK_NAVY`\n     * - `RANDOM`\n     * @typedef {string|number|number[]} ColorResolvable\n     */\n\n    /**\n     * Resolves a ColorResolvable into a color number.\n     * @param {ColorResolvable} color Color to resolve\n     * @returns {number} A color\n     */\n\n  }, {\n    key: \"resolveColor\",\n    value: function resolveColor(color) {\n      if (typeof color === 'string') {\n        if (color === 'RANDOM') return Math.floor(Math.random() * (0xffffff + 1));\n        if (color === 'DEFAULT') return 0;\n        color = Colors[color] || parseInt(color.replace('#', ''), 16);\n      } else if (Array.isArray(color)) {\n        color = (color[0] << 16) + (color[1] << 8) + color[2];\n      }\n\n      if (color < 0 || color > 0xffffff) throw new RangeError('COLOR_RANGE');else if (color && isNaN(color)) throw new _TypeError('COLOR_CONVERT');\n      return color;\n    }\n    /**\n     * Sorts by Discord's position and ID.\n     * @param  {Collection} collection Collection of objects to sort\n     * @returns {Collection}\n     */\n\n  }, {\n    key: \"discordSort\",\n    value: function discordSort(collection) {\n      return collection.sorted(function (a, b) {\n        return a.rawPosition - b.rawPosition || parseInt(b.id.slice(0, -10)) - parseInt(a.id.slice(0, -10)) || parseInt(b.id.slice(10)) - parseInt(a.id.slice(10));\n      });\n    }\n    /**\n     * Sets the position of a Channel or Role.\n     * @param {Channel|Role} item Object to set the position of\n     * @param {number} position New position for the object\n     * @param {boolean} relative Whether `position` is relative to its current position\n     * @param {Collection<string, Channel|Role>} sorted A collection of the objects sorted properly\n     * @param {APIRouter} route Route to call PATCH on\n     * @param {string} [reason] Reason for the change\n     * @returns {Promise<Object[]>} Updated item list, with `id` and `position` properties\n     * @private\n     */\n\n  }, {\n    key: \"setPosition\",\n    value: function setPosition(item, position, relative, sorted, route, reason) {\n      var updatedItems = sorted.array();\n      Util.moveElementInArray(updatedItems, item, position, relative);\n      updatedItems = updatedItems.map(function (r, i) {\n        return {\n          id: r.id,\n          position: i\n        };\n      });\n      return route.patch({\n        data: updatedItems,\n        reason: reason\n      }).then(function () {\n        return updatedItems;\n      });\n    }\n    /**\n     * Alternative to Node's `path.basename`, removing query string after the extension if it exists.\n     * @param {string} path Path to get the basename of\n     * @param {string} [ext] File extension to remove\n     * @returns {string} Basename of the path\n     * @private\n     */\n\n  }, {\n    key: \"basename\",\n    value: function basename(path, ext) {\n      var res = parse(path);\n      return ext && res.ext.startsWith(ext) ? res.name : res.base.split('?')[0];\n    }\n    /**\n     * Transforms a snowflake from a decimal string to a bit string.\n     * @param  {Snowflake} num Snowflake to be transformed\n     * @returns {string}\n     * @private\n     */\n\n  }, {\n    key: \"idToBinary\",\n    value: function idToBinary(num) {\n      var bin = '';\n      var high = parseInt(num.slice(0, -10)) || 0;\n      var low = parseInt(num.slice(-10));\n\n      while (low > 0 || high > 0) {\n        bin = String(low & 1) + bin;\n        low = Math.floor(low / 2);\n\n        if (high > 0) {\n          low += 5000000000 * (high % 2);\n          high = Math.floor(high / 2);\n        }\n      }\n\n      return bin;\n    }\n    /**\n     * Transforms a snowflake from a bit string to a decimal string.\n     * @param  {string} num Bit string to be transformed\n     * @returns {Snowflake}\n     * @private\n     */\n\n  }, {\n    key: \"binaryToID\",\n    value: function binaryToID(num) {\n      var dec = '';\n\n      while (num.length > 50) {\n        var high = parseInt(num.slice(0, -32), 2);\n        var low = parseInt((high % 10).toString(2) + num.slice(-32), 2);\n        dec = (low % 10).toString() + dec;\n        num = Math.floor(high / 10).toString(2) + Math.floor(low / 10).toString(2).padStart(32, '0');\n      }\n\n      num = parseInt(num, 2);\n\n      while (num > 0) {\n        dec = (num % 10).toString() + dec;\n        num = Math.floor(num / 10);\n      }\n\n      return dec;\n    }\n    /**\n     * Breaks user, role and everyone/here mentions by adding a zero width space after every @ character\n     * @param {string} str The string to sanitize\n     * @returns {string}\n     */\n\n  }, {\n    key: \"removeMentions\",\n    value: function removeMentions(str) {\n      return str.replace(/@/g, \"@\\u200B\");\n    }\n    /**\n     * The content to have all mentions replaced by the equivalent text.\n     * @param {string} str The string to be converted\n     * @param {Message} message The message object to reference\n     * @returns {string}\n     */\n\n  }, {\n    key: \"cleanContent\",\n    value: function cleanContent(str, message) {\n      str = str.replace(/<@!?[0-9]+>/g, function (input) {\n        var id = input.replace(/<|!|>|@/g, '');\n\n        if (message.channel.type === 'dm') {\n          var user = message.client.users.cache.get(id);\n          return user ? \"@\".concat(user.username) : input;\n        }\n\n        var member = message.channel.guild.members.cache.get(id);\n\n        if (member) {\n          return \"@\".concat(member.displayName);\n        } else {\n          var _user = message.client.users.cache.get(id);\n\n          return _user ? \"@\".concat(_user.username) : input;\n        }\n      }).replace(/<#[0-9]+>/g, function (input) {\n        var channel = message.client.channels.cache.get(input.replace(/<|#|>/g, ''));\n        return channel ? \"#\".concat(channel.name) : input;\n      }).replace(/<@&[0-9]+>/g, function (input) {\n        if (message.channel.type === 'dm') return input;\n        var role = message.guild.roles.cache.get(input.replace(/<|@|>|&/g, ''));\n        return role ? \"@\".concat(role.name) : input;\n      });\n\n      if (message.client.options.disableMentions === 'everyone') {\n        str = str.replace(/@((?:[\\0-\\x1F!-;=\\?A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*)/gm, function (match, target) {\n          if (target.match(/^[&!]?\\d+$/)) {\n            return \"@\".concat(target);\n          } else {\n            return \"@\\u200B\".concat(target);\n          }\n        });\n      }\n\n      if (message.client.options.disableMentions === 'all') {\n        return Util.removeMentions(str);\n      } else {\n        return str;\n      }\n    }\n    /**\n     * The content to put in a codeblock with all codeblock fences replaced by the equivalent backticks.\n     * @param {string} text The string to be converted\n     * @returns {string}\n     */\n\n  }, {\n    key: \"cleanCodeBlockContent\",\n    value: function cleanCodeBlockContent(text) {\n      return text.replace(/```/g, \"`\\u200B``\");\n    }\n    /**\n     * Creates a Promise that resolves after a specified duration.\n     * @param {number} ms How long to wait before resolving (in milliseconds)\n     * @returns {Promise<void>}\n     * @private\n     */\n\n  }, {\n    key: \"delayFor\",\n    value: function delayFor(ms) {\n      return new Promise(function (resolve) {\n        setTimeout(resolve, ms);\n      });\n    }\n  }]);\n\n  return Util;\n}();\n\nmodule.exports = Util;","map":null,"metadata":{},"sourceType":"module"}