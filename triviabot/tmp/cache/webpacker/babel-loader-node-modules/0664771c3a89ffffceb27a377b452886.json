{"ast":null,"code":"'use strict';\n\nfunction _createForOfIteratorHelper(o) { if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar https = require('https');\n\nvar FormData = require('@discordjs/form-data');\n\nvar AbortController = require('abort-controller');\n\nvar fetch = require('node-fetch');\n\nvar _require = require('../util/Constants'),\n    browser = _require.browser,\n    UserAgent = _require.UserAgent;\n\nif (https.Agent) var agent = new https.Agent({\n  keepAlive: true\n});\n\nvar APIRequest = /*#__PURE__*/function () {\n  function APIRequest(rest, method, path, options) {\n    _classCallCheck(this, APIRequest);\n\n    this.rest = rest;\n    this.client = rest.client;\n    this.method = method;\n    this.route = options.route;\n    this.options = options;\n    var queryString = '';\n\n    if (options.query) {\n      // Filter out undefined query options\n      var query = Object.entries(options.query).filter(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            value = _ref2[1];\n\n        return value !== null && typeof value !== 'undefined';\n      });\n      queryString = new URLSearchParams(query).toString();\n    }\n\n    this.path = \"\".concat(path).concat(queryString && \"?\".concat(queryString));\n  }\n\n  _createClass(APIRequest, [{\n    key: \"make\",\n    value: function make() {\n      var _this = this;\n\n      var API = this.options.versioned === false ? this.client.options.http.api : \"\".concat(this.client.options.http.api, \"/v\").concat(this.client.options.http.version);\n      var url = API + this.path;\n      var headers = {};\n      if (this.options.auth !== false) headers.Authorization = this.rest.getAuth();\n      if (this.options.reason) headers['X-Audit-Log-Reason'] = encodeURIComponent(this.options.reason);\n      if (!browser) headers['User-Agent'] = UserAgent;\n      if (this.options.headers) headers = Object.assign(headers, this.options.headers);\n      var body;\n\n      if (this.options.files && this.options.files.length) {\n        body = new FormData();\n\n        var _iterator = _createForOfIteratorHelper(this.options.files),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var file = _step.value;\n            if (file && file.file) body.append(file.name, file.file, file.name);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        if (typeof this.options.data !== 'undefined') body.append('payload_json', JSON.stringify(this.options.data));\n        if (!browser) headers = Object.assign(headers, body.getHeaders()); // eslint-disable-next-line eqeqeq\n      } else if (this.options.data != null) {\n        body = JSON.stringify(this.options.data);\n        headers['Content-Type'] = 'application/json';\n      }\n\n      var controller = new AbortController();\n      var timeout = this.client.setTimeout(function () {\n        return controller.abort();\n      }, this.client.options.restRequestTimeout);\n      return fetch(url, {\n        method: this.method,\n        headers: headers,\n        agent: agent,\n        body: body,\n        signal: controller.signal\n      })[\"finally\"](function () {\n        return _this.client.clearTimeout(timeout);\n      });\n    }\n  }]);\n\n  return APIRequest;\n}();\n\nmodule.exports = APIRequest;","map":null,"metadata":{},"sourceType":"module"}