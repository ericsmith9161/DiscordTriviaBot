{"ast":null,"code":"'use strict';\n\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _createForOfIteratorHelper(o) { if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function () { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar Channel = require('./Channel');\n\nvar Invite = require('./Invite');\n\nvar PermissionOverwrites = require('./PermissionOverwrites');\n\nvar Role = require('./Role');\n\nvar _require = require('../errors'),\n    Error = _require.Error,\n    _TypeError = _require.TypeError;\n\nvar Collection = require('../util/Collection');\n\nvar Permissions = require('../util/Permissions');\n\nvar Util = require('../util/Util');\n/**\n * Represents a guild channel from any of the following:\n * - {@link TextChannel}\n * - {@link VoiceChannel}\n * - {@link CategoryChannel}\n * - {@link NewsChannel}\n * - {@link StoreChannel}\n * @extends {Channel}\n */\n\n\nvar GuildChannel = /*#__PURE__*/function (_Channel) {\n  _inherits(GuildChannel, _Channel);\n\n  var _super = _createSuper(GuildChannel);\n\n  /**\n   * @param {Guild} guild The guild the guild channel is part of\n   * @param {Object} data The data for the guild channel\n   */\n  function GuildChannel(guild, data) {\n    var _this;\n\n    _classCallCheck(this, GuildChannel);\n\n    _this = _super.call(this, guild.client, data);\n    /**\n     * The guild the channel is in\n     * @type {Guild}\n     */\n\n    _this.guild = guild;\n    return _this;\n  }\n\n  _createClass(GuildChannel, [{\n    key: \"_patch\",\n    value: function _patch(data) {\n      _get(_getPrototypeOf(GuildChannel.prototype), \"_patch\", this).call(this, data);\n      /**\n       * The name of the guild channel\n       * @type {string}\n       */\n\n\n      this.name = data.name;\n      /**\n       * The raw position of the channel from discord\n       * @type {number}\n       */\n\n      this.rawPosition = data.position;\n      /**\n       * The ID of the category parent of this channel\n       * @type {?Snowflake}\n       */\n\n      this.parentID = data.parent_id;\n      /**\n       * A map of permission overwrites in this channel for roles and users\n       * @type {Collection<Snowflake, PermissionOverwrites>}\n       */\n\n      this.permissionOverwrites = new Collection();\n\n      if (data.permission_overwrites) {\n        var _iterator = _createForOfIteratorHelper(data.permission_overwrites),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var overwrite = _step.value;\n            this.permissionOverwrites.set(overwrite.id, new PermissionOverwrites(this, overwrite));\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n    }\n    /**\n     * The category parent of this channel\n     * @type {?CategoryChannel}\n     * @readonly\n     */\n\n  }, {\n    key: \"permissionsFor\",\n\n    /**\n     * Gets the overall set of permissions for a member or role in this channel, taking into account channel overwrites.\n     * @param {GuildMemberResolvable|RoleResolvable} memberOrRole The member or role to obtain the overall permissions for\n     * @returns {?Readonly<Permissions>}\n     */\n    value: function permissionsFor(memberOrRole) {\n      var member = this.guild.members.resolve(memberOrRole);\n      if (member) return this.memberPermissions(member);\n      var role = this.guild.roles.resolve(memberOrRole);\n      if (role) return this.rolePermissions(role);\n      return null;\n    }\n  }, {\n    key: \"overwritesFor\",\n    value: function overwritesFor(member) {\n      var verified = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var roles = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      if (!verified) member = this.guild.members.resolve(member);\n      if (!member) return [];\n      roles = roles || member.roles.cache;\n      var roleOverwrites = [];\n      var memberOverwrites;\n      var everyoneOverwrites;\n\n      var _iterator2 = _createForOfIteratorHelper(this.permissionOverwrites.values()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var overwrite = _step2.value;\n\n          if (overwrite.id === this.guild.id) {\n            everyoneOverwrites = overwrite;\n          } else if (roles.has(overwrite.id)) {\n            roleOverwrites.push(overwrite);\n          } else if (overwrite.id === member.id) {\n            memberOverwrites = overwrite;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return {\n        everyone: everyoneOverwrites,\n        roles: roleOverwrites,\n        member: memberOverwrites\n      };\n    }\n    /**\n     * Gets the overall set of permissions for a member in this channel, taking into account channel overwrites.\n     * @param {GuildMember} member The member to obtain the overall permissions for\n     * @returns {Readonly<Permissions>}\n     * @private\n     */\n\n  }, {\n    key: \"memberPermissions\",\n    value: function memberPermissions(member) {\n      if (member.id === this.guild.ownerID) return new Permissions(Permissions.ALL).freeze();\n      var roles = member.roles.cache;\n      var permissions = new Permissions(roles.map(function (role) {\n        return role.permissions;\n      }));\n      if (permissions.has(Permissions.FLAGS.ADMINISTRATOR)) return new Permissions(Permissions.ALL).freeze();\n      var overwrites = this.overwritesFor(member, true, roles);\n      return permissions.remove(overwrites.everyone ? overwrites.everyone.deny : 0).add(overwrites.everyone ? overwrites.everyone.allow : 0).remove(overwrites.roles.length > 0 ? overwrites.roles.map(function (role) {\n        return role.deny;\n      }) : 0).add(overwrites.roles.length > 0 ? overwrites.roles.map(function (role) {\n        return role.allow;\n      }) : 0).remove(overwrites.member ? overwrites.member.deny : 0).add(overwrites.member ? overwrites.member.allow : 0).freeze();\n    }\n    /**\n     * Gets the overall set of permissions for a role in this channel, taking into account channel overwrites.\n     * @param {Role} role The role to obtain the overall permissions for\n     * @returns {Readonly<Permissions>}\n     * @private\n     */\n\n  }, {\n    key: \"rolePermissions\",\n    value: function rolePermissions(role) {\n      if (role.permissions.has(Permissions.FLAGS.ADMINISTRATOR)) return new Permissions(Permissions.ALL).freeze();\n      var everyoneOverwrites = this.permissionOverwrites.get(this.guild.id);\n      var roleOverwrites = this.permissionOverwrites.get(role.id);\n      return role.permissions.remove(everyoneOverwrites ? everyoneOverwrites.deny : 0).add(everyoneOverwrites ? everyoneOverwrites.allow : 0).remove(roleOverwrites ? roleOverwrites.deny : 0).add(roleOverwrites ? roleOverwrites.allow : 0).freeze();\n    }\n    /**\n     * Replaces the permission overwrites in this channel.\n     * @param {OverwriteResolvable[]|Collection<Snowflake, OverwriteResolvable>} overwrites\n     * Permission overwrites the channel gets updated with\n     * @param {string} [reason] Reason for updating the channel overwrites\n     * @returns {Promise<GuildChannel>}\n     * @example\n     * channel.overwritePermissions([\n     *   {\n     *      id: message.author.id,\n     *      deny: ['VIEW_CHANNEL'],\n     *   },\n     * ], 'Needed to change permissions');\n     */\n\n  }, {\n    key: \"overwritePermissions\",\n    value: function overwritePermissions(overwrites, reason) {\n      var _this2 = this;\n\n      if (!Array.isArray(overwrites) && !(overwrites instanceof Collection)) {\n        return Promise.reject(new _TypeError('INVALID_TYPE', 'overwrites', 'Array or Collection of Permission Overwrites', true));\n      }\n\n      return this.edit({\n        permissionOverwrites: overwrites,\n        reason: reason\n      }).then(function () {\n        return _this2;\n      });\n    }\n    /**\n     * Updates Overwrites for a user or role in this channel. (creates if non-existent)\n     * @param {RoleResolvable|UserResolvable} userOrRole The user or role to update\n     * @param {PermissionOverwriteOptions} options The options for the update\n     * @param {string} [reason] Reason for creating/editing this overwrite\n     * @returns {Promise<GuildChannel>}\n     * @example\n     * // Update or Create permission overwrites for a message author\n     * message.channel.updateOverwrite(message.author, {\n     *   SEND_MESSAGES: false\n     * })\n     *   .then(channel => console.log(channel.permissionOverwrites.get(message.author.id)))\n     *   .catch(console.error);\n     */\n\n  }, {\n    key: \"updateOverwrite\",\n    value: function updateOverwrite(userOrRole, options, reason) {\n      var _this3 = this;\n\n      userOrRole = this.guild.roles.resolve(userOrRole) || this.client.users.resolve(userOrRole);\n      if (!userOrRole) return Promise.reject(new _TypeError('INVALID_TYPE', 'parameter', 'User nor a Role', true));\n      var existing = this.permissionOverwrites.get(userOrRole.id);\n      if (existing) return existing.update(options, reason).then(function () {\n        return _this3;\n      });\n      return this.createOverwrite(userOrRole, options, reason);\n    }\n    /**\n     * Overwrites the permissions for a user or role in this channel. (replaces if existent)\n     * @param {RoleResolvable|UserResolvable} userOrRole The user or role to update\n     * @param {PermissionOverwriteOptions} options The options for the update\n     * @param {string} [reason] Reason for creating/editing this overwrite\n     * @returns {Promise<GuildChannel>}\n     * @example\n     * // Create or Replace permissions overwrites for a message author\n     * message.channel.createOverwrite(message.author, {\n     *   SEND_MESSAGES: false\n     * })\n     *   .then(channel => console.log(channel.permissionOverwrites.get(message.author.id)))\n     *   .catch(console.error);\n     */\n\n  }, {\n    key: \"createOverwrite\",\n    value: function createOverwrite(userOrRole, options, reason) {\n      var _this4 = this;\n\n      userOrRole = this.guild.roles.resolve(userOrRole) || this.client.users.resolve(userOrRole);\n      if (!userOrRole) return Promise.reject(new _TypeError('INVALID_TYPE', 'parameter', 'User nor a Role', true));\n      var type = userOrRole instanceof Role ? 'role' : 'member';\n\n      var _PermissionOverwrites = PermissionOverwrites.resolveOverwriteOptions(options),\n          allow = _PermissionOverwrites.allow,\n          deny = _PermissionOverwrites.deny;\n\n      return this.client.api.channels(this.id).permissions[userOrRole.id].put({\n        data: {\n          id: userOrRole.id,\n          type: type,\n          allow: allow.bitfield,\n          deny: deny.bitfield\n        },\n        reason: reason\n      }).then(function () {\n        return _this4;\n      });\n    }\n    /**\n     * Locks in the permission overwrites from the parent channel.\n     * @returns {Promise<GuildChannel>}\n     */\n\n  }, {\n    key: \"lockPermissions\",\n    value: function lockPermissions() {\n      if (!this.parent) return Promise.reject(new Error('GUILD_CHANNEL_ORPHAN'));\n      var permissionOverwrites = this.parent.permissionOverwrites.map(function (overwrite) {\n        return overwrite.toJSON();\n      });\n      return this.edit({\n        permissionOverwrites: permissionOverwrites\n      });\n    }\n    /**\n     * A collection of members that can see this channel, mapped by their ID\n     * @type {Collection<Snowflake, GuildMember>}\n     * @readonly\n     */\n\n  }, {\n    key: \"edit\",\n\n    /**\n     * The data for a guild channel.\n     * @typedef {Object} ChannelData\n     * @property {string} [name] The name of the channel\n     * @property {number} [position] The position of the channel\n     * @property {string} [topic] The topic of the text channel\n     * @property {boolean} [nsfw] Whether the channel is NSFW\n     * @property {number} [bitrate] The bitrate of the voice channel\n     * @property {number} [userLimit] The user limit of the voice channel\n     * @property {Snowflake} [parentID] The parent ID of the channel\n     * @property {boolean} [lockPermissions]\n     * Lock the permissions of the channel to what the parent's permissions are\n     * @property {OverwriteResolvable[]|Collection<Snowflake, OverwriteResolvable>} [permissionOverwrites]\n     * Permission overwrites for the channel\n     * @property {number} [rateLimitPerUser] The ratelimit per user for the channel in seconds\n     */\n\n    /**\n     * Edits the channel.\n     * @param {ChannelData} data The new data for the channel\n     * @param {string} [reason] Reason for editing this channel\n     * @returns {Promise<GuildChannel>}\n     * @example\n     * // Edit a channel\n     * channel.edit({ name: 'new-channel' })\n     *   .then(console.log)\n     *   .catch(console.error);\n     */\n    value: function () {\n      var _edit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(data, reason) {\n        var _this5 = this;\n\n        var permission_overwrites, newData, clone;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(typeof data.position !== 'undefined')) {\n                  _context.next = 3;\n                  break;\n                }\n\n                _context.next = 3;\n                return Util.setPosition(this, data.position, false, this.guild._sortedChannels(this), this.client.api.guilds(this.guild.id).channels, reason).then(function (updatedChannels) {\n                  _this5.client.actions.GuildChannelsPositionUpdate.handle({\n                    guild_id: _this5.guild.id,\n                    channels: updatedChannels\n                  });\n                });\n\n              case 3:\n                permission_overwrites = data.permissionOverwrites && data.permissionOverwrites.map(function (o) {\n                  return PermissionOverwrites.resolve(o, _this5.guild);\n                });\n                _context.next = 6;\n                return this.client.api.channels(this.id).patch({\n                  data: {\n                    name: (data.name || this.name).trim(),\n                    topic: data.topic,\n                    nsfw: data.nsfw,\n                    bitrate: data.bitrate || this.bitrate,\n                    user_limit: typeof data.userLimit !== 'undefined' ? data.userLimit : this.userLimit,\n                    parent_id: data.parentID,\n                    lock_permissions: data.lockPermissions,\n                    rate_limit_per_user: data.rateLimitPerUser,\n                    permission_overwrites: permission_overwrites\n                  },\n                  reason: reason\n                });\n\n              case 6:\n                newData = _context.sent;\n                clone = this._clone();\n\n                clone._patch(newData);\n\n                return _context.abrupt(\"return\", clone);\n\n              case 10:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function edit(_x, _x2) {\n        return _edit.apply(this, arguments);\n      }\n\n      return edit;\n    }()\n    /**\n     * Sets a new name for the guild channel.\n     * @param {string} name The new name for the guild channel\n     * @param {string} [reason] Reason for changing the guild channel's name\n     * @returns {Promise<GuildChannel>}\n     * @example\n     * // Set a new channel name\n     * channel.setName('not_general')\n     *   .then(newChannel => console.log(`Channel's new name is ${newChannel.name}`))\n     *   .catch(console.error);\n     */\n\n  }, {\n    key: \"setName\",\n    value: function setName(name, reason) {\n      return this.edit({\n        name: name\n      }, reason);\n    }\n    /**\n     * Sets the category parent of this channel.\n     * @param {?CategoryChannel|Snowflake} channel Parent channel\n     * @param {Object} [options={}] Options to pass\n     * @param {boolean} [options.lockPermissions=true] Lock the permissions to what the parent's permissions are\n     * @param {string} [options.reason] Reason for modifying the parent of this channel\n     * @returns {Promise<GuildChannel>}\n     * @example\n     * // Add a parent to a channel\n     * message.channel.setParent('355908108431917066', { lockPermissions: false })\n     *   .then(channel => console.log(`New parent of ${message.channel.name}: ${channel.name}`))\n     *   .catch(console.error);\n     */\n\n  }, {\n    key: \"setParent\",\n    value: function setParent(channel) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref$lockPermissions = _ref.lockPermissions,\n          lockPermissions = _ref$lockPermissions === void 0 ? true : _ref$lockPermissions,\n          reason = _ref.reason;\n\n      return this.edit({\n        // eslint-disable-next-line no-prototype-builtins\n        parentID: channel !== null ? channel.hasOwnProperty('id') ? channel.id : channel : null,\n        lockPermissions: lockPermissions\n      }, reason);\n    }\n    /**\n     * Sets a new topic for the guild channel.\n     * @param {string} topic The new topic for the guild channel\n     * @param {string} [reason] Reason for changing the guild channel's topic\n     * @returns {Promise<GuildChannel>}\n     * @example\n     * // Set a new channel topic\n     * channel.setTopic('needs more rate limiting')\n     *   .then(newChannel => console.log(`Channel's new topic is ${newChannel.topic}`))\n     *   .catch(console.error);\n     */\n\n  }, {\n    key: \"setTopic\",\n    value: function setTopic(topic, reason) {\n      return this.edit({\n        topic: topic\n      }, reason);\n    }\n    /**\n     * Sets a new position for the guild channel.\n     * @param {number} position The new position for the guild channel\n     * @param {Object} [options] Options for setting position\n     * @param {boolean} [options.relative=false] Change the position relative to its current value\n     * @param {string} [options.reason] Reason for changing the position\n     * @returns {Promise<GuildChannel>}\n     * @example\n     * // Set a new channel position\n     * channel.setPosition(2)\n     *   .then(newChannel => console.log(`Channel's new position is ${newChannel.position}`))\n     *   .catch(console.error);\n     */\n\n  }, {\n    key: \"setPosition\",\n    value: function setPosition(position) {\n      var _this6 = this;\n\n      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          relative = _ref2.relative,\n          reason = _ref2.reason;\n\n      return Util.setPosition(this, position, relative, this.guild._sortedChannels(this), this.client.api.guilds(this.guild.id).channels, reason).then(function (updatedChannels) {\n        _this6.client.actions.GuildChannelsPositionUpdate.handle({\n          guild_id: _this6.guild.id,\n          channels: updatedChannels\n        });\n\n        return _this6;\n      });\n    }\n    /**\n     * Creates an invite to this guild channel.\n     * @param {Object} [options={}] Options for the invite\n     * @param {boolean} [options.temporary=false] Whether members that joined via the invite should be automatically\n     * kicked after 24 hours if they have not yet received a role\n     * @param {number} [options.maxAge=86400] How long the invite should last (in seconds, 0 for forever)\n     * @param {number} [options.maxUses=0] Maximum number of uses\n     * @param {boolean} [options.unique=false] Create a unique invite, or use an existing one with similar settings\n     * @param {string} [options.reason] Reason for creating this\n     * @returns {Promise<Invite>}\n     * @example\n     * // Create an invite to a channel\n     * channel.createInvite()\n     *   .then(invite => console.log(`Created an invite with a code of ${invite.code}`))\n     *   .catch(console.error);\n     */\n\n  }, {\n    key: \"createInvite\",\n    value: function createInvite() {\n      var _this7 = this;\n\n      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref3$temporary = _ref3.temporary,\n          temporary = _ref3$temporary === void 0 ? false : _ref3$temporary,\n          _ref3$maxAge = _ref3.maxAge,\n          maxAge = _ref3$maxAge === void 0 ? 86400 : _ref3$maxAge,\n          _ref3$maxUses = _ref3.maxUses,\n          maxUses = _ref3$maxUses === void 0 ? 0 : _ref3$maxUses,\n          unique = _ref3.unique,\n          reason = _ref3.reason;\n\n      return this.client.api.channels(this.id).invites.post({\n        data: {\n          temporary: temporary,\n          max_age: maxAge,\n          max_uses: maxUses,\n          unique: unique\n        },\n        reason: reason\n      }).then(function (invite) {\n        return new Invite(_this7.client, invite);\n      });\n    }\n    /**\n     * Fetches a collection of invites to this guild channel.\n     * Resolves with a collection mapping invites by their codes.\n     * @returns {Promise<Collection<string, Invite>>}\n     */\n\n  }, {\n    key: \"fetchInvites\",\n    value: function () {\n      var _fetchInvites = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var inviteItems, invites, _iterator3, _step3, inviteItem, invite;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.client.api.channels(this.id).invites.get();\n\n              case 2:\n                inviteItems = _context2.sent;\n                invites = new Collection();\n                _iterator3 = _createForOfIteratorHelper(inviteItems);\n\n                try {\n                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                    inviteItem = _step3.value;\n                    invite = new Invite(this.client, inviteItem);\n                    invites.set(invite.code, invite);\n                  }\n                } catch (err) {\n                  _iterator3.e(err);\n                } finally {\n                  _iterator3.f();\n                }\n\n                return _context2.abrupt(\"return\", invites);\n\n              case 7:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function fetchInvites() {\n        return _fetchInvites.apply(this, arguments);\n      }\n\n      return fetchInvites;\n    }()\n    /* eslint-disable max-len */\n\n    /**\n     * Clones this channel.\n     * @param {Object} [options] The options\n     * @param {string} [options.name=this.name] Name of the new channel\n     * @param {OverwriteResolvable[]|Collection<Snowflake, OverwriteResolvable>} [options.permissionOverwrites=this.permissionOverwrites]\n     * Permission overwrites of the new channel\n     * @param {string} [options.type=this.type] Type of the new channel\n     * @param {string} [options.topic=this.topic] Topic of the new channel (only text)\n     * @param {boolean} [options.nsfw=this.nsfw] Whether the new channel is nsfw (only text)\n     * @param {number} [options.bitrate=this.bitrate] Bitrate of the new channel in bits (only voice)\n     * @param {number} [options.userLimit=this.userLimit] Maximum amount of users allowed in the new channel (only voice)\n     * @param {number} [options.rateLimitPerUser=ThisType.rateLimitPerUser] Ratelimit per user for the new channel (only text)\n     * @param {ChannelResolvable} [options.parent=this.parent] Parent of the new channel\n     * @param {string} [options.reason] Reason for cloning this channel\n     * @returns {Promise<GuildChannel>}\n     */\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      Util.mergeDefault({\n        name: this.name,\n        permissionOverwrites: this.permissionOverwrites,\n        topic: this.topic,\n        type: this.type,\n        nsfw: this.nsfw,\n        parent: this.parent,\n        bitrate: this.bitrate,\n        userLimit: this.userLimit,\n        rateLimitPerUser: this.rateLimitPerUser,\n        reason: null\n      }, options);\n      return this.guild.channels.create(options.name, options);\n    }\n    /* eslint-enable max-len */\n\n    /**\n     * Checks if this channel has the same type, topic, position, name, overwrites and ID as another channel.\n     * In most cases, a simple `channel.id === channel2.id` will do, and is much faster too.\n     * @param {GuildChannel} channel Channel to compare with\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"equals\",\n    value: function equals(channel) {\n      var equal = channel && this.id === channel.id && this.type === channel.type && this.topic === channel.topic && this.position === channel.position && this.name === channel.name;\n\n      if (equal) {\n        if (this.permissionOverwrites && channel.permissionOverwrites) {\n          equal = this.permissionOverwrites.equals(channel.permissionOverwrites);\n        } else {\n          equal = !this.permissionOverwrites && !channel.permissionOverwrites;\n        }\n      }\n\n      return equal;\n    }\n    /**\n     * Whether the channel is deletable by the client user\n     * @type {boolean}\n     * @readonly\n     */\n\n  }, {\n    key: \"delete\",\n\n    /**\n     * Deletes this channel.\n     * @param {string} [reason] Reason for deleting this channel\n     * @returns {Promise<GuildChannel>}\n     * @example\n     * // Delete the channel\n     * channel.delete('making room for new channels')\n     *   .then(console.log)\n     *   .catch(console.error);\n     */\n    value: function _delete(reason) {\n      var _this8 = this;\n\n      return this.client.api.channels(this.id)[\"delete\"]({\n        reason: reason\n      }).then(function () {\n        return _this8;\n      });\n    }\n  }, {\n    key: \"parent\",\n    get: function get() {\n      return this.guild.channels.cache.get(this.parentID) || null;\n    }\n    /**\n     * If the permissionOverwrites match the parent channel, null if no parent\n     * @type {?boolean}\n     * @readonly\n     */\n\n  }, {\n    key: \"permissionsLocked\",\n    get: function get() {\n      var _this9 = this;\n\n      if (!this.parent) return null;\n      if (this.permissionOverwrites.size !== this.parent.permissionOverwrites.size) return false;\n      return this.permissionOverwrites.every(function (value, key) {\n        var testVal = _this9.parent.permissionOverwrites.get(key);\n\n        return testVal !== undefined && testVal.deny.bitfield === value.deny.bitfield && testVal.allow.bitfield === value.allow.bitfield;\n      });\n    }\n    /**\n     * The position of the channel\n     * @type {number}\n     * @readonly\n     */\n\n  }, {\n    key: \"position\",\n    get: function get() {\n      var sorted = this.guild._sortedChannels(this);\n\n      return sorted.array().indexOf(sorted.get(this.id));\n    }\n  }, {\n    key: \"members\",\n    get: function get() {\n      var members = new Collection();\n\n      var _iterator4 = _createForOfIteratorHelper(this.guild.members.cache.values()),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var member = _step4.value;\n\n          if (this.permissionsFor(member).has('VIEW_CHANNEL', false)) {\n            members.set(member.id, member);\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      return members;\n    }\n  }, {\n    key: \"deletable\",\n    get: function get() {\n      return this.permissionsFor(this.client.user).has(Permissions.FLAGS.MANAGE_CHANNELS, false);\n    }\n    /**\n     * Whether the channel is manageable by the client user\n     * @type {boolean}\n     * @readonly\n     */\n\n  }, {\n    key: \"manageable\",\n    get: function get() {\n      if (this.client.user.id === this.guild.ownerID) return true;\n\n      if (this.type === 'voice') {\n        if (!this.permissionsFor(this.client.user).has(Permissions.FLAGS.CONNECT, false)) {\n          return false;\n        }\n      } else if (!this.viewable) {\n        return false;\n      }\n\n      return this.permissionsFor(this.client.user).has(Permissions.FLAGS.MANAGE_CHANNELS, false);\n    }\n    /**\n     * Whether the channel is viewable by the client user\n     * @type {boolean}\n     * @readonly\n     */\n\n  }, {\n    key: \"viewable\",\n    get: function get() {\n      if (this.client.user.id === this.guild.ownerID) return true;\n      var permissions = this.permissionsFor(this.client.user);\n      if (!permissions) return false;\n      return permissions.has(Permissions.FLAGS.VIEW_CHANNEL, false);\n    }\n  }]);\n\n  return GuildChannel;\n}(Channel);\n\nmodule.exports = GuildChannel;","map":null,"metadata":{},"sourceType":"module"}