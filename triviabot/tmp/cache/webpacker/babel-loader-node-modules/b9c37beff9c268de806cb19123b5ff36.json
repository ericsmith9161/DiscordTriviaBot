{"ast":null,"code":"'use strict';\n\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _createForOfIteratorHelper(o) { if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar MessageAttachment = require('./MessageAttachment');\n\nvar MessageEmbed = require('./MessageEmbed');\n\nvar _require = require('../errors'),\n    RangeError = _require.RangeError;\n\nvar _require2 = require('../util/Constants'),\n    browser = _require2.browser;\n\nvar DataResolver = require('../util/DataResolver');\n\nvar MessageFlags = require('../util/MessageFlags');\n\nvar Util = require('../util/Util');\n/**\n * Represents a message to be sent to the API.\n */\n\n\nvar APIMessage = /*#__PURE__*/function () {\n  /**\n   * @param {MessageTarget} target - The target for this message to be sent to\n   * @param {MessageOptions|WebhookMessageOptions} options - Options passed in from send\n   */\n  function APIMessage(target, options) {\n    _classCallCheck(this, APIMessage);\n\n    /**\n     * The target for this message to be sent to\n     * @type {MessageTarget}\n     */\n    this.target = target;\n    /**\n     * Options passed in from send\n     * @type {MessageOptions|WebhookMessageOptions}\n     */\n\n    this.options = options;\n    /**\n     * Data sendable to the API\n     * @type {?Object}\n     */\n\n    this.data = null;\n    /**\n     * Files sendable to the API\n     * @type {?Object[]}\n     */\n\n    this.files = null;\n  }\n  /**\n   * Whether or not the target is a webhook\n   * @type {boolean}\n   * @readonly\n   */\n\n\n  _createClass(APIMessage, [{\n    key: \"makeContent\",\n\n    /**\n     * Makes the content of this message.\n     * @returns {?(string|string[])}\n     */\n    value: function makeContent() {\n      var GuildMember = require('./GuildMember');\n\n      var content;\n\n      if (this.options.content === null) {\n        content = '';\n      } else if (typeof this.options.content !== 'undefined') {\n        content = Util.resolveString(this.options.content);\n      }\n\n      var disableMentions = typeof this.options.disableMentions === 'undefined' ? this.target.client.options.disableMentions : this.options.disableMentions;\n\n      if (disableMentions === 'all') {\n        content = Util.removeMentions(content || '');\n      } else if (disableMentions === 'everyone') {\n        content = (content || '').replace(/@((?:[\\0-\\x1F!-;=\\?A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*)/gm, function (match, target) {\n          if (target.match(/^[&!]?\\d+$/)) {\n            return \"@\".concat(target);\n          } else {\n            return \"@\\u200B\".concat(target);\n          }\n        });\n      }\n\n      var isSplit = typeof this.options.split !== 'undefined' && this.options.split !== false;\n      var isCode = typeof this.options.code !== 'undefined' && this.options.code !== false;\n      var splitOptions = isSplit ? _objectSpread({}, this.options.split) : undefined;\n      var mentionPart = '';\n\n      if (this.options.reply && !this.isUser && this.target.type !== 'dm') {\n        var id = this.target.client.users.resolveID(this.options.reply);\n        mentionPart = \"<@\".concat(this.options.reply instanceof GuildMember && this.options.reply.nickname ? '!' : '').concat(id, \">, \");\n\n        if (isSplit) {\n          splitOptions.prepend = \"\".concat(mentionPart).concat(splitOptions.prepend || '');\n        }\n      }\n\n      if (content || mentionPart) {\n        if (isCode) {\n          var codeName = typeof this.options.code === 'string' ? this.options.code : '';\n          content = \"\".concat(mentionPart, \"```\").concat(codeName, \"\\n\").concat(Util.cleanCodeBlockContent(content || ''), \"\\n```\");\n\n          if (isSplit) {\n            splitOptions.prepend = \"\".concat(splitOptions.prepend || '', \"```\").concat(codeName, \"\\n\");\n            splitOptions.append = \"\\n```\".concat(splitOptions.append || '');\n          }\n        } else if (mentionPart) {\n          content = \"\".concat(mentionPart).concat(content || '');\n        }\n\n        if (isSplit) {\n          content = Util.splitMessage(content || '', splitOptions);\n        }\n      }\n\n      return content;\n    }\n    /**\n     * Resolves data.\n     * @returns {APIMessage}\n     */\n\n  }, {\n    key: \"resolveData\",\n    value: function resolveData() {\n      if (this.data) return this;\n      var content = this.makeContent();\n      var tts = Boolean(this.options.tts);\n      var nonce;\n\n      if (typeof this.options.nonce !== 'undefined') {\n        nonce = parseInt(this.options.nonce);\n        if (isNaN(nonce) || nonce < 0) throw new RangeError('MESSAGE_NONCE_TYPE');\n      }\n\n      var embedLikes = [];\n\n      if (this.isWebhook) {\n        if (this.options.embeds) {\n          embedLikes.push.apply(embedLikes, _toConsumableArray(this.options.embeds));\n        }\n      } else if (this.options.embed) {\n        embedLikes.push(this.options.embed);\n      }\n\n      var embeds = embedLikes.map(function (e) {\n        return new MessageEmbed(e).toJSON();\n      });\n      var username;\n      var avatarURL;\n\n      if (this.isWebhook) {\n        username = this.options.username || this.target.name;\n        if (this.options.avatarURL) avatarURL = this.options.avatarURL;\n      }\n\n      var flags;\n\n      if (this.isMessage) {\n        // eslint-disable-next-line eqeqeq\n        flags = this.options.flags != null ? new MessageFlags(this.options.flags).bitfield : this.target.flags.bitfield;\n      }\n\n      var allowedMentions = typeof this.options.allowedMentions === 'undefined' ? this.target.client.options.allowedMentions : this.options.allowedMentions;\n      this.data = {\n        content: content,\n        tts: tts,\n        nonce: nonce,\n        embed: this.options.embed === null ? null : embeds[0],\n        embeds: embeds,\n        username: username,\n        avatar_url: avatarURL,\n        allowed_mentions: allowedMentions,\n        flags: flags\n      };\n      return this;\n    }\n    /**\n     * Resolves files.\n     * @returns {Promise<APIMessage>}\n     */\n\n  }, {\n    key: \"resolveFiles\",\n    value: function () {\n      var _resolveFiles = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this = this;\n\n        var embedLikes, fileLikes, _i, _embedLikes, embed;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this.files) {\n                  _context.next = 2;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", this);\n\n              case 2:\n                embedLikes = [];\n\n                if (this.isWebhook) {\n                  if (this.options.embeds) {\n                    embedLikes.push.apply(embedLikes, _toConsumableArray(this.options.embeds));\n                  }\n                } else if (this.options.embed) {\n                  embedLikes.push(this.options.embed);\n                }\n\n                fileLikes = [];\n\n                if (this.options.files) {\n                  fileLikes.push.apply(fileLikes, _toConsumableArray(this.options.files));\n                }\n\n                for (_i = 0, _embedLikes = embedLikes; _i < _embedLikes.length; _i++) {\n                  embed = _embedLikes[_i];\n\n                  if (embed.files) {\n                    fileLikes.push.apply(fileLikes, _toConsumableArray(embed.files));\n                  }\n                }\n\n                _context.next = 9;\n                return Promise.all(fileLikes.map(function (f) {\n                  return _this.constructor.resolveFile(f);\n                }));\n\n              case 9:\n                this.files = _context.sent;\n                return _context.abrupt(\"return\", this);\n\n              case 11:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function resolveFiles() {\n        return _resolveFiles.apply(this, arguments);\n      }\n\n      return resolveFiles;\n    }()\n    /**\n     * Converts this APIMessage into an array of APIMessages for each split content\n     * @returns {APIMessage[]}\n     */\n\n  }, {\n    key: \"split\",\n    value: function split() {\n      if (!this.data) this.resolveData();\n      if (!Array.isArray(this.data.content)) return [this];\n      var apiMessages = [];\n\n      for (var i = 0; i < this.data.content.length; i++) {\n        var data = void 0;\n        var opt = void 0;\n\n        if (i === this.data.content.length - 1) {\n          data = _objectSpread(_objectSpread({}, this.data), {}, {\n            content: this.data.content[i]\n          });\n          opt = _objectSpread(_objectSpread({}, this.options), {}, {\n            content: this.data.content[i]\n          });\n        } else {\n          data = {\n            content: this.data.content[i],\n            tts: this.data.tts\n          };\n          opt = {\n            content: this.data.content[i],\n            tts: this.data.tts\n          };\n        }\n\n        var apiMessage = new APIMessage(this.target, opt);\n        apiMessage.data = data;\n        apiMessages.push(apiMessage);\n      }\n\n      return apiMessages;\n    }\n    /**\n     * Resolves a single file into an object sendable to the API.\n     * @param {BufferResolvable|Stream|FileOptions|MessageAttachment} fileLike Something that could be resolved to a file\n     * @returns {Object}\n     */\n\n  }, {\n    key: \"isWebhook\",\n    get: function get() {\n      var Webhook = require('./Webhook');\n\n      var WebhookClient = require('../client/WebhookClient');\n\n      return this.target instanceof Webhook || this.target instanceof WebhookClient;\n    }\n    /**\n     * Whether or not the target is a user\n     * @type {boolean}\n     * @readonly\n     */\n\n  }, {\n    key: \"isUser\",\n    get: function get() {\n      var User = require('./User');\n\n      var GuildMember = require('./GuildMember');\n\n      return this.target instanceof User || this.target instanceof GuildMember;\n    }\n    /**\n     * Whether or not the target is a message\n     * @type {boolean}\n     * @readonly\n     */\n\n  }, {\n    key: \"isMessage\",\n    get: function get() {\n      var Message = require('./Message');\n\n      return this.target instanceof Message;\n    }\n  }], [{\n    key: \"resolveFile\",\n    value: function () {\n      var _resolveFile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(fileLike) {\n        var attachment, name, findName, ownAttachment, resource;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                findName = function findName(thing) {\n                  if (typeof thing === 'string') {\n                    return Util.basename(thing);\n                  }\n\n                  if (thing.path) {\n                    return Util.basename(thing.path);\n                  }\n\n                  return 'file.jpg';\n                };\n\n                ownAttachment = typeof fileLike === 'string' || fileLike instanceof (browser ? ArrayBuffer : Buffer) || typeof fileLike.pipe === 'function';\n\n                if (ownAttachment) {\n                  attachment = fileLike;\n                  name = findName(attachment);\n                } else {\n                  attachment = fileLike.attachment;\n                  name = fileLike.name || findName(attachment);\n                }\n\n                _context2.next = 5;\n                return DataResolver.resolveFile(attachment);\n\n              case 5:\n                resource = _context2.sent;\n                return _context2.abrupt(\"return\", {\n                  attachment: attachment,\n                  name: name,\n                  file: resource\n                });\n\n              case 7:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function resolveFile(_x) {\n        return _resolveFile.apply(this, arguments);\n      }\n\n      return resolveFile;\n    }()\n    /**\n     * Partitions embeds and attachments.\n     * @param {Array<MessageEmbed|MessageAttachment>} items Items to partition\n     * @returns {Array<MessageEmbed[], MessageAttachment[]>}\n     */\n\n  }, {\n    key: \"partitionMessageAdditions\",\n    value: function partitionMessageAdditions(items) {\n      var embeds = [];\n      var files = [];\n\n      var _iterator = _createForOfIteratorHelper(items),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var item = _step.value;\n\n          if (item instanceof MessageEmbed) {\n            embeds.push(item);\n          } else if (item instanceof MessageAttachment) {\n            files.push(item);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return [embeds, files];\n    }\n    /**\n     * Transforms the user-level arguments into a final options object. Passing a transformed options object alone into\n     * this method will keep it the same, allowing for the reuse of the final options object.\n     * @param {StringResolvable} [content] Content to send\n     * @param {MessageOptions|WebhookMessageOptions|MessageAdditions} [options={}] Options to use\n     * @param {MessageOptions|WebhookMessageOptions} [extra={}] Extra options to add onto transformed options\n     * @param {boolean} [isWebhook=false] Whether or not to use WebhookMessageOptions as the result\n     * @returns {MessageOptions|WebhookMessageOptions}\n     */\n\n  }, {\n    key: \"transformOptions\",\n    value: function transformOptions(content, options) {\n      var extra = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var isWebhook = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n      if (!options && _typeof(content) === 'object' && !Array.isArray(content)) {\n        options = content;\n        content = undefined;\n      }\n\n      if (!options) {\n        options = {};\n      } else if (options instanceof MessageEmbed) {\n        return isWebhook ? _objectSpread({\n          content: content,\n          embeds: [options]\n        }, extra) : _objectSpread({\n          content: content,\n          embed: options\n        }, extra);\n      } else if (options instanceof MessageAttachment) {\n        return _objectSpread({\n          content: content,\n          files: [options]\n        }, extra);\n      }\n\n      if (Array.isArray(options)) {\n        var _this$partitionMessag = this.partitionMessageAdditions(options),\n            _this$partitionMessag2 = _slicedToArray(_this$partitionMessag, 2),\n            embeds = _this$partitionMessag2[0],\n            files = _this$partitionMessag2[1];\n\n        return isWebhook ? _objectSpread({\n          content: content,\n          embeds: embeds,\n          files: files\n        }, extra) : _objectSpread({\n          content: content,\n          embed: embeds[0],\n          files: files\n        }, extra);\n      } else if (Array.isArray(content)) {\n        var _this$partitionMessag3 = this.partitionMessageAdditions(content),\n            _this$partitionMessag4 = _slicedToArray(_this$partitionMessag3, 2),\n            _embeds = _this$partitionMessag4[0],\n            _files = _this$partitionMessag4[1];\n\n        if (_embeds.length || _files.length) {\n          return isWebhook ? _objectSpread({\n            embeds: _embeds,\n            files: _files\n          }, extra) : _objectSpread({\n            embed: _embeds[0],\n            files: _files\n          }, extra);\n        }\n      }\n\n      return _objectSpread(_objectSpread({\n        content: content\n      }, options), extra);\n    }\n    /**\n     * Creates an `APIMessage` from user-level arguments.\n     * @param {MessageTarget} target Target to send to\n     * @param {StringResolvable} [content] Content to send\n     * @param {MessageOptions|WebhookMessageOptions|MessageAdditions} [options={}] Options to use\n     * @param {MessageOptions|WebhookMessageOptions} [extra={}] - Extra options to add onto transformed options\n     * @returns {MessageOptions|WebhookMessageOptions}\n     */\n\n  }, {\n    key: \"create\",\n    value: function create(target, content, options) {\n      var extra = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      var Webhook = require('./Webhook');\n\n      var WebhookClient = require('../client/WebhookClient');\n\n      var isWebhook = target instanceof Webhook || target instanceof WebhookClient;\n      var transformed = this.transformOptions(content, options, extra, isWebhook);\n      return new this(target, transformed);\n    }\n  }]);\n\n  return APIMessage;\n}();\n\nmodule.exports = APIMessage;\n/**\n * A target for a message.\n * @typedef {TextChannel|DMChannel|User|GuildMember|Webhook|WebhookClient} MessageTarget\n */\n\n/**\n * Additional items that can be sent with a message.\n * @typedef {MessageEmbed|MessageAttachment|Array<MessageEmbed|MessageAttachment>} MessageAdditions\n */","map":null,"metadata":{},"sourceType":"module"}